#!/usr/bin/env python3

from __future__ import annotations

import argparse
import atexit
import base64
import ctypes
import ctypes.util
import dataclasses
import dbus
import errno
import fcntl
import gi
import glob
import ipaddress
import json
import math
import os
import random
import re
import requests
import shutil
import socket
import struct
import subprocess
import sys
import textwrap
import threading
import unittest
import yaml

gi.require_version("NM", "1.0")

from gi.repository import NM
from datetime import datetime
from termcolor import colored
from argparse import Namespace
from collections import defaultdict
from collections import Counter
from collections import deque
from datetime import datetime
from enum import Enum
from prettytable import PrettyTable, ALL, NONE, FRAME

import inspect
from io import StringIO
from requests import Response
from contextlib import redirect_stdout
from functools import partial
from dataclasses import dataclass
from typing import Tuple, Callable

import nacl.signing, nacl.public
from cryptography.hazmat.primitives.asymmetric.x25519 import X25519PrivateKey, X25519PublicKey

from noise.connection import NoiseConnection, Keypair


VERBOSE = False


PREFIX = '/etc'
NAME = 'vad'
RUN_DIR = '/var/run/vad'
LOCK_FILE = f'{RUN_DIR}/lock'
LOCK_FD = None
WIREGUARD_DIR = f'{PREFIX}/wireguard'
WIREGUARD_CONFIG = f'{WIREGUARD_DIR}/{NAME}-%s-%s.conf'
NAMESPACE_HOP = f'{NAME}-%s-%d'
DEVICE_NAME_HOP = f'{NAME}%d'
DESCRIPTION = f'{PREFIX}/wireguard/{NAME}.description'
CONFIGURATION = f'{PREFIX}/{NAME}/config.yaml'
WPA_SUPPLICANT_CONF = f'{PREFIX}/wpa_supplicant/{NAME}.conf'
PROVIDER_DIR = f'{PREFIX}/{NAME}'
MULLVAD_SERVERS = f'{PROVIDER_DIR}/mullvad.json'
NAMESPACE_ROOT = '1'
NAMESPACE_PHYSICAL = 'physical'
EUROPE_UNION = ["at", "be", "bg", "hr", "cy", "cz", "dk", "ee", "fi", "fr", "de", "gr", "hu", "ie", "it", "lv", "lt", "lu", "mt", "nl", "pl", "pt", "ro", "sk", "si", "es", "se"]
EUROPE_CONTINENT = EUROPE_UNION + ["is", "no", "li", "ch", "uk", "gb", "me", "mk", "al", "rs", "tr", "ba", "xk", "am", "az", "by", " md", "ge", "ua"]


ACTION_LISTEN = 0
ACTION_STOP_LISTEN = 1
ACTION_CONNECT = 2
ACTION_TEST = 3

RESPONSE_ACK = 10
RESPONSE_NCK = 11
RESPONSE_CLIENT_CONNECT = 12
RESPONSE_STOP_LISTING = 13


class PrettyTablePretty(PrettyTable):
    def __init__(self, field_names=None, **kwargs) -> None:
        super().__init__(field_names, **kwargs)
        # source: https://github.com/ITGlobal/CLI/blob/master/src/CLI.Table/Impl/PrettyGridTableStyleImpl.cs
        self.vertical_char = '│'
        self.horizontal_char = '─'
        self.top_left_junction_char = '┌'
        self.top_right_junction_char = '┐'
        self.bottom_left_junction_char = '└'
        self.bottom_right_junction_char = '┘'
        self.right_junction_char = '┤'
        self.left_junction_char = '├'
        self.bottom_junction_char = '┴'
        self.top_junction_char = '┬'
        self.junction_char = '┼'


class DeviceKind(Enum):
    Ethernet = 1
    Wifi = 2
    Virtual = 3


@dataclass
class Device:
    kind: DeviceKind
    name: str
    phy: str


@dataclass
class Multihop:
    peer: dict
    entry: dict
    exit: dict
    def pubkey(self):
        return self.exit['pubkey']
    def ipv4(self):
        return self.entry['ipv4_addr_in']
    def ipv6(self):
        return self.entry['ipv6_addr_in']
    def port(self):
        assert 'multihop_port' in self.entry
        assert 'multihop_port' in self.exit
        assert self.entry['vpn'] == 'mullvad'
        return int(self.exit['multihop_port'])
    def vpn(self):
        return self.entry['vpn']


@dataclass
class Hop:
    peer: dict
    server: dict
    def pubkey(self):
        return self.server['pubkey']
    def ipv4(self):
        return self.server['ipv4_addr_in']
    def ipv6(self):
        return self.server['ipv6_addr_in']
    def port(self):
        return 51820
    def vpn(self):
        return self.server['vpn']


@dataclass
class OnionVpnUrl:
    ipv4: str
    port_ip: str
    public_key: bytes

    def to_url(self) -> str:
        ipv4_bytes = ipaddress.IPv4Address(self.ipv4).packed
        port_ip_bytes = struct.pack('!H', int(self.port_ip))
        url = bytes([0, 0]) + ipv4_bytes + port_ip_bytes + self.public_key
        return base64.b32encode(url).decode('utf8').lower() + '.onion.vpn'

    def ed25519_public_key(self) -> Ed25519PublicKey:
        return Ed25519PublicKey.from_public_bytes(self.public_key)

    def __repr__(self) -> str:
        return self.to_url()

    @staticmethod
    def from_url(url: str) -> OnionVpnUrl:
        suffix = url[-10:]
        assert suffix == '.onion.vpn'
        url = url[:-10]
        url = base64.b32decode(url.upper())
        url = url[2:]
        ipv4 = str(ipaddress.IPv4Address(url[0:4]))
        port_ip = str(struct.unpack('!H', url[4:6])[0])
        public_key = url[6:]
        assert len(public_key) == 32
        return OnionVpnUrl(ipv4, port_ip, public_key)


MS_RDONLY = 1
MS_REC = 16384
MS_SLAVE = 1 << 19
MNT_DETACH = 2
CLONE_NEWNET = 0x40000000
CLONE_NEWNS = 0x00020000

LIBC = ctypes.CDLL(ctypes.util.find_library('c'), use_errno=True)
LIBC.setns.argtypes = (ctypes.c_int, ctypes.c_int)
LIBC.unshare.argtypes = (ctypes.c_int,)
LIBC.mount.argtypes = (ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_ulong, ctypes.c_char_p)
LIBC.umount2.argtypes = (ctypes.c_char_p, ctypes.c_int)

def setns(fd: int, nstype: int):
    return LIBC.setns(fd, nstype)

def unshare(flags: int):
    return LIBC.unshare(flags)

def mount(source: str, target: str, fstype: str, flags: int, data: str):
    return LIBC.mount(source.encode(), target.encode(), fstype.encode(), flags, data.encode())

def umount2(target: str, flags: int):
    return LIBC.umount2(target.encode(), flags)

class NetworkNamespace:
    """
    This class follows how `ip netns exec ...` switches to network namespaces.
    <https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/tree/lib/namespace.c?h=v6.7.0#n45>
    """
    def __init__(self, namespace_name: str):
        self.namespace_name = namespace_name
        self.current_net_ns = None
        self.target_net_ns = None

    def __enter__(self):
        if self.namespace_name == NAMESPACE_ROOT:
            return

        log_verbose("Enter network namespace %s" % self.namespace_name)

        try:
            self.current_mnt_ns = os.open('/proc/self/ns/mnt', os.O_RDONLY|os.O_CLOEXEC)
            self.current_net_ns = os.open('/proc/self/ns/net', os.O_RDONLY|os.O_CLOEXEC)
            self.target_net_ns = os.open(f'/var/run/netns/{self.namespace_name}', os.O_RDONLY|os.O_CLOEXEC)
        except OSError as e:
            log_fatal("Failed to change netns to '%s' (%s)" % (self.namespace_name, str(e)))

        if setns(self.target_net_ns, CLONE_NEWNET) < 0:
            errmsg = os.strerror(ctypes.get_errno())
            log_fatal("Failed to change netns to '%s' (%s)" % (self.namespace_name, errmsg))

        os.close(self.target_net_ns)

        if unshare(CLONE_NEWNS) < 0:
            errmsg = os.strerror(ctypes.get_errno())
            log_fatal("Unshare mount namespace failed: %s" % (errmsg))

        if mount("none", "/", "none", MS_SLAVE | MS_REC, "") < 0:
            errmsg = os.strerror(ctypes.get_errno())
            log_fatal("mount namespace failed: '%s' (%s)" % (self.namespace_name, errmsg))

        mountflags = 0
        if umount2("/sys", MNT_DETACH) < 0:
            info = os.statvfs("/sys")
            if info.f_flag & os.ST_RDONLY:
                mountflags = MS_RDONLY

        if mount("none", "/sys", "sysfs", mountflags, "") < 0:
            errmsg = os.strerror(ctypes.get_errno())
            log_fatal("mount of /sys failed: %s" % (errmsg))

    def __exit__(self, *args):
        if self.namespace_name == NAMESPACE_ROOT:
            return

        if umount2("/sys", 0) < 0:
            errmsg = os.strerror(ctypes.get_errno())
            log_fatal("Failed to unmount sysfs: %s" % (errmsg))
        if setns(self.current_mnt_ns, 0) < 0:
            errmsg = os.strerror(ctypes.get_errno())
            log_fatal("Failed to change netns back: %s" % (errmsg))
        if setns(self.current_net_ns, 0) < 0:
            errmsg = os.strerror(ctypes.get_errno())
            log_fatal("Failed to change netns back: %s" % (errmsg))
        os.close(self.current_mnt_ns)
        os.close(self.current_net_ns)

        log_verbose("Leave network namespace %s" % self.namespace_name)


class Abort(Exception):
    pass


class CommandFailed(Abort):
    def __init__(self, returncode):
        self.returncode = returncode


class UDPSocket:
    def __init__(self, sock: socket.socket, address: Tuple[str, int]):
        self.sock = sock
        self.address = address

    def settimeout(self, timeout):
        self.sock.settimeout(timeout)

    def send(self, data: bytes):
        self.sock.sendto(data, self.address)

    def recv(self, count: int):
        data, address = self.sock.recvfrom(count)
        assert self.address == address
        return data


class NoiseUDPSocket:
    def __init__(self, noise: NoiseConnection, udp: UDPSocket, public_key: bytes = None):
        self.noise = noise
        self.udp = udp
        self.address = udp.address
        self.public_key = public_key

    def settimeout(self, timeout):
        self.udp.settimeout(timeout)

    def send(self, data: bytes):
        message = self.noise.encrypt(data)
        self.udp.send(message)

    def recv(self, count: int):
        message = self.udp.recv(count)
        data = self.noise.decrypt(message)
        return data


class InterceptRemoteStaticPublicKey:
    def __init__(self, noise: NoiseConnection):
        self.noise = noise
        self.func = self.noise.noise_protocol.handshake_done
        self.public_key = None

    def __enter__(self):
        def handshake_done():
            self.public_key = self.noise.noise_protocol.handshake_state.rs.public_bytes
            self.func()
        self.noise.noise_protocol.handshake_done = handshake_done
        return self

    def __exit__(self, *args):
        self.noise.noise_protocol.handshake_done = self.func


def initiator_do_handshake(name, udp: UDPSocket, conn: NoiseConnection) -> NoiseUDPSocket:
    print(f'{name}: Handshake')
    conn.set_as_initiator()
    conn.start_handshake()

    with InterceptRemoteStaticPublicKey(conn) as intercept:
        print(f'{name}: Handshake send to %s:%d' % udp.address)
        message = conn.write_message()
        udp.send(message)
        print(f'{name}: Handshake receive...')
        received = udp.recv(2048)
        print(f'{name}: Handshake received from %s:%d' % udp.address)
        payload = conn.read_message(received)
        assert conn.handshake_finished
        print(f'{name}: Handshake done')
        return NoiseUDPSocket(conn, udp, intercept.public_key)


def responder_do_handshake(name, udp: UDPSocket, conn: NoiseConnection) -> NoiseUDPSocket:
    udp.settimeout(5)
    print(f'{name}: Handshake')
    conn.set_as_responder()
    conn.start_handshake()

    with InterceptRemoteStaticPublicKey(conn) as intercept:
        print(f'{name}: Handshake receive from %s:%d' % udp.address)
        data = udp.recv(2048)
        conn.read_message(data)
        print(f'{name}: Handshake send to %s:%d' % udp.address)
        ciphertext = conn.write_message()
        udp.send(ciphertext)
        assert conn.handshake_finished
        print(f'{name}: Handshake done')
        return NoiseUDPSocket(conn, udp, intercept.public_key)


class ProxyPeer:
    def __init__(self, udp: UDPSocket):
        self.udp = udp
        self.public_key = None
        self.handler = None

    def handle(self):
        self.handler()


class Proxy:
    def __init__(self, key: X25519PrivateKey, port: int):
        self.key = key
        self.port = port
        self.peers = {}
        self.listener = {}
        self.listener_peers = deque([], 10000)

    def start(self):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.settimeout(10)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind(('0.0.0.0' , self.port))
            while True:
                try:
                    print('Proxy: Waiting for messages...')
                    data, address = sock.recvfrom(0, socket.MSG_PEEK)
                    if address not in self.peers:
                        print('Proxy: New peer')
                        peer = ProxyPeer(UDPSocket(sock, address))
                        self.peers[address] = peer
                        self.peers[address].handler = partial(self.state_handshake, peer)
                    self.peers[address].handler()
                except TimeoutError:
                    continue
        finally:
            sock.close()

    def state_handshake(self, peer: ProxyPeer):
        noise = NoiseConnection.from_name(b'Noise_IK_25519_ChaChaPoly_BLAKE2s')
        noise.set_keypair_from_private_bytes(Keypair.STATIC, self.key.private_bytes_raw())
        peer.udp = responder_do_handshake('Proxy', peer.udp, noise)
        peer.public_key = peer.udp.public_key
        peer.handler = partial(self.state_normal, peer)

    def state_normal(self, peer: ProxyPeer):
        data = peer.udp.recv(2048)
        assert len(data) >= 1

        action = data[0]
        key = data[1:]
        unkown = False

        print('Proxy: Received action from %s:%d:' % peer.udp.address, action, len(data))
        if len(key) == 0:
            if action == ACTION_TEST:
                print('Proxy: Send reflexive address %s:%d' % peer.udp.address)
                peer.udp.send(bytes([RESPONSE_ACK]) + ipv4_pack(*peer.udp.address))
            elif action == ACTION_LISTEN:
                assert peer.public_key is not None
                if not peer.public_key in self.listener:
                    print('Proxy: Add listener for %s:%d' % peer.udp.address, to_base64(peer.public_key))
                    if self.listener_peers.maxlen == len(self.listener_peers):
                        removed_peer = self.listener_peers.popleft()
                        removed_peer.udp.send(bytes([RESPONSE_STOP_LISTING]))
                    self.listener_peers.append(peer)
                else:
                    print('Proxy: Update listener for %s:%d' % peer.udp.address)
                    old_peer_address = self.listener[peer.public_key]
                    if old_peer_address != peer.udp.address:
                        print('Proxy: Remove old listener')
                        del self.peers[old_peer_address]
                self.listener[peer.public_key] = peer.udp.address
                peer.udp.send(bytes([RESPONSE_ACK]))
            elif action == ACTION_STOP_LISTEN:
                self.listener_peers.remove(peer)
                del self.listener[peer.public_key]
                peer.udp.send(bytes([RESPONSE_ACK]))
            else:
                unkown = True
        elif len(key) == 32:
            if action == ACTION_CONNECT:
                print('Proxy: Connect %s:%d' % peer.udp.address, to_base64(key))
                if key in self.listener:
                    other_peer = self.peers[self.listener[key]]
                    assert peer.public_key is not None
                    other_peer.udp.send(bytes([RESPONSE_CLIENT_CONNECT]) + ipv4_pack(*peer.udp.address) + peer.public_key)
                    peer.udp.send(bytes([RESPONSE_ACK]) + ipv4_pack(*self.listener[key]))
                else:
                    peer.udp.send(bytes([RESPONSE_NCK]))
            else:
                unkown = True
        else:
            unkown = True

        if unkown:
            print('Proxy: Received an unkown message that will be ignored')


class MullvadError(Exception):
    pass


class MullvadParseError(Exception):
    pass


@dataclasses.dataclass
class MullvadBase:
    def to_dict(self) -> str:
        def serialize(object):
            if isinstance(object, datetime):
                return object.strftime("%Y-%m-%dT%H:%M:%S+00:00")
            else:
                return str(object)
        data = dataclasses.asdict(self)
        for key, value in data.items():
            data[key] = serialize(value)
        return data

    @staticmethod
    def parse(ds: type, data: dict):
        # NOTE: This requires that all fields a present and does basic type checking.
        #       Additional type checking can be done in the subclasses.
        for field in dataclasses.fields(ds):
            if not field.name in data:
                raise MullvadParseError("Missing field '%s'!")
            data_type = type(data[field.name]).__name__
            if field.type == 'datetime' and data_type == 'str':
                pass
            elif data_type != field.type:
                raise MullvadParseError("Type missmatch for field '%s', should be %s but is %s!" % (field.name, field.type, data_type))
            if field.type == 'datetime':
                try:
                    data[field.name] = datetime.strptime(data[field.name], "%Y-%m-%dT%H:%M:%S+00:00")
                except Exception as e:
                    raise MullvadParseError("Could not parse datetime field '%s' with '%s'!", field.name, data[field.name]) from e

        return ds(**data)


@dataclasses.dataclass
class MullvadToken(MullvadBase):
    access_token: str
    expiry: datetime

    @staticmethod
    def from_dict(data: dict) -> MullvadToken:
        return MullvadBase.parse(MullvadToken, data)


@dataclasses.dataclass
class MullvadAccount(MullvadBase):
    id: str
    expiry: datetime
    max_ports: int
    max_devices: int
    can_add_ports: bool
    can_add_devices: bool

    @staticmethod
    def from_dict(data: dict) -> MullvadAccount:
        return MullvadBase.parse(MullvadAccount, data)

    def is_active(self):
        return self.expiry > datetime.now()

    def can_add_peers(self):
        return self.can_add_devices

    def max_peers(self):
        return self.max_devices


@dataclasses.dataclass
class MullvadPeer(MullvadBase):
    id: str
    name: str
    pubkey: str
    hijack_dns: bool
    created: datetime
    ipv4_address: str
    ipv6_address: str
    ports: list

    @staticmethod
    def from_dict(data: dict) -> MullvadPeer:
        return MullvadBase.parse(MullvadPeer, data)


@dataclasses.dataclass
class MullvadRelay(MullvadBase):
    hostname: str
    country_code: str
    country_name: str
    city_code: str
    city_name: str
    fqdn: str
    active: bool
    owned: bool
    provider: str
    ipv4_addr_in: str
    ipv6_addr_in: str
    network_port_speed: int
    stboot: bool
    pubkey: str
    multihop_port: int
    socks_name: str
    socks_port: int
    daita: bool
    type: str
    status_messages: list

    @staticmethod
    def from_dict(data: dict) -> MullvadRelay:
        return MullvadRelay.parse(MullvadRelay, data)


class Mullvad:
    def __init__(self):
        self.api_url = "https://api.mullvad.net/"
        self.session = requests.Session()

    def __enter__(self):
        return self

    def __exit__(self, exception_type, exception_value, exception_traceback):
        return False

    def do(self, name: str, request: requests.Request, status_codes: List[int]):
        try:
            response = self.session.send(request.prepare())
        except Exception as e:
            raise MullvadError("%s failed!" % name) from e
        if response.status_code not in status_codes:
            if 'Content-Type' in response.headers and response.headers['Content-Type'] == 'application/json':
                error = response.json()
                if 'code' in error:
                    raise MullvadError("%s failed! Got status code %d but expected one of %s. With error code: %s." % (name, response.status_code, status_codes, error['code']))
            raise MullvadError("%s failed! Got status code %d but expected one of %s." % (name, response.status_code, status_codes))
        return response

    def connected(self):
        response = self.do(
            "Mullvad: Test if connected",
            requests.Request('GET', 'https://ipv4.am.i.mullvad.net/json'),
            [200],
        )
        data = response.json()
        return data['mullvad_exit_ip'], data['ip']

    def relays(self):
        response = self.do(
            "Mullvad: Fetch relays",
            requests.Request('GET', 'https://api.mullvad.net/www/relays/all'),
            [200],
        )
        relays = []
        for relay in response.json():
            if relay['type'] == 'wireguard':
                relays.append(MullvadRelay.from_dict(relay))
        return relays

    def authenticate(self, account_number: str, access_token: Optional[MullvadToken] = None):
        return MullvadAuth(account_number, access_token)


class MullvadAuth(Mullvad):
    def __init__(self, account_number: str, access_token: Optional[MullvadToken] = None):
        self.account_number = account_number
        self.access_token = access_token
        super().__init__()

    def __enter__(self):
        return self

    def __exit__(self, exception_type, exception_value, exception_traceback):
        self.logout()
        return False

    def do_authenticated(self, name: str, request: requests.Request, status_codes: List[int]):
        self.login()
        request.headers['Authorization'] = f'Bearer {self.access_token.access_token}'
        return self.do(name, request, status_codes)

    def login(self):
        if self.access_token is not None and self.access_token.expiry > datetime.now():
            return
        response = self.do(
            "Mullvad: Login",
            requests.Request('POST', self.api_url + "auth/v1/token", json={'account_number': self.account_number}),
            [200]
        )
        self.access_token = MullvadToken.from_dict(response.json())

    def logout(self):
        self.access_token = None
        if self.session is not None:
            self.session.close()

    def account(self) -> MullvadAccount:
        response = self.do_authenticated(
            "Mullvad: Get account information",
            requests.Request('GET', self.api_url + "accounts/v1/accounts/me"),
            [200]
        )

        return MullvadAccount.from_dict(response.json())

    def peers(self) -> List[MullvadPeer]:
        response = self.do_authenticated(
            "Mullvad: Get all wireguard peers (devices)",
            requests.Request('GET', self.api_url + "accounts/v1/devices"),
            [200]
        )

        peers = []
        for peer in response.json():
            peers.append(MullvadPeer.from_dict(peer))
        return peers

    def peer_by_public_key(self, public_key: str) -> MullvadPeer|None:
        for peer in self.peers():
            if peer.pubkey == public_key:
                return peer
        return None

    def peer_create(self, public_key: str, hijack_dns: bool = True):
        response = self.do_authenticated(
            "Mullvad: Create wireguard peer",
            requests.Request('POST', self.api_url + "accounts/v1/devices", json={'pubkey': public_key, 'hijack_dns': hijack_dns}),
            [201]
        )
        return MullvadPeer.from_dict(response.json())

    def peer_remove(self, public_key: str):
        title = "Mullvad: Remove wireguard peer"

        peer = self.peer_by_public_key(public_key)

        if peer is None:
            raise MullvadError('%s failed! Could not find peer with given public key!')

        self.do_authenticated(
            title,
            requests.Request('DELETE', self.api_url + f"accounts/v1/devices/{peer.id}"),
            [204]
        )

    def peer_update_pubkey(self, public_key: str, public_key_new: str, hijack_dns: bool = True):
        title = "Mullvad: Update public key of wireguard peer"

        peer = self.peer_by_public_key(public_key)

        if peer is None:
            raise MullvadError('%s failed! Could not find peer with given public key!')

        response = self.do_authenticated(
            title,
            requests.Request('PUT', self.api_url + f"accounts/v1/devices/{peer.id}/pubkey", json={'pubkey': public_key_new, 'hijack_dns': hijack_dns}),
            [200]
        )

        return MullvadPeer.from_dict(response.json())


def punch_hole(name, udp: UDPSocket, number_of_messages=10):
    count = 0
    failure = 0
    udp.settimeout(1)
    while True:
        try:
            print(f'{name}: Punchy punchy hole to %s:%d' % udp.address[0:2], end='')
            udp.send(b'')
            data = udp.recv(0)
            if len(data) == 0:
                print(' (success)')
                count += 1
                if count == number_of_messages:
                    break
        except TimeoutError as error:
            failure += 1
            if failure > 10:
                raise error
            continue

    try:
        while True:
            data, address = udp.sock.recvfrom(2048, socket.MSG_PEEK)
            if len(data) == 0:
                udp.recv(0)
            else:
                break
    except TimeoutError:
        pass


def get_socket_proxy_client(proxy_address, port=0):
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(5)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(('0.0.0.0', port))
    return UDPSocket(sock, proxy_address)


def get_socket_proxy_client6(proxy_address, port=0):
    sock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
    sock.settimeout(5)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(('::', port))
    return UDPSocket(sock, proxy_address)


def nop_colored(text, *args, **kwargs):
    return text


if not sys.stdout.isatty() or not sys.stderr.isatty():
    colored = nop_colored


already_locked = False


def lock():
    global already_locked
    if already_locked:
        return
    os.makedirs(RUN_DIR, exist_ok=True)
    fd = open(LOCK_FILE, 'a')
    fcntl.lockf(fd, fcntl.LOCK_EX)
    fd.write('%s\n' % os.getpid())
    fd.flush()
    LOCK_FD = fd
    already_locked = True
    atexit.register(unlock)


def unlock():
    if LOCK_FD is None:
        return
    fd = LOCK_FD
    sys.stdout.flush()
    fcntl.lockf(fd, fcntl.LOCK_UN)
    fd.truncate(0)
    fd.close()


def become_root(do_lock=True):
    if os.geteuid() != 0:
        os.execvp("sudo", ["sudo", "-E"] + sys.argv)

    # NOTE: Everytime we become root, we want usually do some atomic
    # operation, to prevent race conditions, we want to serialize the execution with
    # a file lock
    if do_lock:
        try:
            lock()
        except Exception as e:
            log_fatal("Can not acquire file lock (%s)!" % str(e))


def log_verbose(text, **kwargs):
    if VERBOSE:
        print(colored(text, 'cyan'), **kwargs)


def log_info(text, highlight=False, **kwargs):
    attrs=[]
    if highlight:
        attrs=['bold']
    print(colored(text, 'blue', attrs=attrs), **kwargs)


def log(text, **kwargs):
    print(text, **kwargs)


def log_good(text, **kwargs):
    print(colored(text, 'green'), **kwargs)


def log_success(text, **kwargs):
    print(colored(text, 'green', attrs=['bold']), **kwargs)


def log_warn(text, **kwargs):
    print(colored(text, 'yellow'), **kwargs)


def log_fatal(text, **kwargs):
    log_bad(text, **kwargs)
    raise Abort


def log_bad(text, **kwargs):
    print(colored(text, 'red'), **kwargs)


def print_command(process, print_output=True, **kwargs):
    command = subprocess.list2cmdline(process.args)
    command = command.replace('\n','\\n')

    if process.returncode == 0:
        log_good('+ ' + command)
    else:
        log_bad('- ' + command)

    if print_output and len(process.stdout) > 0:
        lines = str(process.stdout, 'utf8')
        lines = lines.split('\n')
        output = '\n  '.join(lines)
        output = output.strip()
        print('  ' + output)


def to_base64(data: bytes) -> str:
    return base64.b64encode(data).decode('utf8')


def from_base64(data: str) -> str:
    return base64.b64decode(data)


# TODO:: Hardcoded and DNS names are not supported at the moment, you need to replace 'proxy' with you public ip address!
PROXY_ADDRESS = ('proxy', 50398)
PROXY_KEY = X25519PrivateKey.from_private_bytes(from_base64('KEGMxadHKE4F0dtQ/SiYYL5/EnW6xlXna1dTF+pj8n4='))
SERVICE_KEY = X25519PrivateKey.from_private_bytes(from_base64('+Gnm7XzLwm+ioOaVBca3ZS1UL2bklpaYD/688rnOV24='))



def ipv4_pack(ip, port):
    ip = ipaddress.IPv4Address(ip).packed
    port = struct.pack('!H', port)
    return ip + port


def ipv4_unpack(data):
    assert len(data) == 6
    ip = data[0:4]
    port = data[4:6]
    return str(ipaddress.IPv4Address(ip)), struct.unpack('!H', port)[0]


assert ipv4_unpack(ipv4_pack('127.0.0.1', 6666)) == ('127.0.0.1', 6666)


def run(args, failure_ok=False, print_output=True, as_user=False, in_namespace=NAMESPACE_ROOT, **kwargs):
    if as_user:
        uid = os.getenv('SUDO_UID', os.geteuid())
        gid = os.getenv('SUDO_GID', os.getegid())
        args = ['sudo', '-E', '-u', '#%s' % uid, '-g', '#%s' % gid, "--"] + args

    if in_namespace != NAMESPACE_ROOT:
        args = ["ip", "netns", "exec", in_namespace] + args

    if VERBOSE:
        command = subprocess.list2cmdline(args)
        command = command.replace('\n','\\n')
        if sys.stdout.isatty() and sys.stderr.isatty():
            log_info('= ' + command + '\r', end='')

    process = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, **kwargs)

    if VERBOSE:
        print_command(process, print_output=print_output, **kwargs)
    elif not failure_ok and process.returncode != 0:
        print_command(process, print_output=print_output, **kwargs)

    return process


def run_in_namespace(namespace: str, args: list[str], **kwargs):
    return run(args, in_namespace=namespace, **kwargs)


def run_or_fail(args, **kwargs):
    process = run(args, **kwargs)
    if process.returncode != 0:
        raise CommandFailed(process.returncode)
    return process


def run_in_namespace_or_fail(namespace: str, args: list[str], **kwargs):
    return run_or_fail(args, in_namespace=namespace, **kwargs)


def device_move_to_physical(device: Device):
    log_verbose("Move device '%s' into %s namespace:" % (device.name, NAMESPACE_PHYSICAL))

    run_or_fail(["ip", "link", "set", device.name, "down"])
    run_or_fail(["resolvconf", "-f", "-d", '%s.*' % device.name])

    if device.kind == DeviceKind.Ethernet:
        run_or_fail(["ip", "link", "set", device.name, "netns", NAMESPACE_PHYSICAL])
    elif device.kind == DeviceKind.Wifi:
        run_or_fail(["iw", "phy", device.phy, "set", "netns", "name", NAMESPACE_PHYSICAL])
        run_or_fail(["ip", "netns", "exec", NAMESPACE_PHYSICAL, "wpa_supplicant", "-B", "-c", WPA_SUPPLICANT_CONF, "-i", device.name])
    else:
        assert False

    run_or_fail(["ip", "netns", "exec", NAMESPACE_PHYSICAL, "dhcpcd", "-b", device.name])


def wireguard_init(namespace: str, device_name: str, namespace_link_to: str, private_key: str, listen_port=51820):
    log_verbose(f"Init wireguard device '%s' in namespace %s and move to namespace %s" % (
        device_name,
        namespace_link_to,
        namespace,
    ))

    run_in_namespace_or_fail(namespace_link_to, ["ip", "link", "add", device_name, "type", "wireguard"])
    run_in_namespace_or_fail(namespace_link_to, ["ip", "link", "set", device_name, "netns", namespace])

    configuration_filename = WIREGUARD_CONFIG % (namespace, device_name)

    if os.path.exists(configuration_filename):
        log_fatal("Configuration %s already exists!" % configuration_filename)

    with open(configuration_filename, 'w') as c:
        wireguard_config = f"""
            [Interface]
            PrivateKey = {private_key}
            ListenPort = {listen_port}
            """
        wireguard_config = wireguard_config.strip()
        wireguard_config = '\n'.join([line.strip() for line in wireguard_config.split('\n')])
        c.write(wireguard_config)

    run_in_namespace_or_fail(namespace, ["wg", "setconf", device_name, configuration_filename])


def wireguard_device_setup(namespace: str, device_name: str, ipv4: str, ipv6: str, mtu: int = 1420):
    log_verbose(f"Setup wireguard device '%s' in namespace %s (ipv4=%s, ipv6=%s, mtu=%s)" % (
        device_name,
        namespace,
        ipv4,
        ipv6,
        mtu
    ))

    if ipv4 is not None:
        run_in_namespace_or_fail(namespace, ["ip", "addr", "add", ipv4, "dev", device_name])
    if ipv6 is not None:
        run_in_namespace_or_fail(namespace, ["ip", "addr", "add", ipv6, "dev", device_name])
    run_in_namespace_or_fail(namespace, ["ip", "link", "set", device_name, "up"])
    run_in_namespace_or_fail(namespace, ["ip", "link", "set", device_name, "mtu", str(mtu)])
    run_in_namespace_or_fail(namespace, ["ip", "route", "add", "default", "dev", device_name])
    # run_in_namespace_or_fail(namespace, ["ip", "route", "add", "::/0", "dev", device_name])


def wireguard_add_peer(namespace:str, device_name:str, public_key:str, endpoint:str=None, allowed_ips:str='0.0.0.0/0,::0/0', persistent_keepalive:int=0):
    log_verbose("Add wireguard peer to %s in namespace %s" % (device_name, namespace))
    command = ['wg', 'set', device_name, 'peer', public_key]
    if endpoint is not None:
        command.extend(['endpoint', endpoint])
    command.extend(['allowed-ips', allowed_ips])
    command.extend(['persistent-keepalive', str(persistent_keepalive)])
    run_in_namespace_or_fail(namespace, command)


def update_resolvconf(dns):
    log_verbose('Update `resolvconf` with nameserver %s:' % dns)
    with subprocess.Popen(['resolvconf', '-a', '%s.vad' % DEVICE_NAME_HOP % 0], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) as process:
        process.stdin.write(bytes('nameserver %s\n' % dns, 'utf8'))
        process.stdin.close()
        stdout = process.stdout.read()
        process.stdout.close()
        process.stdout = stdout
    if VERBOSE:
        print_command(process)
    run(['resolvconf', '-u'])


# TODO: Revist this function
def is_active():
    configuration_filename = WIREGUARD_CONFIG % (NAMESPACE_ROOT, DEVICE_NAME_HOP % 0)

    any_exists = os.path.exists(configuration_filename) or os.path.exists(DESCRIPTION)
    all_exists = os.path.exists(configuration_filename) and os.path.exists(DESCRIPTION)

    if not any_exists == all_exists:
        log_warn('Warning: If the VPN is active or inactive two things should exist or not exist:')
        log_warn('- %s (%s) and' % (DESCRIPTION, os.path.exists(DESCRIPTION)))
        log_warn('- %s (%s)' % (configuration_filename, os.path.exists(configuration_filename)))

    return (
        os.path.exists(configuration_filename) or
        os.path.exists(DESCRIPTION)
    )


def get_dns_server_from_flags(flags):
    bits = 0
    for flag in flags:
        if flag == 'a':
            bits |= 1
        elif flag == 't':
            bits |= 1<<1
        elif flag == 'm':
            bits |= 1<<2
        elif flag == 'p':
            bits |= 1<<3
        elif flag == 'g':
            bits |= 1<<4
        else:
            log_warn('Unkown flag "%s" for DNS server, we will ignore it!' % flag)

    if bits == 0:
        return '10.64.0.1'
    else:
        return '100.64.0.%d' % bits


def load_servers():
    servers = []
    if not os.path.exists(MULLVAD_SERVERS):
        log_fatal('%s does not exists, please use `vad update`, `vad up --update-server-list` or `vad init`.' % MULLVAD_SERVERS)
    for provider_filename in glob.glob(os.path.join(PROVIDER_DIR, '*.json')):
        provider = os.path.basename(provider_filename)
        provider = provider.replace('.json', '')
        with open(provider_filename, 'r') as f:
            provider_servers = json.load(f)
            for provider_server in provider_servers:
                provider_server['vpn'] = provider
            servers.extend(provider_servers)

    return servers


def filter_servers(type='wireguard', owned=None, active=None, country_city_hostname=None, servers=None):
    if servers is None:
        servers = load_servers()

    if type is not None:
        servers = filter(lambda server: server['type'] == type, servers)

    if owned is not None:
        servers = filter(lambda server: server['owned'] == owned, servers)

    if active is not None:
        servers = filter(lambda server: server['active'] == active, servers)

    if country_city_hostname is not None and not country_city_hostname == 'w':
        if country_city_hostname == 'eu':
            servers = filter(lambda server: server['country_code'] in EUROPE_UNION, servers)
        elif country_city_hostname == 'ec':
            servers = filter(lambda server: server['country_code'] in EUROPE_CONTINENT, servers)
        elif len(country_city_hostname) == 2:
            servers = filter(lambda server: server['country_code'] == country_city_hostname, servers)
        elif len(country_city_hostname) == 3:
            servers = filter(lambda server: server['city_code'] == country_city_hostname, servers)
        elif len(country_city_hostname) >= 4:
            servers = filter(lambda server: country_city_hostname in server['hostname'], servers)
        else:
            servers = []

    servers = list(servers)
    return servers


def server_random_choice(servers, uniform_by_country=False):
    if uniform_by_country:
        countries = set()
        for server in servers:
            countries.add(server['country_code'])
        countries = list(countries)
        if len(countries) == 0:
            return None
        country = random.choice(countries)
        servers = filter_servers(country_city_hostname=country, servers=servers)
    if len(servers) == 0:
        return None
    return random.choice(servers)


def verify_account_number(account_number):
    # NOTE: https://mullvad.net/en/blog/2017/6/20/mullvads-account-numbers-get-longer-and-safer
    if len(account_number) in [12, 13, 16] or not account_number.isdigit():
        return False
    return True


def user_request_account_number(passname, config):
    if 'account_number' in config:
        return config['account_number']

    try:
        uid = os.getenv('SUDO_UID', os.geteuid())
        gid = os.getenv('SUDO_GID', os.getegid())
        process = run(['sudo', '-E', '-u', '#%s' % uid, '-g', '#%s' % gid, 'pass', passname], failure_ok=True)
        if process.returncode == 0:
            lines = str(process.stdout, 'utf8')
            lines = lines.split('\n')
            if len(lines) >= 1:
                account_number = lines[0]
                if len(account_number) == 16:
                    return account_number
    except FileNotFoundError:
        pass

    while True:
        account_number = input("Please enter your Mullvad account number (with or w/o spaces): ")
        account_number = account_number.replace(" ", "")
        if verify_account_number(account_number):
            print("The account number must have 12, 13 or 16 digits!")
            continue
        return account_number


def config_load(filename):
    if not os.path.exists(filename):
        return False

    with open(filename) as c:
        config = yaml.safe_load(c)
    for key in config:
        if config[key] is None:
            config[key] = ''
    return config


def config_save(filename, config):
    assert isinstance(config, dict)
    with open(filename, 'w') as c:
        yaml.dump(config, c)
    os.chmod(filename, 0o600)
    return config


def config_save_up_command(config, args):
    args_to_save = dict(vars(args))

    del args_to_save['func']
    del args_to_save['verbose']
    del args_to_save['print_args']
    del args_to_save['no_color']

    del args_to_save['dry_run']
    del args_to_save['dont_save']

    config['up_command'] = args_to_save
    return config_save(args.config, config)


def config_execute_commands(config, subsection_name):
    subsection = config.get(subsection_name, [])
    if not isinstance(subsection, list):
        return
    if subsection:
        log_verbose("Execute commands from '%s':" % (subsection_name))
        for command in subsection:
            run(['bash', '-c', command.replace('\\n', '\n')])


def config_set_up_command_attributes(config, args):
    up_command = config.get('up_command', {})
    for key, value in up_command.items():
        setattr(args, key, value)


def config_rebuild_up_command(config, parser_up):
    up_command = config.get('up_command', {})

    cmdline = ['vad', 'up']

    order = [
        'update_server_list',
        'dns',
        'without_multihop'
        'uniform_by_country',
        'owned_entry',
        'only_use_ipv6',
        'COUNTRY_CITY_HOSTNAME',
    ]

    defaults = dict(vars(parser_up.parse_args([])))

    for name in order:
        if name not in up_command:
            continue
        if name not in defaults:
            continue
        value = up_command[name]
        if defaults[name] == value:
            continue
        if name == 'COUNTRY_CITY_HOSTNAME':
            cmdline.extend(value)
        elif name == 'dns':
            cmdline.append('--dns')
            if isinstance(value, list):
                cmdline.append(value[0])
            else:
                cmdline.append(value)
        elif isinstance(defaults[name], bool) and value:
            cmdline.append('--%s' % name.replace('_', '-'))
        else:
            assert False, "Can not handle %s attribute!" % name

    return subprocess.list2cmdline(cmdline)


def init_command(args):
    become_root()

    config = config_load(args.config)

    peers = config.get('peers', [])
    if len(peers) > 0:
        log_fatal('Already initialized with at least one peer. If you want to add a new peer, use `vad add`.')

    if len(peers) == 0:
        update_command(None)

    account_number = user_request_account_number(args.passname, config)

    access_token = None
    if 'mullvad' in config:
        access_token = MullvadToken.from_dict(config['mullvad'])

    with Mullvad().authenticate(account_number, access_token) as mullvad:
        mullvad.login()
        config['mullvad'] = mullvad.access_token.to_dict()
        config = config_save(args.config, config)
        config = add_command(args)

        if args.dont_save_account_number:
            if 'account_number' in config:
                del config['account_number']
        else:
            config['account_number'] = account_number

        config = config_save(args.config, config)
        log_info('Initialized with one peer, you can now use `vad up`')

    return config


def add_command(args):
    become_root()

    config = config_load(args.config)

    account_number = user_request_account_number(args.passname, config)

    access_token = None
    if 'mullvad' in config:
        access_token = MullvadToken.from_dict(config['mullvad'])

    with Mullvad().authenticate(account_number, access_token) as mullvad:
        mullvad.login()
        config['mullvad'] = mullvad.access_token.to_dict()
        config = config_save(args.config, config)

        account = mullvad.account()

        if not account.is_active():
            log_fatal('Your account is expired (since %s)!' % account['expires'])

        if not account.can_add_peers():
            log_fatal('You can not add more peers to your account, your account is full!')

        private_key = generate_private_key()
        public_key = get_public_key(private_key)

        peer: MullvadPeer = mullvad.peer_create(public_key)

        config['peers'].append(dict(
            private_key=private_key,
            ipv4=peer.ipv4_address,
            ipv6=peer.ipv6_address,
            provider='mullvad',
        ))

        config = config_save(args.config, config)
        log_info('New peer added')

    return config


def delete_command(args):
    become_root()

    config = config_load(args.config)

    account_number = user_request_account_number(args.passname, config)

    access_token = None
    if 'mullvad' in config:
        access_token = MullvadToken.from_dict(config['mullvad'])

    with Mullvad().authenticate(account_number) as mullvad:
        mullvad.login()
        config['mullvad'] = mullvad.access_token.to_dict()

        peers = []
        public_keys = []
        if not args.all and args.INDEX_PUBLIC_KEY is None:
            log_warn('Specify a INDEX_PUBLIC_KEY or use `--all`')
            return
        elif args.all:
            for peer in config['peers']:
                public_key = get_public_key(peer['private_key'])
                public_keys.append(public_key)
                peers.append(peers)
        elif len(args.INDEX_PUBLIC_KEY) == 44:
            peer = mullvad.peer_by_public_key(args.INDEX_PUBLIC_KEY)
            if peer is None:
                log_warn('Peer with public key %s does not exists!' % args.INDEX_PUBLIC_KEY)
                return
            public_keys.append(args.INDEX_PUBLIC_KEY)
        elif len(args.INDEX_PUBLIC_KEY) == 1 and args.INDEX_PUBLIC_KEY[0].isdigit():
            index = int(args.INDEX_PUBLIC_KEY[0])
            if index < len(config['peers']):
                peer = config['peers'][index]
                public_key = get_public_key(peer['private_key'])
                public_keys.append(public_key)
                peers.append(peers)
            else:
                log_warn('Peer with index %d does not exists!' % index)
                return
        else:
            log_warn('INDEX_PUBLIC_KEY is neither a base64 encoded 256 bit public key nor a index (0-9)!')
            return

        for peer in peers:
            config['peers'].remove(peer)
        for public_key in public_keys:
            mullvad.peer_remove(public_key)
            log_info("Deleted peer %s!" % (public_key))

        return config_save(args.config, config)


def generate_private_key() -> str:
    process = run(['wg', 'genkey'], failure_ok=True, print_output=False)
    key = str(process.stdout, 'utf8').strip()
    assert len(key) == 44
    return key


def get_public_key(private_key: str) -> str:
    process = subprocess.Popen(['wg', 'pubkey'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)
    process.stdin.write(bytes('%s\n' % private_key, 'utf8'))
    process.stdin.close()
    stdout = process.stdout.read()
    process.stdout.close()
    process.terminate()
    return str(stdout, 'utf8').strip()


def get_this_peer(peer, mullvad: MullvadAuth):
    if peer is not None:
        public_key = get_public_key(peer['private_key'])
        return mullvad.peer_by_public_key(public_key)
    return None


def get_city_ports(city_ports):
    ports = []
    for city_port in city_ports:
        ports.append('%s-%s' % (city_port['city_code'], city_port['port']))
    return ports


def print_peer_table(peers: List[MullvadPeer], mapped_peers, show_ipv6, show_peer_id):
    add_peer = lambda current, peer: table.add_row(
        [current, peer.created] +
        ([peer.id] if show_peer_id else []) +
        [peer.name.title(), peer.ipv4_address] +
        ([peer.ipv6_address] if show_ipv6 else []) +
        [peer.pubkey]
    )

    fields = ['Index', 'Created']

    if show_peer_id:
        fields.append('ID')

    fields.extend(['Name', 'IPv4'])

    if show_ipv6:
        fields.append('IPv6')

    fields.extend(['Public Key'])

    table = PrettyTablePretty(fields)

    table.align['Name'] = 'l'
    table.align['IPv4'] = 'r'
    table.align['IPv6'] = 'r'
    for idx, peer in enumerate(mapped_peers):
        if peer:
            add_peer(str(idx), peer)
    for peer in peers:
        if peer in mapped_peers:
            continue
        add_peer('', peer)
    print(table)


def info_command(args, parser_up):
    become_root()

    config = config_load(args.config)
    account_number = user_request_account_number(args.passname, config)

    access_token = None
    if 'mullvad' in config:
        access_token = MullvadToken.from_dict(config['mullvad'])

    with Mullvad().authenticate(account_number, access_token) as mullvad:
        mullvad.login()
        config['mullvad'] = mullvad.access_token.to_dict()
        config = config_save(args.config, config)

        account = mullvad.account()
        peers = mullvad.peers()

        mapped_peers = []
        if config and 'peers' in config:
            for peer in config['peers']:
                peer_mullvad = get_this_peer(peer, mullvad)
                mapped_peers.append(peer_mullvad)

        print('Account number: ', end='')
        if args.show_account_number:
            print('(%s)' % account_number)
        else:
            print('*' * 16)

        delta = account.expiry - datetime.now()
        if account.is_active():
            print('Expires:', end=' ')
            log_good(str(account.expiry), end=' ')
            print('(in %d days)' % delta.days)
        else:
            print('Expired:', end=' ')
            log_bad(str(account.expiry), end=' ')
            print('(since %d days)' % (-1*delta.days))

        print('Peers: ', end='')
        peers_text = '%s/%s' % (len(peers), account.max_peers())
        if account.can_add_peers():
            log_good(peers_text)
        else:
            log_warn(peers_text)

        print()
        print_peer_table(peers, mapped_peers, args.show_ipv6, args.show_peer_ids)
        print()
        log_info('If you only call `vad up` this command will be executed: ', end='')
        print(config_rebuild_up_command(
            config,
            parser_up))


def show_command(args):
    become_root()

    if is_active():
        try:
            with open(DESCRIPTION) as desc:
                print(desc.read().strip())
                print()
                sys.stdout.flush()
            subprocess.run(["wg"])
            for idx in range(1, 10):
                namespace = NAME + str(idx)
                if network_namespace_exists(namespace):
                    print()
                    subprocess.run(["ip", "netns", "exec", namespace, "wg"])
        except Exception as e:
            log_warn("VPN seemed to be active but something went wrong (%s)" % str(e))
        print()
    else:
        log_bad("You are not connected to Mullvad.")
        raise Abort()

    if not print_status_connected():
        raise Abort()


def describe_server(server):
    return f"{server['city_name']}, {server['country_name']} ({server['hostname']}:{server['ipv4_addr_in']}:{server['multihop_port']})"


def get_dns_from_args(args):
    if len(args.dns) == 0:
        return get_dns_server_from_flags('')
    else:
        return get_dns_server_from_flags(args.dns[0])


def create_network_namespace(namespace_new: str):
    log_verbose(f"Create namespace %s" % namespace_new)
    run_or_fail(["ip", "netns", "add", namespace_new])
    run_or_fail(["ip", "-n", namespace_new, "link", "set", "lo", "up"])
    # NOTE: allow "ping" command for all user groups in the physical namespace
    run_or_fail(["ip", "netns", "exec", namespace_new, "sysctl", 'net.ipv4.ping_group_range=0 2147483647'])


def print_status_connected():
    try:
        response = requests.get("https://am.i.mullvad.net/connected")
        if 'You are not' in response.text:
            log_bad(response.text.strip())
            return False
        elif response.ok:
            log_good(response.text.strip())
            return True
        else:
            log_bad(response.text.strip())
            return False
    except:
        log_bad("Not able to determine if connected to VPN.")
        return False


def network_manager_get_active_connection(device_name):
    client = NM.Client.new(None)
    for device in client.get_devices():
        if device.get_iface() == device_name:
            connection = device.get_active_connection()
            if connection is not None:
                return connection.get_uuid()


def network_manager_set_secret(uuid, config):
    process = run(
        ["nmcli", "--show-secrets", "con", "show", str(uuid)],
        failure_ok=True, print_output=False
    )
    output = str(process.stdout, 'utf8').strip()
    for line in output.split('\n'):
        key, value = line.split(':', 1)
        key = key.strip()
        value = value.strip()
        if 'password' in key and not '-flags' in key and value != '--':
            config['password'] = '"%s"' % value
            return
        elif 'psk' in key and not '-flags' in key and value != '--':
            config['psk'] = '"%s"' % value
            return


def workaround_fetch_current_wifi_configuration():
    for device in get_network_devices():
        if device.kind == DeviceKind.Wifi:
            log_verbose("fetch current wifi configuration:")
            log_verbose("- gather configuration for device: '%s'" % device.name)
            try:
                bus = dbus.SystemBus()
                proxy = bus.get_object('fi.w1.wpa_supplicant1', '/fi/w1/wpa_supplicant1')
                wpas = dbus.Interface(proxy, 'fi.w1.wpa_supplicant1')
                interface_path = wpas.GetInterface(device_name)
                log_verbose('- interface path: %s' % interface_path)
                proxy = bus.get_object('fi.w1.wpa_supplicant1', interface_path)
                current_network_path = proxy.Get('fi.w1.wpa_supplicant1.Interface', 'CurrentNetwork', dbus_interface=dbus.PROPERTIES_IFACE)
                log_verbose('- current network path: %s' % current_network_path)
                proxy = bus.get_object('fi.w1.wpa_supplicant1', current_network_path)
                network = proxy.Get('fi.w1.wpa_supplicant1.Network', 'Properties', dbus_interface=dbus.PROPERTIES_IFACE)
                config = {}
                for key, value in network.items():
                    config[str(key)] = str(value)
            except Exception as e:
                log_bad("Can not retrieve wifi information from wpa supplicant over DBus (%s)" % str(e))
                return None

            try:
                log_verbose("retrieve secrets from NetworkManager:")
                uuid = network_manager_get_active_connection(device_name)
                network_manager_set_secret(uuid, config)
            except Exception as e:
                log_bad("Can not retrieve wifi information from wpa supplicant over DBus (%s)" % str(e))
                return None

            return config


def write_wpa_supplicant_config(wifi_config):
    config = [
        "ctrl_interface=/run/wpa_supplicant",
        "update_config=1",
        "",
        "network={"
    ]
    for key, value in wifi_config.items():
        key = key.strip()
        value = value.strip()
        if len(value) == 0:
            log_verbose("key has zero length!")
            continue
        config.append('    %s=%s' % (key, value))
    config.append("}")
    try:
        with open(WPA_SUPPLICANT_CONF, 'w') as f:
            f.write('\n'.join(config))
    except IOError as e:
        log_bad('Could not write configuration: %s (%s)' % (WPA_SUPPLICANT_CONF, str(e)))


def path_selection(path: list[str], owned_entry: bool, uniform_by_country: bool, servers: list = None):
    selected_path = [
        server_random_choice(
            filter_servers(
                active=True,
                owned=owned_entry if owned_entry else None,
                country_city_hostname=path[0],
                servers=servers,
            ),
            uniform_by_country=uniform_by_country
        )
    ]
    for country_city_hostname in path[1:]:
        for _ in range(10):
            chosen_server = server_random_choice(
                filter_servers(
                    active=True,
                    country_city_hostname=country_city_hostname,
                    servers=servers,
                ),
                uniform_by_country=uniform_by_country
            )
            if not chosen_server in selected_path:
                selected_path.append(chosen_server)
                break
    return selected_path


def path_selection_default(nodes: list = None):
    # (1) Select a entry node
    #     (a) Select a trust worthy VPN provider uniform at random
    #     (b) Select a node from this provider uniform at random
    #     (c) Exclude provider from path selection
    # (2) Select a middle node
    #     (a) Select a VPN provider uniform at random
    #     (b) Select a node from this provider uniform at random
    #     (c) Exclude provider from path selection
    # (3) Select a exit node
    #     (a) Select a VPN provider uniform at random
    #     (b) Select a node from this provider uniform at random
    #     (c) Infer and/or measure AS’s from client to entry
    #     (d) Infer and/or measure AS’s from exit to destination
    #     (e) Make sure both AS sets do not intersect, if they do, go back to the beginning

    nodes = nodes[:]

    # (1) Select a entry node
    # WARN: We only have one provider so we will skip (a) and (c), instead we will exclude the node.
    entry_node_idx = random.randint(0, len(nodes)-1)
    entry_node = nodes[entry_node_idx]
    del nodes[entry_node_idx]

    # (2) Select a middle node
    # WARN: We only have one provider so we will skip (a) and (c), instead we will exclude the node.
    middle_node_idx = random.randint(0, len(nodes)-1)
    middle_node = nodes[middle_node_idx]
    del nodes[middle_node_idx]

    # (3) Select a exit node
    # WARN: We only have one provider so we will skip (a).
    # WARN: For (c) and (d) we do not use full ASN path interference and use the provider attribute as a proxy.
    nodes = list(filter(lambda node: node['provider'] != entry_node['provider'], nodes))
    exit_node_idx = random.randint(0, len(nodes)-1)
    exit_node = nodes[exit_node_idx]

    return [entry_node, middle_node, exit_node]


def get_peer_from_group(group_by_provider, server):
    provider = server['vpn']
    if len(group_by_provider[provider]) == 0:
        log_fatal('Provider %s has no more peers!' % provider) # TODO: formulate clearer
    return group_by_provider[provider].pop(0)


def path_configure_hops(peers, servers, without_multihop):
    hops = []

    group_by_provider = defaultdict(list)
    for peer in peers:
        provider = peer['provider']
        group_by_provider[provider].append(peer)

    if without_multihop:
        for server in servers:
            hops.append(Hop(get_peer_from_group(group_by_provider, server), server))
    else:
        idx = 0
        while idx < len(servers) - 1:
            has_multihop_support = (
                'multihop_port' in servers[idx] and
                'multihop_port' in servers[idx+1] and
                servers[idx]['provider'] == servers[idx+1]['provider'] and
                servers[idx]['provider'] == 'mullvad'
            )

            if has_multihop_support:
                hops.append(Multihop(get_peer_from_group(group_by_provider, servers[idx]), servers[idx], servers[idx+1]))
            else:
                hops.append(Hop(get_peer_from_group(group_by_provider, servers[idx]), servers[idx]))
                hops.append(Hop(get_peer_from_group(group_by_provider, servers[idx+1]), servers[idx+1]))

            idx += 2
        if idx < len(servers):
            hops.append(Hop(get_peer_from_group(group_by_provider, servers[idx]), servers[idx]))

    return hops


def create_hop_table(hops, without_multihop, title):
    hrules=ALL
    if without_multihop:
        hrules=FRAME
    table = PrettyTablePretty([
        '#',
        'Country',
        'City',
        'Hostname',
        'IP',
        'Port',
        'VPN',
        'Provider',
    ], hrules=hrules)
    table.title = title
    table.align['#'] = 'r'
    table.align['Country'] = 'l'
    table.align['City'] = 'l'
    table.align['Hostname'] = 'l'
    table.align['IP'] = 'r'
    table.align['VPN'] = 'l'
    table.align['Provider'] = 'l'

    idx = 0
    for hop in hops:
        if isinstance(hop, Multihop):
            index    = '%d\n%d' % (idx, idx+1)
            country  = '%s\n%s' % (hop.entry['country_name'] , hop.exit['country_name'])
            city     = '%s\n%s' % (hop.entry['city_name']    , hop.exit['city_name'])
            hostname = '%s\n%s' % (hop.entry['hostname']     , hop.exit['hostname'])
            provider = '%s\n%s' % (hop.entry['provider']     , hop.exit['provider'])
            ip       = '%s\n%s' % (hop.entry['ipv4_addr_in'] , hop.exit['ipv4_addr_in'])
            port     = '%d'     % (hop.port())
            vpn      = '%s'     % (hop.vpn())

            table.add_row([index, country, city, hostname, ip, port, vpn, provider])
            idx += 2
        else:
            index    = '%d' % (idx)
            country  = '%s' % (hop.server['country_name'])
            city     = '%s' % (hop.server['city_name'])
            hostname = '%s' % (hop.server['hostname'])
            provider = '%s' % (hop.server['provider'])
            ip       = '%s' % (hop.server['ipv4_addr_in'])
            port     = '%d' % (hop.port())
            vpn      = '%s' % (hop.vpn())
            table.add_row([index, country, city, hostname, ip, port, vpn, provider])
            idx += 1

    return table


def physical_namespace_set_up(auto_configure_wifi=False):
    physical_already_existed = network_namespace_exists(NAMESPACE_PHYSICAL)

    if physical_already_existed:
        return True

    if auto_configure_wifi:
        wifi_config = workaround_fetch_current_wifi_configuration()
        if wifi_config is not None:
            write_wpa_supplicant_config(wifi_config)

    create_network_namespace(NAMESPACE_PHYSICAL)

    run(["timeout", "-s", "KILL", "5", "killall", "-w", "wpa_supplicant", "dhcpcd"], failure_ok=True)
    run(["mkdir", "-p", "/etc/netns/physical"])
    run(["rm", "-f", "/etc/netns/physical/resolv.conf"])
    run(["touch", "/etc/netns/physical/resolv.conf"])

    for device in get_network_devices():
        if device.kind != DeviceKind.Virtual:
            device_move_to_physical(device)

    return False


def up_command(args, is_default):
    become_root()

    config = config_load(args.config)
    if not config or not isinstance(config, dict):
        if args.config == CONFIGURATION:
            log_fatal('Default configuration file not found or is not readable (use `vad init` to create one)!')
        else:
            log_fatal('Configuration file "%s" not found or is not readable!' % args.config)

    if is_default:
        config_set_up_command_attributes(config, args)

    if args.update_server_list:
        update_command(None)

    peers = config.get('peers', [])
    if len(peers) == 0:
        log_fatal('No peers configured (use `vad init` to create a peer)!')

    hops = len(args.COUNTRY_CITY_HOSTNAME)
    if len(args.COUNTRY_CITY_HOSTNAME) == 1 and args.COUNTRY_CITY_HOSTNAME[0] == 'default':
        hops = 3
        args.without_multihop = True
    if not args.without_multihop:
        needed = math.ceil(hops / 2) - len(peers)
        if needed > 0:
            log_fatal('You do not have enough peers to build a %d hop tunnel. With multihop you need at least %d more peer(s) (use `vad init --add-peer`)' % (hops, needed))
    else:
        needed = hops - len(peers)
        if needed > 0:
            log_fatal('You do not have enough peers to build a %d hop tunnel. Without multihop you need at least %d more peer(s) (use `vad init --add-peer`)' % (hops, needed))

    if len(args.COUNTRY_CITY_HOSTNAME) == 0:
        args.COUNTRY_CITY_HOSTNAME = ['w']

    servers = filter_servers()

    if len(args.COUNTRY_CITY_HOSTNAME) == 1 and args.COUNTRY_CITY_HOSTNAME[0] == 'default':
        servers = path_selection_default(servers)
    else:
        servers = path_selection(
            args.COUNTRY_CITY_HOSTNAME,
            owned_entry=args.owned_entry,
            uniform_by_country=args.uniform_by_country,
            servers=servers
        )
        if None in servers:
            log_fatal('Filter criteria "%s" does not return any server!' %  args.COUNTRY_CITY_HOSTNAME[servers.index(None)])

        if len(servers) != len(args.COUNTRY_CITY_HOSTNAME):
            log_fatal("Could not chose unique servers for all hops! Please try again or use wider filter criteria.")

    hops = path_configure_hops(peers, servers, args.without_multihop)

    if hops[-1].vpn() == 'mullvad':
        dns_server = get_dns_from_args(args)
    else:
        dns_server = hops[-1].peer['dns']

    table_hops = create_hop_table(hops, args.without_multihop, title='Hop configuration with nameserver %s' % dns_server)

    if args.dry_run:
        print(table_hops)
        sys.exit(0)

    if is_active():
        log_verbose("Was already active, do a partial tear down.")
        config = down_command(Namespace(config=args.config, partial=True))

    physical_already_existed = physical_namespace_set_up(args.auto_configure_wifi)

    if not physical_already_existed:
        config_execute_commands(config, 'pre_up')

    print(table_hops)
    with open(DESCRIPTION, 'w') as c:
        c.write(f"{table_hops}\n")

    config['hops'] = []
    for hop in hops:
        config['hops'].append(dict(
            peer_public_key=get_public_key(hop.peer['private_key']),
            server_public_key=hop.pubkey()
        ))
    config = config_save(args.config, config)

    namespaces = []
    namespaces.append(args.namespace_physical)
    for idx in range(1, len(hops)):
        namespaces.insert(1, NAMESPACE_HOP % (args.namespace_root, idx))
        create_network_namespace(NAMESPACE_HOP % (args.namespace_root, idx))
    namespaces.append(args.namespace_root)

    mtu = 1420
    for idx in range(len(hops)):
        ridx = len(hops) - idx - 1

        hop = hops[idx]
        namespace = namespaces[idx+1]
        namespace_link_to = namespaces[idx]
        device_name = DEVICE_NAME_HOP % ridx

        wireguard_init(
            namespace,
            device_name,
            namespace_link_to,
            hop.peer['private_key']
        )

        wireguard_device_setup(
            namespace,
            device_name,
            ipv4=None if args.only_use_ipv6 else hop.peer['ipv4'],
            ipv6=hop.peer['ipv6'],
            mtu=mtu
        )

        wireguard_add_peer(
            namespace,
            device_name,
            public_key=hop.pubkey(),
            endpoint=f'{hop.ipv6()}:{hop.port()}' if args.only_use_ipv6 else f'{hop.ipv4()}:{hop.port()}'
        )

        mtu -= 80

    update_resolvconf(dns_server)

    if not is_default and config and not args.dont_save:
        config = config_save_up_command(config, args)

    if not physical_already_existed:
        config_execute_commands(config, 'post_up')

    run(['systemctl', 'unmask', 'vad.move@.service'])
    log_success("VPN is successfully up!")

    return config


def network_namespace_exists(namespace):
    return os.path.exists('/var/run/netns/%s' % namespace)


def remove_device(namespace, device_name):
    log_verbose("Delete device %s from network namespace %s" % (device_name, namespace))

    if namespace == NAMESPACE_ROOT:
        run(['resolvconf', '-d', '%s.vad' % device_name])
        run(['ip', 'link', 'del', device_name])
    else:
        run(['ip', '-n', namespace, 'link', 'del', device_name])


def remove_network_namespace(namespace):
    if namespace == NAMESPACE_ROOT:
        return
    log_verbose("Remove network namespace %s" % namespace)
    process = run(['ip', 'netns', 'pids', namespace], failure_ok=True)
    if process.returncode == 0:
        pids = str(process.stdout, 'utf8')
        pids = pids.split('\n')
        pids = pids[:-1]
        if pids:
            run(['ip', 'netns', 'exec', namespace, 'kill'] + pids)

    if namespace == NAMESPACE_PHYSICAL:
        with NetworkNamespace(NAMESPACE_PHYSICAL):
            for device in get_network_devices():
                run(['ip', 'link', 'set', device.name, 'down'])
                if type == DeviceKind.Wifi:
                    run(['iw', 'phy', device.phy, 'set', 'netns', NAMESPACE_ROOT])
                elif type == DeviceKind.Ethernet:
                    run(['ip', 'link', 'set', device.name, 'netns', NAMESPACE_ROOT])

    run(['ip', 'netns', 'del', namespace])


def remove_file_if_exists(filename):
    if os.path.exists(filename):
        os.remove(filename)
        log_verbose('Removed %s' % filename)


def down_command(args):
    become_root()

    if not args.partial:
        run(['systemctl', 'mask', 'vad.move@.service'])

    config = config_load(args.config)

    if config and not args.partial:
        config_execute_commands(config, 'pre_down')

    remove_file_if_exists(DESCRIPTION)
    for wireguard_config in glob.glob(os.path.join(WIREGUARD_DIR, f'{NAME}-*.conf')):
        remove_file_if_exists(wireguard_config)

    namespaces = [NAMESPACE_ROOT]
    namespaces.extend([os.path.basename(f) for f in glob.glob('/var/run/netns/{NAME}-*')])
    if not args.partial:
        if network_namespace_exists(NAMESPACE_PHYSICAL):
            namespaces.append(NAMESPACE_PHYSICAL)

    for namespace in namespaces:
        with NetworkNamespace(namespace):
            devices = get_network_devices()
        for device in devices:
            if device.name.startswith(f'{NAME}'):
                remove_device(namespace, device.name)
        remove_network_namespace(namespace)

    if config and not args.partial:
        config_execute_commands(config, 'post_down')

    log_verbose("Reset hop configuration")
    config['hops'] = []
    config = config_save(args.config, config)

    if args.partial:
        log_success("VPN is succefully down (partial)")
    else:
        run(['systemctl', 'unmask', 'vad.move@.service'])
        log_success("VPN is succefully down")

    return config


def exec_command(args):
    become_root(do_lock=False)

    uid = os.getenv('SUDO_UID', os.geteuid())
    gid = os.getenv('SUDO_GID', os.getegid())
    args = ["ip", "netns", "exec", NAMESPACE_PHYSICAL, "sudo", "-E", "-u", '#%s' % uid, "-g", '#%s' % gid, "--"] + args.CMD
    if VERBOSE:
        print(subprocess.list2cmdline(args))
    os.execvp("ip", args)


def list_command(args):
    servers = load_servers()

    servers = filter_servers(
        type=None if args.all else 'wireguard',
        active=args.active,
        owned=args.owned,
        country_city_hostname=args.COUNTRY_CITY_HOSTNAME,
        servers=servers
    )

    if args.group_by_country:
        countries = defaultdict(int)
        for server in servers:
            key = (server['country_code'], server['country_name'])
            countries[key] += 1

        table = PrettyTablePretty(['Count', 'Code', 'Country'])
        table.align['Count'] = 'r'
        table.align['Country'] = 'l'
        for (country_code, country_name), count in sorted(countries.items(), key=lambda k: k[1]):
            table.add_row([count, country_code, country_name])
        print(table)
    elif args.group_by_country_city:
        country_cities = defaultdict(int)
        for server in servers:
            key = (
                server['country_code'], server['country_name'],
                server['city_code'], server['city_name']
            )
            country_cities[key] += 1

        table = PrettyTablePretty(['Count', '', 'Country', 'Code', 'City'])
        table.align['Count'] = 'r'
        table.align['Country'] = 'l'
        table.align['City'] = 'l'
        for (country_code, country_name, city_code, city_name), count in sorted(country_cities.items(), key=lambda k: k[1]):
            table.add_row([count, country_code, country_name, city_code, city_name])
        print(table)
    elif args.group_by_provider:
        providers = defaultdict(int)
        for server in servers:
            key = (
                server['provider']
            )
            providers[key] += 1

        total = 0
        for (provider), count in sorted(providers.items(), key=lambda k: k[1]):
            total += count

        table = PrettyTablePretty(['Count', 'Percent', 'Cum. Percent', 'Provider'])
        table.align['Count'] = 'r'
        table.align['Percent'] = 'r'
        table.align['Cum. Percent'] = 'r'
        table.align['Provider'] = 'l'
        cumsum = 0
        for (provider), count in sorted(providers.items(), key=lambda k: k[1]):
            cumsum += count
            table.add_row([count, '%.1f' % (count/total*100), '%.1f' % (cumsum/total*100), provider])
        print(table)
    else:
        fields = ['Active', 'Owned', 'Diskless']

        if args.all:
            fields.append('Type')

        fields.extend(['', 'Country', 'Code', 'City', 'VPN', 'Provider', 'Hostname'])

        if args.show_column_ipv4:
            fields.append('IPv4')
        if args.show_column_ipv6:
            fields.append('IPv6')

        fields.append('Multihop Port')

        if args.show_column_socks_proxy:
            fields.append('Socks Proxy')

        fields.append('Gbit/s')

        if args.show_column_public_key:
            fields.append('Public Key')

        if args.show_column_status_messages:
            fields.append('Messages')

        table = PrettyTablePretty(fields)
        table.align['Country'] = 'l'
        table.align['City'] = 'l'
        table.align['VPN'] = 'l'
        table.align['Provider'] = 'l'
        table.align['Hostname'] = 'l'
        table.align['IPv4'] = 'r'
        table.align['IPv6'] = 'r'
        table.align['Gbit/s'] = 'r'
        table.align['Messages'] = 'l'
        for server in servers:
            values = [
                '✓' if server['active'] else '',
                '✓' if server['owned'] else '',
                '✓' if server['stboot'] else '',
            ]

            if args.all:
                values.append(server['type'])

            values.extend([
                server['country_code'],
                server['country_name'],
                server['city_code'],
                server['city_name'],
                server['vpn'],
                server['provider'],
                server['hostname'],
            ])

            if args.show_column_ipv4:
                values.append(server['ipv4_addr_in'])
            if args.show_column_ipv6:
                values.append(server['ipv6_addr_in'])

            values.append(server['multihop_port'] if 'multihop_port' in server else '')

            if args.show_column_socks_proxy:
                values.append('%s:%s' % (server['socks_name'], server['socks_port']) if 'socks_name' in server else '')

            values.append(server['network_port_speed'])

            if args.show_column_public_key:
                values.append(server['pubkey'] if 'pubkey' in server else '')

            if args.show_column_status_messages:
                messages = ['%s: %s' % (message['timestamp'], message['message']) for message in server['status_messages']]
                messages = '\n'.join(messages)
                values.append('\n'.join(textwrap.wrap(messages, 50)))

            table.add_row(values)
        print(table)


def service_config():
    udev_rule = """
    SUBSYSTEM=="net", ACTION=="add", DEVPATH!="/devices/virtual/*", RUN+="/bin/systemctl start vad.move@%E{ID_NET_NAME}"
    """

    vad_move_service = """
    [Unit]
    Description=Move interface to physical namespace

    [Service]
    Type=forking
    ExecStart=vad -nv mv %I
    """

    vad_rotate_service = """
    [Unit]
    Description=Rotate WireGuard keys of all devices

    [Service]
    Type=oneshot
    ExecStart=vad -nv rotate
    """

    vad_rotate_timer = """
    [Unit]
    After=network-online.target
    Description=Rotate WireGuard keys of all devices every 4 days

    [Timer]
    OnCalendar=*-*-2/4 02:00
    Persistent=true

    [Install]
    WantedBy=timers.target
    """

    vad_up_service = """
    [Unit]
    Description=Execute `vad update` and `vad up`

    [Service]
    Type=oneshot
    ExecStartPre=-vad -nv update
    ExecStartPre=vad -nv show
    ExecStart=vad -nv up
    """

    vad_up_timer = """
    [Unit]
    After=network-online.target
    Description=Execute `vad update` and `vad up` daily at 03:00 to refresh hop endpoints

    [Timer]
    OnCalendar=*-*-* 03:00
    Persistent=true

    [Install]
    WantedBy=timers.target
    """

    vad_service = """
    [Unit]
    Description=Starts Vad on system startup
    After=syslog.target network-online.target
    Wants=network-online.target

    [Service]
    Type=forking
    RemainAfterExit=yes
    ExecStart=vad -nv up
    ExecStop=vad -nv down

    [Install]
    WantedBy=multi-user.target
    """

    prefix='/usr/local'
    bin_prefix=f"{prefix}/bin"
    rule_prefix=f"{prefix}/lib/udev/rules.d"
    systemd_prefix=f"{prefix}/lib/systemd/system"

    return Namespace(
        prefix=prefix,
        bin_prefix=bin_prefix,
        bin_path=f"{bin_prefix}/vad",
        rule_prefix=rule_prefix,
        rule_path=f"{rule_prefix}/vad.rules",
        systemd_prefix=systemd_prefix,
        udev_rule=udev_rule,
        systemd_units=[
            ("service" , f"{systemd_prefix}/vad.move@.service"  , vad_move_service   ) ,
            ("service" , f"{systemd_prefix}/vad.rotate.service" , vad_rotate_service ) ,
            ("service" , f"{systemd_prefix}/vad.up.service"     , vad_up_service     ) ,
            ("service" , f"{systemd_prefix}/vad.service"        , vad_service        ) ,
            ("timer"   , f"{systemd_prefix}/vad.rotate.timer"   , vad_rotate_timer   ) ,
            ("timer"   , f"{systemd_prefix}/vad.up.timer"       , vad_up_timer       ) ,
        ],
    )


def generate_ipv6_private_address() -> ipaddress.IPv6Interface:
    private = ipaddress.IPv6Network('fc00::/7')
    return ipaddress.IPv6Interface(
        random.randint(
            int(private.network_address) + 2,
            int(private.broadcast_address) + 1
        )
    )


def get_rp_address(key: X25519PrivateKey, proxy_address: Tuple[str, int], proxy_public_key: X25519PublicKey, port_rp: int):
    udp_rp = get_socket_proxy_client(proxy_address, port_rp)

    conn = NoiseConnection.from_name(b'Noise_IK_25519_ChaChaPoly_BLAKE2s')
    conn.set_keypair_from_private_bytes(Keypair.STATIC, key.private_bytes_raw())
    conn.set_keypair_from_public_bytes(Keypair.REMOTE_STATIC, proxy_public_key.public_bytes_raw())
    noise = initiator_do_handshake('Service', udp_rp, conn)

    noise.send(bytes([ACTION_TEST]))
    data = noise.recv(2048)
    rp_address = data[1:]
    print('Service: Reflexive address for RP: %s:%d' % ipv4_unpack(rp_address))

    return ipv4_unpack(rp_address)


# TODO: Implement keepalive for services
# TODO: Better error handling
# TODO: Rate limiting (DoS)
# TODO: Only supportes one client
# NOTE: Assumption: Every unique (protcol, private address, port) combination is mapped to the same public combination
def introduction_point_service(key: X25519PrivateKey, proxy_address: Tuple[str, int], proxy_public_key: X25519PublicKey, our_rp_address: Tuple[str, int], port_service: int) -> Tuple[str, bytes]:
    udp = get_socket_proxy_client(proxy_address)

    conn = NoiseConnection.from_name(b'Noise_IK_25519_ChaChaPoly_BLAKE2s')
    conn.set_keypair_from_private_bytes(Keypair.STATIC, key.private_bytes_raw())
    conn.set_keypair_from_public_bytes(Keypair.REMOTE_STATIC, proxy_public_key.public_bytes_raw())
    noise = initiator_do_handshake('Service', udp, conn)

    noise.send(bytes([ACTION_TEST]))
    data = noise.recv(2048)
    print('Service: Reflexive address for IP: %s:%d' % ipv4_unpack(data[1:]))

    print('Service: Request listing')
    noise.send(bytes([ACTION_LISTEN]))
    data = noise.recv(2048)
    assert len(data) == 1

    print('Service: Listening', to_base64(key.public_key().public_bytes_raw()))
    noise.settimeout(None)
    data = noise.recv(2048)
    assert len(data) == (1 + 6 + 32)

    print('Service: Got public key for peer')
    peer_public_key = data[7:]
    peer_public_key = X25519PublicKey.from_public_bytes(peer_public_key)
    peer = ipv4_unpack(data[1:7])
    peer_udp = UDPSocket(udp.sock, peer)
    punch_hole('Service', peer_udp)

    conn = NoiseConnection.from_name(b'Noise_KK_25519_ChaChaPoly_BLAKE2s')
    conn.set_keypair_from_private_bytes(Keypair.STATIC, key.private_bytes_raw())
    conn.set_keypair_from_public_bytes(Keypair.REMOTE_STATIC, peer_public_key.public_bytes_raw())
    noise = responder_do_handshake('Service', peer_udp, conn)

    ipv6 = generate_ipv6_private_address()
    print(f'Service: Allocate address for client: {ipv6}')
    noise.send(ipv4_pack(*our_rp_address))
    data = noise.recv(2048)
    assert len(data) == 6
    their_rp_address = data

    noise.send(ipv6.packed + struct.pack('!H', int(port_service)))
    noise.recv(2048)
    return ipv6.ip, peer_public_key, ipv4_unpack(their_rp_address)


# TODO: DoS is possible (Exhaust resources with added wireguard peers)
# TODO: -> Introduce `max_connections` and `max_connections_per_second`
# TODO: -> Automatically remove wireguard peers
# NOTE: WIP: This function just demonstrates how it could work, but it is far from production ready!
def introduction_point(stop: threading.Event, service_key: X25519PrivateKey, namespace: str, device_name: str, our_rp_address, port_service: int):
    while not stop.is_set():
        ipv6, peer_public_key, their_rp_address = introduction_point_service(service_key, PROXY_ADDRESS, PROXY_KEY.public_key(), our_rp_address, port_service)
        rp_ipv4, rp_port = their_rp_address
        wireguard_add_peer(namespace, device_name, to_base64(peer_public_key.public_bytes_raw()), endpoint=f'{rp_ipv4}:{rp_port}', allowed_ips=f'{ipv6}', persistent_keepalive=25)
        with NetworkNamespace('service'):
            run(['ping', '-c', '5', '-6', str(ipv6)])



def get_my_public_ip():
    try:
        response = requests.get('https://ipv4.am.i.mullvad.net/json')
        return response.json()['ip']
    except Exception as e:
        log_fatal("Error while getting public ip (%s)!" % (str(e)))


def copy_to_clipboard(message: str):
    from tkinter import Tk
    r = Tk()
    r.withdraw()
    r.clipboard_clear()
    r.clipboard_append(message)
    r.update()


def proxy_command(args):
    Proxy(PROXY_KEY, args.port).start()


def start_command(args, up_command_defaults):
    become_root()

    if not is_active():
        up_command(Namespace(**up_command_defaults), True)

    config = config_load(args.config)
    if 'hops' in config and isinstance(config['hops'], list):
        num_hops = len(config['hops'])
    log_info('Current number of hops: %d' % num_hops)

    ipv4 = get_my_public_ip()

    introduction_point_thread = None
    stop_event = None
    service_process = None

    def start():
        nonlocal introduction_point_thread
        nonlocal stop_event
        nonlocal service_process

        stop_event = threading.Event()

        local_rp_port = random.randint(40000, 2**16)
        rp_address = get_rp_address(SERVICE_KEY, PROXY_ADDRESS, PROXY_KEY.public_key(), local_rp_port)
        rp_ip, rp_port = rp_address

        introduction_point_thread = threading.Thread(target=introduction_point, args=(stop_event, SERVICE_KEY, 'service', 'service0', rp_address, '8000'))

        url = OnionVpnUrl(*PROXY_ADDRESS, PROXY_KEY.public_key().public_bytes_raw())
        copy_to_clipboard('vad -v connect ' + str(url))
        log_info('Share this URL with a client: ' + str(url) + " (It does not work with a regular web browser)")

        create_network_namespace('service')
        wireguard_init('service', 'service0', NAMESPACE_ROOT, to_base64(SERVICE_KEY.private_bytes_raw()), local_rp_port)
        wireguard_device_setup('service', 'service0', 'fc00::1', None, 1420 - (num_hops*80))

        log_info('Start introduction point')
        introduction_point_thread.start()
        service_process = subprocess.Popen(['ip', 'netns', 'exec', 'service'] + args.CMD)

    def cleanup():
        if stop_event is not None:
            stop_event.set()
        if introduction_point_thread is not None and introduction_point_thread.is_alive():
            introduction_point_thread.join()
        if service_process is not None:
            service_process.terminate()
            service_process.wait()
        remove_file_if_exists(WIREGUARD_CONFIG % ('service', 'service0'))
        remove_device('service', 'service0')
        remove_network_namespace('service')

    try:
        start()
        input()
    finally:
        cleanup()

def introduction_point_connect(key: X25519PrivateKey, proxy_address: Tuple[str, int], proxy_public_key: X25519PublicKey, service_public_key: X25519PublicKey, our_rp_address):
    udp = get_socket_proxy_client(proxy_address)

    conn = NoiseConnection.from_name(b'Noise_IK_25519_ChaChaPoly_BLAKE2s')
    conn.set_keypair_from_private_bytes(Keypair.STATIC, key.private_bytes_raw())
    conn.set_keypair_from_public_bytes(Keypair.REMOTE_STATIC, proxy_public_key.public_bytes_raw())
    noise = initiator_do_handshake('Client', udp, conn)

    noise.send(bytes([ACTION_TEST]))
    data = noise.recv(2048)
    print('Client: Reflexive address:', ipv4_unpack(data[1:]))

    noise.send(bytes([ACTION_CONNECT]) + service_public_key.public_bytes_raw())
    data = noise.recv(2048)
    assert len(data) >= 1
    action = data[0]
    if len(data) == 1 and action == RESPONSE_NCK:
        print('Client: No listener for key')
        return
    elif len(data) == 7 and action == RESPONSE_ACK:
        print('Client: Found listener')
        peer = ipv4_unpack(data[1:])
        peer_udp = UDPSocket(udp.sock, peer)
        punch_hole('Client', peer_udp)
        # peer_udp.recv(0)

        conn = NoiseConnection.from_name(b'Noise_KK_25519_ChaChaPoly_BLAKE2s')
        conn.set_keypair_from_private_bytes(Keypair.STATIC, key.private_bytes_raw())
        conn.set_keypair_from_public_bytes(Keypair.REMOTE_STATIC, service_public_key.public_bytes_raw())
        noise = initiator_do_handshake('Client', peer_udp, conn)

        data = noise.recv(2048)
        assert len(data) == 6
        their_rp_address = ipv4_unpack(data)

        noise.send(ipv4_pack(*our_rp_address))

        data = noise.recv(2048)
        assert len(data) == 18
        ipv6 = ipaddress.IPv6Address(data[0:16])
        service_port = struct.unpack('!H', data[16:18])[0]
        print(f'Client: Got {ipv6}:{service_port}')
        noise.send(bytes([RESPONSE_ACK]))
        return str(ipv6), service_port, their_rp_address


def connect_command(args):
    become_root(do_lock=False)

    # TODO:
    # if no is_active():
    #   up_command(Namespace(**up_command_defaults), True)

    config = config_load(args.config)
    if 'hops' in config and isinstance(config['hops'], list):
        num_hops = len(config['hops'])
    log_info('Current nubmer of hops: %d' % num_hops)

    url = OnionVpnUrl.from_url(args.URL[0])

    log_info('Service Information:', highlight=True)
    log('- ip address: ' + url.ipv4)
    log('- introduction point port: ' + url.port_ip)
    log('- service sign public key: ' + to_base64(url.public_key))

    # TODO: hardcoded
    client_key = X25519PrivateKey.from_private_bytes(from_base64('0Bz3Vpa47HCoNYrWmtZDfDFi4mEuXmgPC6Nk8mA8aU8='))

    local_rp_port = random.randint(40000, 2**16)
    our_rp_address = get_rp_address(client_key, PROXY_ADDRESS, PROXY_KEY.public_key(), local_rp_port)

    log_info('IP: Connecting to introduction point', highlight=True)
    our_ipv6, service_port, their_rp_address = introduction_point_connect(client_key, (url.ipv4, int(url.port_ip)), X25519PublicKey.from_public_bytes(url.public_key), SERVICE_KEY.public_key(), our_rp_address)
    rp_ipv4, rp_port = their_rp_address
    log('IP: Got our ip address from the service: ' + our_ipv6)

    try:
        create_network_namespace('client')
        wireguard_init('client', 'client0', NAMESPACE_ROOT, to_base64(client_key.private_bytes_raw()), local_rp_port)
        wireguard_device_setup('client', 'client0', our_ipv6, None, 1420 - (num_hops*80))
        wireguard_add_peer('client', 'client0', to_base64(SERVICE_KEY.public_key().public_bytes_raw()), endpoint=f'{rp_ipv4}:{rp_port}', allowed_ips='fc00::1/128', persistent_keepalive=25)
        with NetworkNamespace('client'):
            run(['ping', '-c', '5', '-6', 'fc00::1'])
        run_in_namespace_or_fail('client', ['chromium', f'http://[fc00::1]:{service_port}'], as_user=True)
    finally:
        remove_file_if_exists(WIREGUARD_CONFIG % ('client', 'client0'))
        remove_device('client', 'client0')
        remove_network_namespace('client')


def install_command(args):
    become_root()

    config = service_config()

    os.makedirs(config.bin_prefix, exist_ok=True)
    os.makedirs(config.rule_prefix, exist_ok=True)
    os.makedirs(config.systemd_prefix, exist_ok=True)

    log_verbose("Copy vad into %s" % config.bin_prefix)
    shutil.copyfile(os.path.abspath(os.sys.argv[0]), config.bin_path)
    os.chmod(config.bin_path, 0o755)

    log_verbose("Install udev rule %s" % config.rule_path)

    with open(config.rule_path, 'w') as f:
        f.write(config.udev_rule)

    for type, filename, content in config.systemd_units:
        log_verbose("Install %s %s" % (type, filename))
        with open(filename, 'w') as f:
            f.write(content)

    log_verbose("Verify configuration files:")

    for filename in os.listdir('/sys/class/net'):
        run_or_fail(['bash', '-c', 'udevadm test --action=add /sys/class/net/%s 2>&1 | grep "vad"' % filename])

    for type, filename, content in config.systemd_units:
        run_or_fail(['systemd-analyze', 'verify', os.path.basename(filename)])

    log_verbose("Enable:")

    for type, filename, content in config.systemd_units:
        if 'vad.rotate.service' in filename:
            continue
        if 'vad.up.service' in filename:
            continue
        if 'vad.move@.service' in filename:
            continue
        run_or_fail(['systemctl', 'enable', os.path.basename(filename)])

    log_verbose("Reload udev rules")
    run_or_fail(['udevadm', 'control', '--reload'])

    log_success("Successfully installed udev rule, services and timers!")


def uninstall_command(args):
    become_root()

    config = service_config()

    log_verbose("Disable services/timers:")
    for type, filename, content in config.systemd_units:
        run_or_fail(['systemctl', 'disable', os.path.basename(filename)])

    log_verbose("Unlink %s" % config.bin_path)
    os.unlink(config.bin_path)

    log_verbose("Remove udev rule %s" % config.rule_path)
    os.unlink(config.rule_path)

    for type, filename, content in config.systemd_units:
        log_verbose("Remove %s %s" % (type, filename))
        os.unlink(filename)

    log_verbose("Reload udev rules")
    run_or_fail(['udevadm', 'control', '--reload'])


def get_server_by_public_key(servers: list, public_key: str):
    for server in servers:
        if 'pubkey' in server and server['pubkey'] == public_key:
            return server
    return None


def get_peer_by_public_key(peers, public_key):
    for peer in peers:
        pubkey = get_public_key(peer['private_key'])
        if pubkey == public_key:
            return peer
    return None


def get_ports_by_peer_public_key(city_ports, peer_public_key):
    ports = []
    for city_port in city_ports:
        if city_port['wgkey'] == peer_public_key:
            ports.append(city_port)
    return ports


def menu_select_one(selection, default):
    while True:
        digits_total = int(math.ceil(math.log10(len(selection))))
        for idx, (key, value) in enumerate(selection):
            index = idx+1
            index_format = '%%%ds' % digits_total
            print(colored(index_format, 'green') % str(index) + ' %s' % value)
        try:
            print()
            print(
                colored('[%d]' % (default + 1), 'green') +
                ': ',
                end=''
            )
            idx = input()
            if idx == '':
                idx = default
                break
            idx = int(idx) - 1
            if idx < 0 or idx >= len(selection):
                continue
            else:
                break
        except ValueError:
            continue
    return selection[idx][0]


def move_command(args):
    become_root()

    if not network_namespace_exists(NAMESPACE_PHYSICAL):
        log_warn('Namespace %s does not exists, can not move device!' % NAMESPACE_PHYSICAL)
        raise Abort()

    moved_to = False
    for device in get_network_devices():
        if device.kind != DeviceKind.Virtual and device.name == args.INTERFACE[0]:
            device_move_to_physical(device)
            moved_to = True

    exists_in_physical = False
    with NetworkNamespace(NAMESPACE_PHYSICAL):
        for device in get_network_devices():
            if device.kind != DeviceKind.Virtual and device.name == args.INTERFACE[0]:
                exists_in_physical = True

    if not moved_to and not exists_in_physical:
        log_warn("Device '%s' does not exists!" % args.INTERFACE[0])


def rotate_command(args, up_command_defaults):
    become_root()

    config = config_load(args.config)
    account_number = user_request_account_number(args.passname, config)

    access_token = None
    if 'mullvad' in config:
        access_token = MullvadToken.from_dict(config['mullvad'])

    with Mullvad().authenticate(account_number, access_token) as mullvad:
        mullvad.login()
        config['mullvad'] = mullvad.access_token.to_dict()

        for config_peer in config.get('peers', []):
            if not config_peer['provider'] == 'mullvad':
                continue
            private_key_new = generate_private_key()
            public_key_new = get_public_key(private_key_new)
            public_key = get_public_key(config_peer['private_key'])
            peer = mullvad.peer_update_pubkey(public_key, public_key_new)
            config_peer['private_key'] = private_key_new
            config_peer['ipv4'] = peer.ipv4_address
            config_peer['ipv6'] = peer.ipv6_address
            config_save(args.config, config)

    log_success("Successfully rotated WireGuard keys of all mapped peers")

    if is_active():
        up_command(Namespace(**up_command_defaults), True)

    return config


def reset_command(args):
    become_root()

    uninstall_command(Namespace())

    config = delete_command(Namespace(config=args.config, all=True, INDEX=None, passname='web/mullvad'))

    down_command(Namespace(config=args.config, partial=False))

    if 'account_number' in config:
        del config['account_number']
    if 'auth' in config:
        del config['auth']

    config = config_save(args.config, config)

    log_success("Successfully reseted")

    return config


def check_unique_city_codes(servers):
    country_cities = set([(server['country_code'], server['city_code']) for server in servers])
    city_counter = Counter([city for country, city in country_cities])

    duplicates = set()
    for city, count in city_counter.items():
        if count > 1:
            for server in servers:
                if city == server['city_code']:
                    duplicates.add('%s (%s), %s (%s)' % (server['country_name'], server['country_code'], server['city_name'], server['city_code']))
            log_warn("Attention, the city code '%s' is not unique:" % city)
            for text in duplicates:
                print('- %s' % text)


def check_special_country_codes_not_in_use(servers):
    countries = set([server['country_code'] for server in servers])
    for server in servers:
        if 'eu' == server['country_code']:
            log_warn("Attention, the special country code 'eu' used by this program is in use by a server. This makes this server unselectable! (%s)", str(server))
        if 'ec' == server['country_code']:
            log_warn("Attention, the special country code 'ec' used by this program is in use by a server. This makes this server unselectable! (%s)", str(server))


def update_command(args):
    become_root()

    os.makedirs('/etc/vad', exist_ok=True)

    url_servers = "https://api.mullvad.net/www/relays/all"

    try:
        response = requests.get(url_servers)

        if response.ok:
            with open(MULLVAD_SERVERS, 'w') as servers:
                servers.write(response.text)
            os.chmod(MULLVAD_SERVERS, 0o644)
            servers = filter_servers()
            check_unique_city_codes(servers)
            check_special_country_codes_not_in_use(servers)
            log_info('%s updated with %d wireguard servers' % (MULLVAD_SERVERS, len(servers)))
        else:
            log_warn('Can not download servers from %s, because of %s' % (url_servers, response.text))
    except Exception as e:
        log_warn('Can not download servers from %s, because of %s' % (url_servers, str(e)))


def get_network_devices():
    dir = '/sys/class/net'
    devices = []
    for dev in os.listdir(dir):
        path_dest = os.readlink(os.path.join(dir, dev))
        if 'virtual' in path_dest:
            devices.append(Device(DeviceKind.Virtual, dev, ''))
        elif 'devices' in path_dest:
            path = os.path.join(dir, path_dest, "phy80211")
            if os.path.exists(path):
                devices.append(Device(DeviceKind.Wifi, dev, os.path.basename(os.readlink(path))))
            else:
                devices.append(Device(DeviceKind.Ethernet, dev, ''))
    return devices


class TestDependencies(unittest.TestCase):
    def test(self):
        commands = [
            "sudo",
            "kill",
            "killall",
            "timeout",
            "wg",
            "ip",
            "iw",
            "wpa_supplicant",
            "dhcpcd",
            "sysctl",
            "resolvconf",
            # pass
        ]

        for command in commands:
            process = subprocess.run(['bash', '-c', 'command -v %s' % command], capture_output=True)
            if process.returncode != 0:
                print("Command '%s' should be available!" % command)


class TestCase(unittest.TestCase):
    def save_main_module(self):
        self.main_module = dict()
        module = sys.modules[__name__]
        for key, value in module.__dict__.items():
            if not '__' in key:
                self.main_module[key] = value
        return module

    def restore_main_module(self):
        module = sys.modules[__name__]
        for key, value in self.main_module.items():
            module.__dict__[key] = value

    def inject_get_response(self, code, content):
        response = Response()
        response.status_code = code
        response._content = bytes(content, "utf8")
        requests.get = lambda x: response

    def throw_exception(self, arg):
        raise Exception("Some exception")

    def assertExit(self, func):
        with self.assertRaises(SystemExit):
            func()

    def capture(self, func):
        out = StringIO()
        with redirect_stdout(out):
            func()
        return out.getvalue()


class TestServerRandomChoice(TestCase):
    def test(self):
        import numpy as np
        servers = filter_servers()
        countries = defaultdict(int)

        N = 1000
        for _ in range(N):
            server = server_random_choice(servers, uniform_by_country=True)
            countries[server['country_code']] += 1

        result = np.array(list(countries.values()))
        expected = np.array([N/len(countries)] * len(countries.values()))

        chi = np.sum((result - expected)**2 / expected)
        chi = chi / len(countries.values())
        assert chi < 2.0


class TestGetDnsServerFromFlags(TestCase):
    def testWrongFlag(self):
        out = self.capture(partial(get_dns_server_from_flags, "x"))
        self.assertIn("Unkown", out)

    def test(self):
        cases = [
            ("10.64.0.1",   ""),
            ("100.64.0.1",  "a"),
            ("100.64.0.2",  "t"),
            ("100.64.0.3",  "at"),
            ("100.64.0.4",  "m"),
            ("100.64.0.5",  "am"),
            ("100.64.0.6",  "tm"),
            ("100.64.0.7",  "atm"),
            ("100.64.0.8",  "p"),
            ("100.64.0.9",  "pa"),
            ("100.64.0.10", "pt"),
            ("100.64.0.11", "pat"),
            ("100.64.0.12", "pm"),
            ("100.64.0.13", "pam"),
            ("100.64.0.14", "ptm"),
            ("100.64.0.15", "patm"),
            ("100.64.0.16", "g"),
            ("100.64.0.17", "ga"),
            ("100.64.0.18", "gt"),
            ("100.64.0.19", "gat"),
            ("100.64.0.20", "gm"),
            ("100.64.0.21", "gam"),
            ("100.64.0.22", "gmt"),
            ("100.64.0.23", "gamt"),
            ("100.64.0.24", "gp"),
            ("100.64.0.25", "gap"),
            ("100.64.0.26", "gpt"),
            ("100.64.0.27", "gapt"),
            ("100.64.0.28", "gpm"),
            ("100.64.0.29", "gapm"),
            ("100.64.0.30", "gpmt"),
            ("100.64.0.31", "apgmt"),
        ]

        for dns, flags in cases:
            self.assertEqual(dns, get_dns_server_from_flags(flags), "Used flags: %s" % flags)


class TestMullvadIntegration(unittest.TestCase):
    def test(self):
        import base64

        with Mullvad() as api:
            connected = api.connected()
            self.assertEqual(len(connected), 2)
            self.assertEqual(type(connected[0]), bool)
            self.assertEqual(type(connected[1]), str)

            relays = api.relays()
            self.assertTrue(len(relays) > 200)
            self.assertEqual(type(relays[0]), MullvadRelay)

            with api.authenticate(user_request_account_number('web/mullvad', dict())) as auth:
                public_key = str(base64.encodebytes(os.urandom(32)), 'utf8').strip()
                public_key2 = str(base64.encodebytes(os.urandom(32)), 'utf8').strip()

                account = auth.account()
                self.assertTrue(account.is_active())
                self.assertTrue(account.can_add_peers())

                peers = auth.peers()

                peer = auth.peer_create(public_key)
                self.assertEqual(peer.pubkey, public_key)
                self.assertEqual(len(peers)+1, len(auth.peers()))

                peer = auth.peer_update_pubkey(public_key, public_key2)
                self.assertEqual(peer.pubkey, public_key2)

                auth.peer_remove(public_key2)
                self.assertEqual(len(peers), len(auth.peers()))


class TestOnionVpnUrl(unittest.TestCase):
    def test(self):
        url = OnionVpnUrl('123.45.6.78', '6666', bytes([1]*32))
        url_ = OnionVpnUrl.from_url(str(url))

        self.assertEqual(url.ipv4, '123.45.6.78')
        self.assertEqual(url.port_ip, '6666')
        self.assertEqual(url.public_key, bytes([1]*32))

        self.assertIsInstance(url.ipv4, str)
        self.assertIsInstance(url_.ipv4, str)
        self.assertIsInstance(url.port_ip, str)
        self.assertIsInstance(url_.port_ip, str)
        self.assertIsInstance(url.public_key, bytes)
        self.assertIsInstance(url_.public_key, bytes)

        self.assertEqual(url.ipv4, url_.ipv4)
        self.assertEqual(url.port_ip, url_.port_ip)
        self.assertEqual(url.public_key, url_.public_key)
        self.assertEqual(len(url.public_key), 32)
        self.assertEqual(len(url_.public_key), 32)

        self.assertEqual(str(url), 'aaahwligjynauaibaeaqcaibaeaqcaibaeaqcaibaeaqcaibaeaqcaibaeaqcaib.onion.vpn')


def test_build_image(base_image, build, Dockerfile):
    from tempfile import TemporaryDirectory

    tag = 'vad-%s' % base_image

    if build:
        with TemporaryDirectory() as dir:
            with open('%s/Dockerfile' % dir, 'w') as f:
                f.write(Dockerfile.format(base_image=base_image))
            subprocess.run(f"docker build -t {tag} {dir}", shell=True, check=True)
    return tag


def test_command(args):
    if args.docker:
        become_root()

        images = []
        images.append(test_build_image('archlinux', not args.docker_skip_build,
            """
            FROM {base_image}
            RUN pacman -Syu --noconfirm python-requests python-dbus python-yaml python-prettytable python-numpy sudo iw wpa_supplicant dhcpcd wireguard-tools
            """
        ))

        for base_image in ['ubuntu', 'ubuntu:20.04', 'debian']:
            images.append(test_build_image(base_image, not args.docker_skip_build,
                """
                FROM {base_image}
                RUN apt update && apt install -y -q python3-dbus python3-requests python3-yaml python3-prettytable python3-numpy sudo psmisc wireguard-tools iproute2 iw wpasupplicant dhcpcd5 procps
                """
            ))


        path = sys.argv[0]
        for image in images:
            command = f"docker run --rm -v /etc/vad/servers.json:/etc/vad/servers.json -v {path}:/bin/vad {image} vad test"
            print(command)
            subprocess.run(command, shell=True, check=True)
    else:
        unittest.main(argv=sys.argv[1:])


def get_default_arguments(parser, subparser):
    defaults_parser = vars(parser.parse_args([]))
    defaults_subparser = vars(subparser.parse_args([]))
    defaults = {**defaults_parser, **defaults_subparser}
    return defaults


def is_default_arguments(parser, subparser, args):
    defaults_parser = vars(parser.parse_args([]))
    defaults = get_default_arguments(parser, subparser)
    args_to_compare = {**vars(args), **defaults_parser}
    args_to_compare['func'] = None
    args_to_compare['dont_save'] = False
    args_to_compare['dry_run'] = False
    defaults['func'] = None
    return defaults == args_to_compare


def vad():
    parser = argparse.ArgumentParser(
        prog="vad",
        description="An alternative command line interface (CLI) for Mullvad that is based on network namespaces and supports up to ten hops.",
    )

    parser.add_argument('-p', '--print-args', action='store_true', help='Output parsed args.')
    parser.add_argument('-v', '--verbose', action='store_true', help='Output verbose information.')
    parser.add_argument('-n', '--no-color', action='store_true', help='Never color output')
    parser.add_argument('-c', '--config', help='Use this configuration file', default=CONFIGURATION)
    parser.set_defaults(func=show_command)

    subparsers = parser.add_subparsers()
    subparser_args = dict(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    init = subparsers.add_parser('init', help='Initalize Mullvad VPN by asking the user for the account number and adding one peer. The account number will be saved.', **subparser_args)
    init.add_argument('-p', '--passname', nargs=1, dest='passname', help='Request account number from pass.', default='web/mullvad')
    init.add_argument('-d', '--dont-save-account-number', action='store_true', help='Does not save the account number into the configuration file. Useful if you have the account number in `pass`.')
    init.set_defaults(func=init_command)

    add = subparsers.add_parser('add', help='Adding a new peer from your account to this computer. Every new peer enables at least one hop. In a multihop configuration (https://mullvad.net/de/help/multihop-wireguard) every peer enables two hops. Normally 5 peers are possible per account, this allows a maximum of ten hops.', **subparser_args)
    add.add_argument('-p', '--passname', nargs=1, dest='passname', help='Request account number from pass.', default='web/mullvad')
    add.set_defaults(func=add_command)

    delete = subparsers.add_parser('delete', help='Delete mapped peer(s) from this computer and your account.', **subparser_args)
    delete.add_argument('--all', action='store_true', help='Delete all mapped peers.')
    delete.add_argument('-p', '--passname', nargs=1, dest='passname', help='Request account number from pass.', default='web/mullvad')
    delete.add_argument('INDEX_PUBLIC_KEY', nargs='?', metavar='INDEX_PUBLIC_KEY', help='Delete specified mapped peer from this computer and your account. You can do that with the index (`vad info`) or the public key. CAUTION: The index of the other peers changes after deletion. You can use the public key to delete non mapped peers.')
    delete.set_defaults(func=delete_command)

    info = subparsers.add_parser('info', help='View account information and highlight peers added to this computer.', **subparser_args)
    info.add_argument('-p', '--passname', nargs=1, dest='passname', help='Request account number from pass.', default='web/mullvad')
    info.add_argument('-a', '--show-account-number', action='store_true', help='Shows the account number.')
    info.add_argument('-s', '--show-peer-ids', action='store_true', help='Show peer ids.')
    info.add_argument('-6', '--show-ipv6', action='store_true', help='Show IPv6 address column of peer.')
    info.set_defaults(func=info_command)

    update = subparsers.add_parser('update', help='Update or initialize server list.')
    update.set_defaults(func=update_command)

    up = subparsers.add_parser('up', aliases=['u'], help=f'Set up a vpn tunnel: move all physical network devices into the physical network namespace, configure one or more Mullvad server and setup a wireguard device in the root namespace. All programs from non root users are forced to use the wireguard device in the root namespace.')
    up.add_argument('COUNTRY_CITY_HOSTNAME', nargs='*', help='Select up to ten random hops by country code (e.g. de), city code (e.g. dus) or hostname (e.g. de-dus-wg-001). Filtering by hostname only works with four or more characters and must be a substring from the server\'s hostname. The sequence determines the data flow. More hops require more devices (see `vad init`). If you want to use a random hop around the earth, then use "w" as placeholder. If you only want to use hops from countries in the European Union then use "eu". If you only want to use hops from countries on the European continent then use "ec". If no hops are specified, then a one hop tunnel with a random hop from around the earth will be built. If already active, than a second call, will tear down the configuration, except the physical namespace, so no data leaks can occur, and build a new tunnel. If you execute the up command without arguments (`vad up`) it will use the options of the last call with arguments. The last call with arguments will be saved to the configuration file, after an successful up, if you do not want this, use `-s --dont-save`.')
    up.add_argument('-i', '--auto-configure-wifi', action='store_true', help='This is a workaround to automaically configure the wifi interface. It only works if you have NetworkManager, currently connected to an wifi network and `wpa_supplicant` is used. It will retrive the configuration from `wpa_supplicant` for the current network and fetch the PSK from NetworkManager (somehow `wpa_supplicant` does not give us this information?). This is at least a better for usability then configuring it manually.')
    up.add_argument('-s', '--dont-save', action='store_true', help='Do not save the last call with arguments to the configuration file.')
    up.add_argument('-a', '--update-server-list', action='store_true', help='Update server list.')
    up.add_argument('-n', '--dry-run', action='store_true', help='Show only chosen hop(s) and nameserver.')
    up.add_argument('-d', '--dns', nargs=1, help='Set a blocking dns server by flags (atmpg) or with no flags use the nonblocking dns server (10.64.0.1): a = Block adverdisments, t = Block tracking, m = Block malicious sites, p = Block adult content, g = Block gampling sites.', default='')
    up.add_argument('-w', '--without-multihop', action='store_true', help='Normally pairs of hops are taken and configured as multihop beginning from the last hop. Every hop pair requires one peer, with this option every hop requires one peer.')
    up.add_argument('-u', '--uniform-by-country', action='store_true', help='Randomly select a country and then randomly select a hop.')
    up.add_argument('-o', '--owned-entry', action='store_true', help='Use a owned server by Mullvad for your entry hop.')
    up.add_argument('-6', '--only-use-ipv6', action='store_true', help='Only use IPv6 addresses.')
    up.add_argument('-r', '--namespace-root', help='EXPERIMENTAL: You can specific which namespace will have access to the tunnel, if this option is not present, it will be the root namespace, which is called "1" under Linux.', default=NAMESPACE_ROOT)
    up.add_argument('-p', '--namespace-physical', help='EXPERIMENTAL: You can specific the namespace where you start building your hops. Usually it is the physical namespace but if you want to extend an existing tunnel you can do so.', default=NAMESPACE_PHYSICAL)
    up.set_defaults(func=up_command)

    down = subparsers.add_parser('down', aliases=['d'], help='Tear down the vpn configuration and restore the previous state.')
    down.add_argument('-p', '--partial', action='store_true', help=f'Do not delete the physical namespace. Your physical network interfaces will remain in this namespace, which leaves you with no network access at all. Useful if you manually configured your physical network namespace.', default=False)
    down.set_defaults(func=down_command)

    exec = subparsers.add_parser('exec', aliases=['e'], help='Execute command in the physical namespace. The command can use the physical network interfaces directly.')
    exec.add_argument('CMD', nargs=argparse.REMAINDER, help=f'Command to execute in the physical namespace with or without arguments.')
    exec.set_defaults(func=exec_command)

    show = subparsers.add_parser('show', aliases=['s'], help='Show vpn status information, return 0 if active otherwise 1.', **subparser_args)
    show.set_defaults(func=show_command)

    list = subparsers.add_parser('list', aliases=['l'], help='List, filter and group servers.', **subparser_args)
    list.add_argument('COUNTRY_CITY_HOSTNAME', nargs='?', help='Select server by country code (e.g. de), city code (e.g. dus) or hostname if it contains this substring (e.g. de-dus-wg-001). Filtering by hostname only works with four or more characters.')
    list.add_argument('--all', action='store_true', help='List also non wireguard servers and add "Type" column to table.')
    list.add_argument('-c', '--group-by-country', action='store_true', help='Group and count by country.')
    list.add_argument('-y', '--group-by-country-city', action='store_true', help='Group and count by country and city.')
    list.add_argument('-d', '--group-by-provider', action='store_true', help='Group and count by provider.')
    list.add_argument('-4', '--show-column-ipv4', action='store_true', help='Shows ipv4 column (ignored by --group-by-*).')
    list.add_argument('-6', '--show-column-ipv6', action='store_true', help='Shows ipv6 column (ignored by --group-by-*).')
    list.add_argument('-p', '--show-column-public-key', action='store_true', help='Show public key column (ignored by --group-by-*).')
    list.add_argument('-s', '--show-column-socks-proxy', action='store_true', help='Show socks proxy column (ignored by --group-by-*).')
    list.add_argument('-m', '--show-column-status-messages', action='store_true', help='Show status messages column (ignored by --group-by-*).')
    list.add_argument('-o', '--owned', dest='owned', action='store_true', help='Filter by owned servers.', default=None)
    list.add_argument('-r', '--rented', dest='owned', action='store_false', help='Filter by rented servers.', default=None)
    list.add_argument('-a', '--active', dest='active', action='store_true', help='Filter by active servers.', default=None)
    list.add_argument('-i', '--inactive', dest='active', action='store_false', help='Filter by inactive servers.', default=None)
    list.set_defaults(func=list_command)

    proxy = subparsers.add_parser('proxy', help='Start a proxy that will help an onion vpn service to connect to a client')
    proxy.set_defaults(func=proxy_command)
    proxy.add_argument('--port', nargs=1, default=6666, help=f'Port where the proxy should listen on')

    start = subparsers.add_parser('start', help='Start an onion vpn service in its own network namespace')
    start.set_defaults(func=start_command)
    start.add_argument('CMD', nargs=argparse.REMAINDER, help=f'Command to start the service in the service namespace with or without arguments.')

    connect = subparsers.add_parser('connect', help='Connect to an onion vpn service')
    connect.set_defaults(func=connect_command)
    connect.add_argument('URL', nargs=1, help=f'URL')

    install = subparsers.add_parser('install', aliases=['in'], help='Installs a service which automatically starts the VPN on system startup and tears it down on system shutdown. A udev rule move new network devices into physical namespace and automatically creates it if it does not exists. A timer will rotate WireGuard keys every 4 days (same as the Mullvad app).')
    install.set_defaults(func=install_command)

    uninstall = subparsers.add_parser('uninstall', aliases=['un'], help='Uninstalles all services.')
    uninstall.set_defaults(func=uninstall_command)

    move = subparsers.add_parser('move', aliases=['mv'], help='Move a physical device into the physical namespace if it exists.')
    move.add_argument('INTERFACE', nargs=1, help='Interface name that will be moved.')
    move.set_defaults(func=move_command)

    rotate = subparsers.add_parser('rotate', help='Rotate WireGuard keys from all mapped peers.')
    rotate.add_argument('-p', '--passname', nargs=1, dest='passname', help='Request account number from pass.', default='web/mullvad')
    rotate.set_defaults(func=rotate_command)

    reset = subparsers.add_parser('reset', help='Tear down vpn, delete all mapped peers to this computer, remove services added through `vpn service` and remove account related information from configuration.')
    reset.set_defaults(func=reset_command)

    test = subparsers.add_parser('test', help='Run unittests.')
    test.add_argument('-d', '--docker', action='store_true', help='Run the tests in different docker images (archlinux, ubuntu, debian).')
    test.add_argument('-s', '--docker-skip-build', action='store_true', help='Skip docker build.')
    test.add_argument('UNITTEST_CMD', nargs=argparse.REMAINDER, help='Command(s) for unittest.')
    test.set_defaults(func=test_command)

    args = parser.parse_args()

    global VERBOSE
    VERBOSE = args.verbose

    global colored
    if args.no_color:
        colored = nop_colored

    if args.print_args:
        if os.geteuid() == 0:
            print(args)

    try:
        if not 'func' in args:
            parser.print_help()
        elif args.func == info_command:
            args.func(args, up)
        elif args.func == up_command:
            args.func(args, is_default=is_default_arguments(parser, up, args))
        elif args.func in [rotate_command, start_command]:
            args.func(args, get_default_arguments(parser, up))
        else:
            args.func(args)
    except KeyboardInterrupt:
        sys.exit(1)
    except CommandFailed as e:
        # TODO: Should this only apply to the first `vad up`, and not to partial ups's?
        if args.func == up_command:
            log_warn("A command failed during `vad up`, to leave the network in a working state we will undo all changes with `vad down`.")
            down_command(Namespace(config=args.config, partial=False))
        sys.exit(e.returncode)
    except Abort:
        sys.exit(1)

if __name__ == "__main__":
    vad()
