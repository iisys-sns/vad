#!/usr/bin/env python3

import argparse
import json
import math
import os
import random
import requests
import shutil
import subprocess
import sys
import unittest
import yaml
import fcntl
import atexit
import dbus


from datetime import datetime
from termcolor import colored
from argparse import Namespace
from collections import defaultdict
from collections import Counter
from datetime import datetime
from enum import Enum
from prettytable import PrettyTable

import inspect
from io import StringIO
from requests import Response
from contextlib import redirect_stdout
from functools import partial


VERBOSE = False


PREFIX = '/etc'
NAME = 'vad'
RUN_DIR = '/var/run/vad'
LOCK_FILE = f'{RUN_DIR}/lock'
CONFIGURATION_HOP = f'{PREFIX}/wireguard/{NAME}%d.conf'
DEVICE_NAME_HOP = f'{NAME}%d'
NAMESPACE_HOP = f'{NAME}%d'
DESCRIPTION = f'{PREFIX}/wireguard/{NAME}.description'
CONFIGURATION = f'{PREFIX}/{NAME}/config.yaml'
WPA_SUPPLICANT_CONF = f'{PREFIX}/wpa_supplicant/{NAME}.conf'
SERVERS = f'{PREFIX}/{NAME}/servers.json'
NAMESPACE_ROOT = '1'
NAMESPACE_PHYSICAL = 'physical'
EUROPE_UNION = ["at", "be", "bg", "hr", "cy", "cz", "dk", "ee", "fi", "fr", "de", "gr", "hu", "ie", "it", "lv", "lt", "lu", "mt", "nl", "pl", "pt", "ro", "sk", "si", "es", "se"]
EUROPE_CONTINENT = EUROPE_UNION + ["is", "no", "li", "ch", "uk", "gb", "me", "mk", "al", "rs", "tr", "ba", "xk", "am", "az", "by", " md", "ge", "ua"]


class DeviceType(Enum):
    Ethernet = 1
    Wifi = 2
    Virtual = 3


def nop_colored(text, *args, **kwargs):
    return text


if not sys.stdout.isatty() or not sys.stderr.isatty():
    colored = nop_colored


already_locked = False


def lock():
    global already_locked
    if already_locked:
        return
    os.makedirs(RUN_DIR, exist_ok=True)
    fd = open(LOCK_FILE, 'a')
    fcntl.lockf(fd, fcntl.LOCK_EX)
    fd.write('%s\n' % os.getpid())
    fd.flush()
    atexit.register(lambda: partial(unlock, fd)())
    already_locked = True


def unlock(fd):
    sys.stdout.flush()
    fcntl.lockf(fd, fcntl.LOCK_UN)
    fd.truncate(0)
    fd.close()


def become_root(do_lock=True):
    if os.geteuid() != 0:
        os.execvp("sudo", ["sudo", "-E"] + sys.argv)

    # NOTE: Everytime we become root, we want usually to do some atomic
    # operation, to prevent race conditions, we want to serialize the execution with
    # a file lock
    if do_lock:
        try:
            lock()
        except Exception as e:
            log_fatal("Can not acquire file lock (%s)!" % str(e))


def log_verbose(text, **kwargs):
    if VERBOSE:
        print(colored(text, 'cyan'), **kwargs)


def log_info(text, highlight=False, **kwargs):
    attrs=[]
    if highlight:
        attrs=['bold']
    print(colored(text, 'blue', attrs=attrs), **kwargs)


def log_good(text, **kwargs):
    print(colored(text, 'green'), **kwargs)


def log_success(text, **kwargs):
    print(colored(text, 'green', attrs=['bold']), **kwargs)


def log_warn(text, **kwargs):
    print(colored(text, 'yellow'), **kwargs)


class Abort(Exception):
    pass


def log_fatal(text, **kwargs):
    log_bad(text, **kwargs)
    raise Abort


def log_bad(text, **kwargs):
    print(colored(text, 'red'), **kwargs)


def print_command(process, print_output=True, **kwargs):
    if 'shell' in kwargs and kwargs['shell']:
        command = process.args
    else:
        command = subprocess.list2cmdline(process.args)
    command = command.replace('\n','\\n')

    if process.returncode == 0:
        log_good('+ ' + command)
    else:
        log_bad('- ' + command)

    if print_output and len(process.stdout) > 0:
        lines = str(process.stdout, 'utf8')
        lines = lines.split('\n')
        output = '\n  '.join(lines)
        output = output.strip()
        print('  ' + output)


def run(args, failure_ok=False, print_output=True, **kwargs):
    if VERBOSE:
        if 'shell' in kwargs and kwargs['shell']:
            command = args
        else:
            command = subprocess.list2cmdline(args)
        command = command.replace('\n','\\n')
        if sys.stdout.isatty() and sys.stderr.isatty():
            log_info('= ' + command + '\r', end='')

    process = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, **kwargs)

    if VERBOSE:
        print_command(process, print_output=print_output, **kwargs)
    elif not failure_ok and process.returncode != 0:
        print_command(process, print_output=print_output, **kwargs)

    return process


class CommandFailed(Abort):
    def __init__(self, returncode):
        self.returncode = returncode


def run_or_fail(args, **kwargs):
    process = run(args, **kwargs)
    if process.returncode != 0:
        raise CommandFailed(process.returncode)
    return process


def device_move_to_physical(device):
    type, dev, phy = device

    log_verbose("Move device '%s' into %s namespace:" % (dev, NAMESPACE_PHYSICAL))

    run_or_fail(["ip", "link", "set", dev, "down"])
    run_or_fail(["resolvconf", "-f", "-d", '%s.*' % dev])

    if type == DeviceType.Ethernet:
        run_or_fail(["ip", "link", "set", dev, "netns", NAMESPACE_PHYSICAL])
    elif type == DeviceType.Wifi:
        run_or_fail(["iw", "phy", phy, "set", "netns", "name", NAMESPACE_PHYSICAL])
        run_or_fail(["ip", "netns", "exec", NAMESPACE_PHYSICAL, "wpa_supplicant", "-B", "-c", WPA_SUPPLICANT_CONF, "-i", dev])
    else:
        assert False

    run_or_fail(["ip", "netns", "exec", NAMESPACE_PHYSICAL, "dhcpcd", "-b", dev])


def write_wireguard_config(device_index, device, public_key, address, port=51820):
    wireguard_config = f"""
        [Interface]
        PrivateKey = {device['private_key']}

        [Peer]
        PublicKey = {public_key}
        AllowedIPs = 0.0.0.0/0,::0/0
        Endpoint = {address}:{port}
        """

    wireguard_config = wireguard_config.strip()
    wireguard_config = '\n'.join([line.strip() for line in wireguard_config.split('\n')])

    configuration_filename = CONFIGURATION_HOP % device_index
    log_verbose("Create wireguard config: %s" % configuration_filename)
    if os.path.exists(configuration_filename):
        log_fatal("Configuration %s already exists!" % configuration_filename)
    with open(configuration_filename, 'w') as c:
        c.write(wireguard_config)

    return configuration_filename, DEVICE_NAME_HOP % device_index, device['ipv4'], device['ipv6']


def update_resolvconf(dns):
    log_verbose('Update `resolvconf` with nameserver %s:' % dns)
    with subprocess.Popen(['resolvconf', '-a', '%s.vad' % DEVICE_NAME_HOP % 0], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) as process:
        process.stdin.write(bytes('nameserver %s\n' % dns, 'utf8'))
        process.stdin.close()
        stdout = process.stdout.read()
        process.stdout.close()
        process.stdout = stdout
    if VERBOSE:
        print_command(process)
    run(['resolvconf', '-u'])


def is_active():
    any_exists = os.path.exists(CONFIGURATION_HOP % 0) or os.path.exists(DESCRIPTION)
    all_exists = os.path.exists(CONFIGURATION_HOP % 0) and os.path.exists(DESCRIPTION)

    if not any_exists == all_exists:
        log_warn('Warning: If the VPN is active or inactive two things should exist or not exist:')
        log_warn('- %s (%s) and' % (DESCRIPTION, os.path.exists(DESCRIPTION)))
        log_warn('- %s (%s)' % (CONFIGURATION_HOP % 0, os.path.exists(CONFIGURATION_HOP % 0)))

    return (
        os.path.exists(CONFIGURATION_HOP % 0) or
        os.path.exists(DESCRIPTION)
    )


def get_dns_server_from_flags(flags):
    bits = 0
    for flag in flags:
        if flag == 'a':
            bits |= 1
        elif flag == 't':
            bits |= 1<<1
        elif flag == 'm':
            bits |= 1<<2
        elif flag == 'p':
            bits |= 1<<3
        elif flag == 'g':
            bits |= 1<<4
        else:
            log_warn('Unkown flag "%s" for DNS server, we will ignore it!' % flag)

    if bits == 0:
        return '10.64.0.1'
    else:
        return '100.64.0.%d' % bits


def filter_servers(type='wireguard', owned=None, active=None, country_city_hostname=None, diskless=None, servers=None):
    if servers is None:
        if os.path.exists(SERVERS):
            with open(SERVERS) as f:
                servers = json.load(f)
        else:
            log_fatal('%s does not exists, please use `vad update`, `vad up --update-server-list` or `vad init`.' % SERVERS)

    if type is not None:
        servers = filter(lambda server: server['type'] == type, servers)

    if owned is not None:
        servers = filter(lambda server: server['owned'] == owned, servers)

    if active is not None:
        servers = filter(lambda server: server['active'] == active, servers)

    if country_city_hostname is not None and not country_city_hostname == 'w':
        if country_city_hostname == 'eu':
            servers = filter(lambda server: server['country_code'] in EUROPE_UNION, servers)
        elif country_city_hostname == 'ec':
            servers = filter(lambda server: server['country_code'] in EUROPE_CONTINENT, servers)
        elif len(country_city_hostname) == 2:
            servers = filter(lambda server: server['country_code'] == country_city_hostname, servers)
        elif len(country_city_hostname) == 3:
            servers = filter(lambda server: server['city_code'] == country_city_hostname, servers)
        elif len(country_city_hostname) >= 4:
            servers = filter(lambda server: country_city_hostname in server['hostname'], servers)
        else:
            servers = []

    if diskless is not None:
        servers = filter(lambda server: server['stboot'] == diskless, servers)

    servers = list(servers)
    return servers


def server_random_choice(servers, uniform_by_country=False):
    if uniform_by_country:
        countries = set()
        for server in servers:
            countries.add(server['country_code'])
        countries = list(countries)
        if len(countries) == 0:
            return None
        country = random.choice(countries)
        servers = filter_servers(country_city_hostname=country, servers=servers)
    if len(servers) == 0:
        return None
    return random.choice(servers)


def verify_account_number(account_number):
    # NOTE: https://mullvad.net/en/blog/2017/6/20/mullvads-account-numbers-get-longer-and-safer
    if len(account_number) in [12, 13, 16] or not account_number.isdigit():
        return False
    return True


def request_account_number(passname, config):
    if 'account_number' in config:
        return config['account_number']

    try:
        uid = os.getenv('SUDO_UID', os.geteuid())
        gid = os.getenv('SUDO_GID', os.getegid())
        process = run(['sudo', '-E', '-u', '#%s' % uid, '-g', '#%s' % gid, 'pass', passname], failure_ok=True)
        if process.returncode == 0:
            lines = str(process.stdout, 'utf8')
            lines = lines.split('\n')
            if len(lines) >= 1:
                account_number = lines[0]
                if len(account_number) == 16:
                    return account_number
    except FileNotFoundError:
        pass

    while True:
        account_number = input("Please enter your Mullvad account number (with or w/o spaces): ")
        account_number = account_number.replace(" ", "")
        if verify_account_number(account_number):
            print("The account number must be have 12, 13 or 16 digits!")
            continue
        return account_number


def request_login(account_number):
    log_verbose('request login...', end='')
    try:
        response = requests.get("https://api.mullvad.net/www/accounts/%s/" % account_number)
    except Exception as e:
        log_fatal("Error while sending request to login (%s)!" % (str(e)))
    log_verbose('%s' % response.status_code)
    if not response.ok:
        log_fatal("Could not login into account (%d:%s)!" % (response.status_code, response.text))
    try:
        return response.json()
    except Exception as e:
        log_fatal("Could not parse account information (%s)!" % (str(e)))


def request_account(login):
    try:
        log_verbose('request account...', end='')
        response = requests.get(
            "https://api.mullvad.net/www/me",
            headers=dict(
                Authorization='Token %s' % login['auth_token']
            ),
        )
        log_verbose('%s' % response.status_code)
    except Exception as e:
        log_fatal("Error while sending request to receive account information (%s)!" % (str(e)))
    if not response.ok:
        log_fatal("Could not receive account information (%d:%s)!" % (response.status_code, response.text))
    try:
        return response.json()
    except Exception as e:
        log_fatal("Could not parse account information (%s)!" % (str(e)))


def request_login_api(args, account_number, config):
    auth = config.get('auth', None)
    if auth:
        expires = datetime.strptime(auth['api_expiry'], "%Y-%m-%dT%H:%M:%S+00:00")
        if expires > datetime.now():
            return config

    try:
        log_verbose('request login api...', end='')
        response = requests.post(
            'https://api.mullvad.net/auth/v1/token',
            json=dict(
                account_number=account_number
            )
        )
        log_verbose('%s' % response.status_code)
    except Exception as e:
        log_fatal("Error while sending request to login into api (%s)!" % (str(e)))

    if not response.ok:
        log_fatal("Could not login into api (%d:%s)!" % (response.status_code, response.text))

    try:
        # {'access_token': '...', 'expiry': 'YYYY-mm-ddTHH:MM:SS+00:00'}
        app = response.json()
    except Exception as e:
        log_fatal("Could not parse api login response (%s)!" % (str(e)))

    config['auth'] = dict(
        api_token=app['access_token'],
        api_expiry=app['expiry'],
    )

    return config_save(args.config, config)


def request_add_key(login):
    log_verbose('request add key...', end='')
    private_key = generate_private_key()
    public_key = get_public_key(private_key)
    try:
        response = requests.post(
            "https://api.mullvad.net/www/wg-pubkeys/add/",
            headers=dict(
                Authorization='Token %s' % login['auth_token']
            ),
            json=dict(
                pubkey=public_key
            )
        )
    except Exception as e:
        log_fatal("Error while sending request to adding new public key (%s)!" % (str(e)))
    log_verbose('%s' % response.status_code)
    if not response.ok:
        log_fatal("Could not add new public key to account (%d:%s)!" % (response.status_code, response.text))
    try:
        peer = response.json()
    except Exception as e:
        log_fatal("Adding new public key: Could not parse response (%s:%s)!" % (response.text, str(e)))
    if peer['key']['public'] != public_key:
        log_fatal("Adding new public key: Public key in response should be equal to sended public key, but is not (%s (response) != %s (sended))!" % (peer['key']['public'], public_key))
    return (private_key, peer)


def request_update_public_key(config, device):
    if not 'device_id' in device:
        return

    private_key = generate_private_key()
    public_key = get_public_key(private_key)

    try:
        log_verbose('request update public key...', end='')
        response = requests.put(
            "https://api.mullvad.net/accounts/v1/devices/%s/pubkey" % device['device_id'],
            headers=dict(
                Authorization='Bearer %s' % config['auth']['api_token']
            ),
            json=dict(
                pubkey=public_key
            )
        )
        log_verbose('%s' % response.status_code)
    except Exception as e:
        log_fatal("Error while sending request to update public key for device %s (%s)!" % (device['device_id'], str(e)))
    if not response.ok:
        log_fatal("Could not update public key to account (%d:%s)!" % (response.status_code, response.text))

    try:
        peer = response.json()
    except Exception as e:
        log_fatal("Update public key: Could not parse response (%s:%s)!" % (response.text, str(e)))
    if peer['pubkey'] != public_key:
        log_fatal("Update public key: Public key in response should be equal to sended public key, but is not (%s (response) != %s (sended))!" % (peer['pubkey'], public_key))

    return private_key, peer


def request_revoke_key(login, public_key):
    log_verbose('request revoke key %s...' % public_key, end='')
    try:
        response = requests.post(
            "https://api.mullvad.net/www/wg-pubkeys/revoke/",
            headers=dict(
                Authorization='Token %s' % login['auth_token']
            ),
            json=dict(
                pubkey=public_key
            )
        )
    except Exception as e:
        log_fatal("Error while sending request to revoke public key (%s)!" % (str(e)))
    log_verbose('%s' % response.status_code)
    return response.ok


def request_logout(login):
    log_verbose('request logout...', end='')
    try:
        response = requests.post(
            "https://api.mullvad.net/www/expire-auth-token/",
            headers=dict(
                Authorization='Token %s' % login['auth_token']
            )
        )
    except Exception as e:
        log_fatal("Error while sending request to logout (%s)!" % (str(e)))
    log_verbose('%s' % response.status_code)
    return response.ok


def config_load(filename):
    if not os.path.exists(filename):
        return False

    with open(filename) as c:
        config = yaml.safe_load(c)
    for key in config:
        if config[key] is None:
            config[key] = ''
    return config


def config_save(filename, config):
    assert isinstance(config, dict)
    with open(filename, 'w') as c:
        yaml.dump(config, c)
    os.chmod(filename, 0o600)
    return config


def config_save_up_command(config, args):
    args_to_save = dict(vars(args))

    del args_to_save['func']
    del args_to_save['verbose']
    del args_to_save['print_args']
    del args_to_save['no_color']

    del args_to_save['dry_run']
    del args_to_save['dont_save']

    config['up_command'] = args_to_save
    return config_save(args.config, config)


def config_execute_commands(config, subsection_name):
    subsection = config.get(subsection_name, [])
    if not isinstance(subsection, list):
        return
    if subsection:
        log_verbose("Execute commands from '%s':" % (subsection_name))
        for command in subsection:
            run(['bash', '-c', command.replace('\\n', '\n')])


def config_set_up_command_attributes(config, args):
    up_command = config.get('up_command', {})
    for key, value in up_command.items():
        setattr(args, key, value)


def config_rebuild_up_command(config, parser_up):
    up_command = config.get('up_command', {})

    cmdline = ['vad', 'up']

    order = [
        'update_server_list',
        'dns',
        'without_multihop'
        'uniform_by_country',
        'owned_entry',
        'diskless_entry',
        'only_use_ipv6',
        'COUNTRY_CITY_HOSTNAME',
    ]

    defaults = dict(vars(parser_up.parse_args([])))

    for name in order:
        if name not in up_command:
            continue
        if name not in defaults:
            continue
        value = up_command[name]
        if defaults[name] == value:
            continue
        if name == 'COUNTRY_CITY_HOSTNAME':
            cmdline.extend(value)
        elif name == 'dns':
            cmdline.append('--dns')
            if isinstance(value, list):
                cmdline.append(value[0])
            else:
                cmdline.append(value)
        elif isinstance(defaults[name], bool) and value:
            cmdline.append('--%s' % name.replace('_', '-'))
        else:
            assert False, "Can not handle %s attribute!" % name

    return subprocess.list2cmdline(cmdline)


def init_command(args):
    become_root()

    config = config_load(args.config)

    if isinstance(config, dict):
        if not 'devices' in config:
            config['devices'] = []
        if not args.add_device and len(config['devices']) > 0:
            log_fatal('Already initialized with at least one device. If you want to add a new device, use `--add-device`.')
    else:
        config = dict(devices=[])

    if len(config['devices']) == 0:
        update_command(None)

    account_number = request_account_number(args.passname, config)
    login = request_login(account_number)

    try:
        account = login['account']

        if not account['active']:
            log_fatal('Your account is expired (since %s)!' % account['expires'])

        if not account['can_add_wg_peers']:
            log_fatal('You can not add more devices, account is full!' )

        private_key, peer = request_add_key(login)

        account = request_account(login)

        for device in account['account']['wg_peers']:
            if device['key']['public'] == peer['key']['public']:
                config['devices'].append(dict(
                    private_key=private_key,
                    ipv4=peer['ipv4_address'],
                    ipv6=peer['ipv6_address'],
                    device_id=device['device_id'],
                    device_name=device['device_name'],
                ))
                break

        if args.dont_save_account_number:
            if 'account_number' in config:
                del config['account_number']
        else:
            config['account_number'] = account_number

        config = config_save(args.config, config)

        if len(config['devices']) == 1:
            log_info('First device added (you can now use `vad up`)')
        else:
            log_info('New device added')
    finally:
        request_logout(login)

    return config


def delete_command(args):
    become_root()

    config = config_load(args.config)

    if not args.all and args.INDEX is None:
        log_warn('Specify a INDEX or use `--all`')
        raise Abort()
    elif args.all:
        devices = config['devices']
    else:
        index = int(args.INDEX[0])
        if index < len(config['devices']):
            device = config['devices'][index]
            devices = [device]
        else:
            log_warn('Device with index %d does not exists!' % index)
            return

    account_number = request_account_number(args.passname, config)
    login = request_login(account_number)

    try:
        for device in devices:
            public_key = get_public_key(device['private_key'])
            request_revoke_key(login, public_key)
            config['devices'].remove(device)
            log_info("Deleted device %s (index %d)!" % (public_key, index))
        config = config_save(args.config, config)
    finally:
        request_logout(login)

    return config


def generate_private_key():
    process = run(['wg', 'genkey'], failure_ok=True, print_output=False)
    key = str(process.stdout, 'utf8').strip()
    assert len(key) == 44
    return key


def get_public_key(private_key):
    process = subprocess.Popen(['wg', 'pubkey'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)
    process.stdin.write(bytes('%s\n' % private_key, 'utf8'))
    process.stdin.close()
    stdout = process.stdout.read()
    process.stdout.close()
    return str(stdout, 'utf8').strip()


def get_this_peer(device, login):
    if device is not None:
        public_key = get_public_key(device['private_key'])
        for wg_peer in login['account']['wg_peers']:
            if wg_peer['key']['public'] == public_key:
                return wg_peer
    return None


def get_city_ports(city_ports):
    ports = []
    for city_port in city_ports:
        ports.append('%s-%s' % (city_port['city_code'], city_port['port']))
    return ports


def print_peer_table(peers, this_peers, show_ipv6, show_device_id):
    add_peer = lambda current, peer: table.add_row([
            current,
            '✓' if peer['app'] else '',
            peer['created']] +
            ([peer['device_id']] if show_device_id else []) +
            [peer['device_name'].title(),
            peer['ipv4_address']] +
            ([peer['ipv6_address']] if show_ipv6 else []) +
            [peer['key']['public'],
            '✓' if peer['can_add_ports'] else '',
            '\n'.join([str(port) for port in  peer['ports']]),
            '\n'.join(get_city_ports(peer['city_ports']))
        ])

    fields = ['Index','By App', 'Created']

    if show_device_id:
        fields.append('ID')

    fields.extend(['Name', 'IPv4'])

    if show_ipv6:
        fields.append('IPv6')

    fields.extend(['Public Key', 'Can Add Ports', 'Ports', 'City Ports'])

    table = PrettyTable(fields)

    table.align['Name'] = 'l'
    table.align['IPv4'] = 'r'
    table.align['IPv6'] = 'r'
    for idx, peer in enumerate(this_peers):
        if peer:
            add_peer(str(idx), peer)
    for peer in peers:
        if peer in this_peers:
            continue
        add_peer('', peer)
    print(table)


def info_command(args, parser_up):
    become_root()

    config = config_load(args.config)
    account_number = request_account_number(args.passname, config)
    login = request_login(account_number)

    try:
        peers = []
        if config:
            for device in config['devices']:
                peer = get_this_peer(device, login)
                peers.append(peer)

        if args.raw:
            for peer in peers:
                print(yaml.dump(peer), end='')
                print('---')
            print(yaml.dump(login['account']), end='')
        else:
            account = login['account']

            print('Account number: ', end='')
            if args.show_account_number:
                log_info(account['pretty_token'], highlight=True, end=' ')
                print('(%s)' % account['token'])
            else:
                print('*' * 16)

            expires = datetime.strptime(account['expires'], "%Y-%m-%dT%H:%M:%S+00:00")
            delta = expires - datetime.now()
            if account['active']:
                print('Expires:', end=' ')
                log_good(str(expires), end=' ')
                print('(in %d days)' % delta.days)
            else:
                print('Expired:', end=' ')
                log_bad(str(expires), end=' ')
                print('(since %d days)' % (-1*delta.days))

            print('Subscription: %s' % account['subscription'])

            print('Devices: ', end='')
            devices = '%s/%s' % (len(account['wg_peers']), account['max_wg_peers'])
            if account['can_add_wg_peers']:
                log_good(devices)
            else:
                log_warn(devices)

            print('Ports: ', end='')
            ports = '%s/%s' % (len(account['ports']), account['max_ports'])
            if account['can_add_ports']:
                log_good(ports)
            else:
                log_warn(ports)

            for city_port in account['city_ports']:
                print('- %s-%s' % (city_port['city_code'], city_port['port']))
            print()
            print_peer_table(account['wg_peers'], peers, args.show_ipv6, args.show_device_ids)
            print()
            log_info('If you only call `vad up` this command will be executed: ', end='')
            print(config_rebuild_up_command(
                config,
                parser_up))
    except Exception as e:
        log_fatal('Error while trying to show account information (%s)!' % str(e))
    finally:
        request_logout(login)


def show_command(args):
    become_root()

    if is_active():
        try:
            with open(DESCRIPTION) as desc:
                log_info('Configuration:', highlight=True)
                print(desc.read().strip())
                print()
                sys.stdout.flush()
            subprocess.run(["wg"])
            for idx in range(1, 10):
                namespace = NAME + str(idx)
                if network_namespace_exists(namespace):
                    print()
                    subprocess.run(["ip", "netns", "exec", namespace, "wg"])
        except Exception as e:
            log_warn("VPN seemed to be active but something went wrong (%s)" % str(e))
        print()
    else:
        log_bad("You are not connected to Mullvad.")
        raise Abort()

    if not print_status_connected():
        raise Abort()


def describe_server(server):
    return f"{server['city_name']}, {server['country_name']} ({server['hostname']}:{server['ipv4_addr_in']}:{server['multihop_port']})"


def get_dns_from_args(args):
    if len(args.dns) == 0:
        return get_dns_server_from_flags('')
    else:
        return get_dns_server_from_flags(args.dns[0])


def setup_wireguard_device(namespace_new, namespace_link_to, device_name, config_filename, ipv4, ipv6, mtu, only_use_ipv6):
    update_physical_namespace = network_namespace_exists(NAMESPACE_PHYSICAL) and namespace_new == NAMESPACE_PHYSICAL

    if update_physical_namespace:
        prefix = 'Update'
    else:
        prefix = 'Create'

    log_verbose(f"{prefix} namespace %s and link to %s (device=%s, ipv4=%s, ipv6=%s, mtu=%s)" % (
        namespace_new,
        namespace_link_to,
        device_name,
        ipv4,
        ipv6,
        mtu
    ))

    if not update_physical_namespace:
        run_or_fail(["ip", "netns", "add", namespace_new])
        run_or_fail(["ip", "-n", namespace_new, "link", "set", "lo", "up"])
        # NOTE: allow "ping" command for all user groups in the physical namespace
        run_or_fail(["ip", "netns", "exec", namespace_new, "sysctl", 'net.ipv4.ping_group_range=0 2147483647'])

    run_or_fail(["ip", "-n", namespace_new, "link", "add", device_name, "type", "wireguard"])
    run_or_fail(["ip", "-n", namespace_new, "link", "set", device_name, "netns", namespace_link_to])

    if namespace_link_to == NAMESPACE_ROOT:
        execute_namespace = []
    else:
        execute_namespace = ["ip", "netns", "exec", namespace_link_to]

    run_or_fail(execute_namespace + ["wg", "setconf", device_name, config_filename])
    if not only_use_ipv6:
        run_or_fail(execute_namespace + ["ip", "addr", "add", ipv4, "dev", device_name])
    run_or_fail(execute_namespace + ["ip", "addr", "add", ipv6, "dev", device_name])
    run_or_fail(execute_namespace + ["ip", "link", "set", device_name, "up"])
    run_or_fail(execute_namespace + ["ip", "link", "set", device_name, "mtu", str(mtu)])
    run_or_fail(execute_namespace + ["ip", "route", "add", "default", "dev", device_name])


def print_status_connected():
    try:
        response = requests.get("https://am.i.mullvad.net/connected")
        if 'You are not' in response.text:
            log_bad(response.text.strip())
            return False
        elif response.ok:
            log_good(response.text.strip())
            return True
        else:
            log_bad(response.text.strip())
            return False
    except:
        log_bad("Not able to determine if connected to VPN.")
        return False


def workaround_fetch_current_wifi_configuration():
    for device in get_network_devices():
        if device[0] == DeviceType.Wifi:
            log_verbose("fetch current wifi configuration:")
            device_name = device[1]
            log_verbose("- gather configuration for device: '%s'" % device_name)
            try:
                bus = dbus.SystemBus()
                proxy = bus.get_object('fi.w1.wpa_supplicant1', '/fi/w1/wpa_supplicant1')
                wpas = dbus.Interface(proxy, 'fi.w1.wpa_supplicant1')
                interface_path = wpas.GetInterface(device_name)
                log_verbose('- interface path: %s' % interface_path)
                proxy = bus.get_object('fi.w1.wpa_supplicant1', interface_path)
                current_network_path = proxy.Get('fi.w1.wpa_supplicant1.Interface', 'CurrentNetwork', dbus_interface=dbus.PROPERTIES_IFACE)
                log_verbose('- current network path: %s' % current_network_path)
                proxy = bus.get_object('fi.w1.wpa_supplicant1', current_network_path)
                network = proxy.Get('fi.w1.wpa_supplicant1.Network', 'Properties', dbus_interface=dbus.PROPERTIES_IFACE)
                config = {}
                for key, value in network.items():
                    config[str(key)] = str(value)
            except Exception as e:
                log_bad("Can not retrieve wifi information from wpa supplicant over DBus (%s)" % str(e))
                return {}

            # FIXME: Why does wpa supplicant not send us the PSK?
            try:
                log_verbose("retrieve PSK from NetworkManager:")

                process = run(
                    "nmcli con show --active | grep %s | cut -d' ' -f3" % device_name,
                    failure_ok=True, print_output=False, shell=True
                )
                uuid = str(process.stdout, 'utf8').strip()

                process = run(
                    "nmcli --show-secrets --fields 802-11-wireless-security.psk con show %s | cut -d: -f2 | xargs" % uuid,
                    failure_ok=True, print_output=False, shell=True
                )
                psk = str(process.stdout, 'utf8').strip()

                config['psk'] = '"%s"' % psk
            except Exception as e:
                log_bad("Can not retrieve wifi information from wpa supplicant over DBus (%s)" % str(e))
                return {}

            return config


def write_wpa_supplicant_config(wifi_config):
    config = [
        "ctrl_interface=/run/wpa_supplicant",
        "update_config=1",
        "",
        "network={"
    ]
    for key, value in wifi_config.items():
        key = key.strip()
        value = value.strip()
        if len(value) == 0:
            log_debug("key has zero length!")
            continue
        config.append('    %s=%s' % (key, value))
    config.append("}")
    try:
        with open(WPA_SUPPLICANT_CONF, 'w') as f:
            f.write('\n'.join(config))
    except IOError as e:
        log_bad('Could not write configuration: %s (%s)' % (WPA_SUPPLICANT_CONF, str(e)))


def up_command(args, is_default):
    become_root()

    config = config_load(args.config)
    if not config or not isinstance(config, dict):
        if args.config == CONFIGURATION:
            log_fatal('Default configuration file not found or is not readable (use `vad init` to create one)!')
        else:
            log_fatal('Configuration file "%s" not found or is not readable!' % args.config)

    if is_default:
        config_set_up_command_attributes(config, args)

    if args.update_server_list:
        update_command(None)

    if len(config['devices']) == 0:
        log_fatal('No devices configured (use `vad init` to create a device)!')

    if len(args.COUNTRY_CITY_HOSTNAME) > 10:
        log_fatal('Only 10 hops are supported, you specified %d (%s)!' % (len(args.COUNTRY_CITY_HOSTNAME), args.COUNTRY_CITY_HOSTNAME))

    hops = len(args.COUNTRY_CITY_HOSTNAME)
    if not args.without_multihop:
        needed = math.ceil(hops / 2) - len(config['devices'])
        if needed > 0:
            log_fatal('You do not have enough devices to build a %d hop tunnel. With multihop you need at least %d more device(s) (use `vad init --add-device`)' % (hops, needed))
    else:
        needed = hops - len(config['devices'])
        if needed > 0:
            log_fatal('You do not have enough devices to build a %d hop tunnel. Without multihop you need at least %d more device(s) (use `vad init --add-device`)' % (hops, needed))

    if len(args.COUNTRY_CITY_HOSTNAME) == 0:
        args.COUNTRY_CITY_HOSTNAME = ['w']

    servers = [
        server_random_choice(
            filter_servers(
                active=True,
                owned=args.owned_entry if args.owned_entry else None,
                country_city_hostname=args.COUNTRY_CITY_HOSTNAME[0],
                diskless=args.diskless_entry if args.diskless_entry else None,
            ),
            uniform_by_country=args.uniform_by_country
        )
    ]
    for country_city_hostname in args.COUNTRY_CITY_HOSTNAME[1:]:
        for _ in range(10):
            chosen_server = server_random_choice(
                filter_servers(
                    active=True,
                    country_city_hostname=country_city_hostname
                ),
                uniform_by_country=args.uniform_by_country
            )
            if not chosen_server in servers:
                servers.append(chosen_server)
                break

    if None in servers:
        log_fatal('Filter criteria "%s" does not return any server!' %  args.COUNTRY_CITY_HOSTNAME[servers.index(None)])

    if len(servers) != len(args.COUNTRY_CITY_HOSTNAME):
        log_fatal("Could not chose unique servers for all hops! Please try again or use wider filter criteria.")

    if len(servers) % 2 != 0:
        i = iter(servers[1:])
    else:
        i = iter(servers)

    description = []
    if not args.without_multihop:
        for left, right in reversed(list(zip(i, i))):
            description.insert(0, describe_server(right))
            description.insert(0, describe_server(left) + " [Multihop]")
        if len(servers) % 2 != 0:
            description.insert(0, describe_server(servers[0]) + " [Tunnel]")
    else:
        for server in reversed(servers):
            description.insert(0, describe_server(server) + " [Tunnel]")

    description[-1] += ' [Exit]'
    description.append('with nameserver %s' % get_dns_from_args(args))
    description = '- ' + '\n- '.join(description)

    if args.dry_run:
        log_info("Would configure:", highlight=True)
        print(description)
        sys.exit(0)

    physical_already_existed = network_namespace_exists(NAMESPACE_PHYSICAL)

    was_already_active = is_active()

    if was_already_active:
        log_verbose("Was already active, do a partial tear down.")
        config = down_command(Namespace(config=args.config, partial=True))

    if not physical_already_existed:
        if args.auto_configure_wifi:
            wifi_config = workaround_fetch_current_wifi_configuration()
            write_wpa_supplicant_config(wifi_config)
        config_execute_commands(config, 'pre_up')

    log_info("Configure:", highlight=True)
    print(description)

    with open(DESCRIPTION, 'w') as c:
        c.write(f"{description}\n")

    if len(servers) % 2 != 0:
        i = iter(servers[1:])
    else:
        i = iter(servers)

    configurations = []
    namespaces = [NAMESPACE_ROOT]
    devices = iter(enumerate(config['devices']))
    if not args.without_multihop:
        for left, right in reversed(list(zip(i, i))):
            idx, device = next(devices)
            namespaces.insert(1, NAME + str(idx))
            configurations.append(write_wireguard_config(
                device_index=idx,
                device=device,
                public_key=right['pubkey'],
                address=left['ipv6_addr_in'] if args.only_use_ipv6 else left['ipv4_addr_in'],
                port=int(right['multihop_port'])
            ))
        if len(servers) % 2 != 0:
            idx, device = next(devices)
            namespaces.insert(1, NAME + str(idx))
            configurations.append(write_wireguard_config(
                device_index=idx,
                device=device,
                public_key=servers[0]['pubkey'],
                address=servers[0]['ipv6_addr_in'] if args.only_use_ipv6 else servers[0]['ipv4_addr_in'],
            ))
    else:
        for server in reversed(servers):
            idx, device = next(devices)
            namespaces.insert(1, NAME + str(idx))
            configurations.append(write_wireguard_config(
                device_index=idx,
                device=device,
                public_key=server['pubkey'],
                address=server['ipv6_addr_in'] if args.only_use_ipv6 else server['ipv4_addr_in'],
            ))

    namespaces[-1] = NAMESPACE_PHYSICAL

    for idx, (configuration_filename, device_name, ipv4, ipv6) in enumerate(configurations):
        namespace_new = namespaces[idx + 1]
        namespace_link_to = namespaces[idx]
        mtu = 1420 - (80 * (len(configurations) - idx - 1))
        setup_wireguard_device(
            namespace_new,
            namespace_link_to,
            device_name,
            configuration_filename,
            ipv4,
            ipv6,
            mtu,
            False
            # args.only_use_ipv6,
            # TODO: Why does IPv6 only not work?
        )

    if not physical_already_existed:
        run(["timeout", "-s", "KILL", "5", "killall", "-w", "wpa_supplicant", "dhcpcd"], failure_ok=True)
        run(["mkdir", "-p", "/etc/netns/physical"])
        run(["rm", "-f", "/etc/netns/physical/resolv.conf"])
        run(["touch", "/etc/netns/physical/resolv.conf"])

    for device in get_network_devices():
        if device[0] != DeviceType.Virtual:
            device_move_to_physical(device)

    update_resolvconf(get_dns_from_args(args))

    if not is_default and config and not args.dont_save:
        config = config_save_up_command(config, args)

    if not physical_already_existed:
        config_execute_commands(config, 'post_up')

    run(['systemctl', 'unmask', 'vad.move@.service'])
    log_success("VPN is successfully up!")

    print_status_connected()

    return config


def network_namespace_exists(namespace):
    return os.path.exists('/var/run/netns/%s' % namespace)


def remove_linked_device(namespace_to_remove, namespace_linked_to, device_name):
    log_verbose("Delete device %s from linked network namespace %s (birth place: %s)" % (device_name, namespace_linked_to, namespace_to_remove))

    if namespace_linked_to == NAMESPACE_ROOT:
        run(['ip', 'link', 'del', device_name])
    else:
        run(['ip', '-n', namespace_linked_to, 'link', 'del', device_name])


def remove_network_namespace(namespace_to_remove, namespace_linked_to, device_name):
    log_verbose("Remove network namespace %s which is linked to %s" % (namespace_to_remove, namespace_linked_to))

    process = run(['ip', 'netns', 'pids', namespace_to_remove], failure_ok=True)
    if process.returncode == 0:
        pids = str(process.stdout, 'utf8')
        pids = pids.split('\n')
        pids = pids[:-1]
        if pids:
            run(['ip', 'netns', 'exec', namespace_to_remove, 'kill'] + pids)

    if namespace_to_remove == NAMESPACE_PHYSICAL:
        devices = get_network_devices_from_namespace(namespace_to_remove)
        for type, name, phy in devices:
            run(['ip', '-n', namespace_to_remove, 'link', 'set', name, 'down'])
            if type == DeviceType.Wifi:
                run(['ip', 'netns', 'exec', namespace_to_remove, 'iw', 'phy', phy, 'set', 'netns', '1'])
            elif type == DeviceType.Ethernet:
                run(['ip', '-n', namespace_to_remove, 'link', 'set', name, 'netns', '1'])

    run(['ip', 'netns', 'del', namespace_to_remove])


def remove_file_if_exists(filename):
    if os.path.exists(filename):
        os.remove(filename)
        log_verbose('Removed %s' % filename)


def down_command(args):
    become_root()

    run(['systemctl', 'mask', 'vad.move@.service'])

    config = config_load(args.config)

    if config and (not args.partial):
        config_execute_commands(config, 'pre_down')

    remove_file_if_exists(DESCRIPTION)
    remove_file_if_exists(CONFIGURATION_HOP % 0)

    namespaces = [NAMESPACE_ROOT]
    for idx in range(1, 10):
        remove_file_if_exists(CONFIGURATION_HOP % idx)
        if network_namespace_exists(NAMESPACE_HOP % idx):
            namespaces.append(NAMESPACE_HOP % idx)
    namespaces.append(NAMESPACE_PHYSICAL)

    for idx in reversed(range(len(namespaces))):
        namespace = namespaces[idx]
        if network_namespace_exists(namespace):
            interface_name = namespaces[idx-1]

            if interface_name == NAMESPACE_ROOT:
                interface_name = 'vad0'

            remove_linked_device(
                namespace_to_remove=namespaces[idx],
                namespace_linked_to=namespaces[idx-1],
                device_name=interface_name,
            )

            if args.partial and namespaces[idx] == NAMESPACE_PHYSICAL:
                continue

            remove_network_namespace(
                namespace_to_remove=namespaces[idx],
                namespace_linked_to=namespaces[idx-1],
                device_name=interface_name,
            )

    if (config and not args.partial):
        config_execute_commands(config, 'post_down')

    if args.partial:
        log_success("VPN is succefully down (partial)")
    else:
        run(['systemctl', 'unmask', 'vad.move@.service'])
        log_success("VPN is succefully down")

    return config


def exec_command(args):
    become_root()

    uid = os.getenv('SUDO_UID', os.geteuid())
    gid = os.getenv('SUDO_GID', os.getegid())
    args = ["ip", "netns", "exec", NAMESPACE_PHYSICAL, "sudo", "-E", "-u", '#%s' % uid, "-g", '#%s' % gid, "--"] + args.CMD
    if VERBOSE:
        print(subprocess.list2cmdline(args))
    os.execvp("ip", args)


def list_command(args):
    servers = filter_servers(
        type=None if args.all else 'wireguard',
        active=args.active,
        owned=args.owned,
        country_city_hostname=args.COUNTRY_CITY_HOSTNAME,
        diskless=args.diskless
    )

    if args.group_by_country:
        countries = defaultdict(int)
        for server in servers:
            key = (server['country_code'], server['country_name'])
            countries[key] += 1

        table = PrettyTable(['Count', 'Code', 'Country'])
        table.align['Count'] = 'r'
        table.align['Country'] = 'l'
        for (country_code, country_name), count in sorted(countries.items(), key=lambda k: k[1]):
            table.add_row([count, country_code, country_name])
        print(table)
    elif args.group_by_country_city:
        country_cities = defaultdict(int)
        for server in servers:
            key = (
                server['country_code'], server['country_name'],
                server['city_code'], server['city_name']
            )
            country_cities[key] += 1

        table = PrettyTable(['Count', '', 'Country', 'Code', 'City'])
        table.align['Count'] = 'r'
        table.align['Country'] = 'l'
        table.align['City'] = 'l'
        for (country_code, country_name, city_code, city_name), count in sorted(country_cities.items(), key=lambda k: k[1]):
            table.add_row([count, country_code, country_name, city_code, city_name])
        print(table)
    elif args.group_by_provider:
        providers = defaultdict(int)
        for server in servers:
            key = (
                server['provider']
            )
            providers[key] += 1

        table = PrettyTable(['Count', 'Provider'])
        table.align['Count'] = 'r'
        table.align['Provider'] = 'l'
        for (provider), count in sorted(providers.items(), key=lambda k: k[1]):
            table.add_row([count, provider])
        print(table)
    else:
        fields = ['Active', 'Owned', 'Diskless']

        if args.all:
            fields.append('Type')

        fields.extend(['', 'Country', 'Code', 'City', 'Provider', 'Hostname'])

        if args.show_column_ipv4:
            fields.append('IPv4')
        if args.show_column_ipv6:
            fields.append('IPv6')

        fields.append('Multihop Port')

        if args.show_column_socks_proxy:
            fields.append('Socks Proxy')

        fields.append('Gbit/s')

        if args.show_column_public_key:
            fields.append('Public Key')

        if args.show_column_status_messages:
            fields.append('Messages')

        table = PrettyTable(fields)
        table.align['Country'] = 'l'
        table.align['City'] = 'l'
        table.align['Provider'] = 'l'
        table.align['Hostname'] = 'l'
        table.align['IPv4'] = 'r'
        table.align['IPv6'] = 'r'
        table.align['Gbit/s'] = 'r'
        for server in servers:
            values = [
                '✓' if server['active'] else '',
                '✓' if server['owned'] else '',
                '✓' if server['stboot'] else '',
            ]

            if args.all:
                values.append(server['type'])

            values.extend([
                server['country_code'],
                server['country_name'],
                server['city_code'],
                server['city_name'],
                server['provider'],
                server['hostname'],
            ])

            if args.show_column_ipv4:
                values.append(server['ipv4_addr_in'])
            if args.show_column_ipv6:
                values.append(server['ipv6_addr_in'])

            values.append(server['multihop_port'] if 'multihop_port' in server else '')

            if args.show_column_socks_proxy:
                values.append('%s:%s' % (server['socks_name'], server['socks_port']) if 'socks_name' in server else '')

            values.append(server['network_port_speed'])

            if args.show_column_public_key:
                values.append(server['pubkey'] if 'pubkey' in server else '')

            if args.show_column_status_messages:
                messages = ['%s: %s' % (message['timestamp'], message['message']) for message in server['status_messages']]
                values.append('\n'.join(messages))

            table.add_row(values)
        print(table)


def service_config():
    # SUBSYSTEM=="net", ACTION=="add", DEVPATH!="/devices/virtual/*", TAG+="systemd", ENV{SYSTEMD_WANTS}="vad.move@%E{INTERFACE}"
    udev_rule = """
    SUBSYSTEM=="net", ACTION=="add", DEVPATH!="/devices/virtual/*", RUN+="/bin/systemctl start vad.move@%E{ID_NET_NAME}"
    """

    vad_move_service = """
    [Unit]
    Description=Move interface to physical namespace

    [Service]
    Type=forking
    ExecStart=vad -nv mv %I
    """

    vad_rotate_service = """
    [Unit]
    Description=Rotate WireGuard keys of all devices

    [Service]
    Type=oneshot
    ExecStart=vad -nv rotate
    """

    vad_rotate_timer = """
    [Unit]
    After=network-online.target
    Description=Rotate WireGuard keys of all devices every 4 days

    [Timer]
    OnCalendar=*-*-2/4 02:00
    Persistent=true

    [Install]
    WantedBy=timers.target
    """

    vad_up_service = """
    [Unit]
    Description=Execute `vad update` and `vad up`

    [Service]
    Type=oneshot
    ExecStartPre=-vad -nv update
    ExecStartPre=vad -nv show
    ExecStart=vad -nv up
    """

    vad_up_timer = """
    [Unit]
    After=network-online.target
    Description=Execute `vad update` and `vad up` daily at 03:00 to refresh hop endpoints

    [Timer]
    OnCalendar=*-*-* 03:00
    Persistent=true

    [Install]
    WantedBy=timers.target
    """

    vad_service = """
    [Unit]
    Description=Starts Vad on system startup
    After=syslog.target network-online.target
    Wants=network-online.target

    [Service]
    Type=forking
    RemainAfterExit=yes
    ExecStart=vad -nv up
    ExecStop=vad -nv down

    [Install]
    WantedBy=multi-user.target
    """

    prefix='/usr/local'
    bin_prefix=f"{prefix}/bin"
    rule_prefix=f"{prefix}/lib/udev/rules.d"
    systemd_prefix=f"{prefix}/lib/systemd/system"

    return Namespace(
        prefix=prefix,
        bin_prefix=bin_prefix,
        bin_path=f"{bin_prefix}/vad",
        rule_prefix=rule_prefix,
        rule_path=f"{rule_prefix}/vad.rules",
        systemd_prefix=systemd_prefix,
        udev_rule=udev_rule,
        systemd_units=[
            ("service" , f"{systemd_prefix}/vad.move@.service"  , vad_move_service   ) ,
            ("service" , f"{systemd_prefix}/vad.rotate.service" , vad_rotate_service ) ,
            ("service" , f"{systemd_prefix}/vad.up.service"     , vad_up_service     ) ,
            ("service" , f"{systemd_prefix}/vad.service"        , vad_service        ) ,
            ("timer"   , f"{systemd_prefix}/vad.rotate.timer"   , vad_rotate_timer   ) ,
            ("timer"   , f"{systemd_prefix}/vad.up.timer"       , vad_up_timer       ) ,
        ],
    )


def service_install_command(args):
    become_root()

    config = service_config()

    os.makedirs(config.bin_prefix, exist_ok=True)
    os.makedirs(config.rule_prefix, exist_ok=True)
    os.makedirs(config.systemd_prefix, exist_ok=True)

    log_verbose("Copy vad into %s" % config.bin_prefix)
    shutil.copyfile(os.path.abspath(os.sys.argv[0]), config.bin_path)
    os.chmod(config.bin_path, 0o755)

    log_verbose("Install udev rule %s" % config.rule_path)

    with open(config.rule_path, 'w') as f:
        f.write(config.udev_rule)

    for type, filename, content in config.systemd_units:
        log_verbose("Install %s %s" % (type, filename))
        with open(filename, 'w') as f:
            f.write(content)

    log_verbose("Verify configuration files:")

    for filename in os.listdir('/sys/class/net'):
        run_or_fail(['bash', '-c', 'udevadm test --action=add /sys/class/net/%s 2>&1 | grep "vad"' % filename])

    for type, filename, content in config.systemd_units:
        run_or_fail(['systemd-analyze', 'verify', os.path.basename(filename)])

    log_verbose("Enable:")

    for type, filename, content in config.systemd_units:
        if 'vad.rotate.service' in filename:
            continue
        if 'vad.up.service' in filename:
            continue
        if 'vad.move@.service' in filename:
            continue
        run_or_fail(['systemctl', 'enable', os.path.basename(filename)])

    log_verbose("Reload udev rules")
    run_or_fail(['udevadm', 'control', '--reload'])

    log_success("Successfully installed udev rule, services and timers!")


def service_remove_command(args):
    become_root()

    config = service_config()

    log_verbose("Disable services/timers:")
    for type, filename, content in config.systemd_units:
        run_or_fail(['systemctl', 'disable', os.path.basename(filename)])

    log_verbose("Unlink %s" % config.bin_path)
    os.unlink(config.bin_path)

    log_verbose("Remove udev rule %s" % config.rule_path)
    os.unlink(config.rule_path)

    for type, filename, content in config.systemd_units:
        log_verbose("Remove %s %s" % (type, filename))
        os.unlink(filename)

    log_verbose("Reload udev rules")
    run_or_fail(['udevadm', 'control', '--reload'])


def move_command(args):
    become_root()

    if not network_namespace_exists(NAMESPACE_PHYSICAL):
        run_or_fail(["ip", "netns", "add", NAMESPACE_PHYSICAL])
        run_or_fail(["ip", "-n", NAMESPACE_PHYSICAL, "link", "set", "lo", "up"])
        run_or_fail(["ip", "netns", "exec", NAMESPACE_PHYSICAL, "sysctl", 'net.ipv4.ping_group_range=0 2147483647'])

    for device in get_network_devices():
        if device[0] != DeviceType.Virtual and device[1] == args.INTERFACE[0]:
            device_move_to_physical(device)


def rotate_command(args, up_command_defaults):
    become_root()

    config = config_load(args.config)
    account_number = request_account_number(args.passname, config)
    config = request_login_api(args, account_number, config)

    for device in config.get('devices', []):
        private_key, peer = request_update_public_key(config, device)
        device['private_key'] = private_key
        device['ipv4'] = peer['ipv4_address']
        device['ipv6'] = peer['ipv6_address']
        device['device_id'] = peer['id']
        device['device_name'] = peer['name']
        config_save(args.config, config)

    log_success("Successfully rotated WireGuard keys of all mapped devices")

    if is_active():
        up_command(Namespace(**up_command_defaults), True)

    return config


def reset_command(args):
    become_root()

    service_remove_command(Namespace())

    config = delete_command(Namespace(config=args.config, all=True, INDEX=None, passname='web/mullvad'))

    down_command(Namespace(config=args.config, partial=False))

    if 'account_number' in config:
        del config['account_number']
    if 'auth' in config:
        del config['auth']

    config = config_save(args.config, config)

    log_success("Successfully reseted")

    return config


# NOTE: All wireguard servers have unique city codes. For all servers there is only one duplicate:
#       - Finland (fi), Helsinki (hel) and
#       - Sweden (se), Helsingborg (hel)
def check_unique_city_codes(servers):
    country_cities = set([(server['country_code'], server['city_code']) for server in servers])
    city_counter = Counter([city for country, city in country_cities])

    duplicates = set()
    for city, count in city_counter.items():
        if count > 1:
            for server in servers:
                if city == server['city_code']:
                    duplicates.add('%s (%s), %s (%s)' % (server['country_name'], server['country_code'], server['city_name'], server['city_code']))
            log_warn("Attention, the city code '%s' is not unique:" % city)
            for text in duplicates:
                print('- %s' % text)


def check_special_country_codes_not_in_use(servers):
    countries = set([server['country_code'] for server in servers])
    for server in servers:
        if 'eu' == server['country_code']:
            log_warn("Attention, the special country code 'eu' used by this script is in use by a server. This makes this server unselectable! (%s)", str(server))
        if 'ec' == server['country_code']:
            log_warn("Attention, the special country code 'ec' used by this script is in use by a server. This makes this server unselectable! (%s)", str(server))


def update_command(args):
    become_root()

    os.makedirs('/etc/vad', exist_ok=True)

    url_servers = "https://api.mullvad.net/www/relays/all"

    try:
        response = requests.get(url_servers)

        if response.ok:
            with open(SERVERS, 'w') as servers:
                servers.write(response.text)
            os.chmod(SERVERS, 0o644)
            servers = filter_servers()
            check_unique_city_codes(servers)
            check_special_country_codes_not_in_use(servers)
            log_info('%s updated with %d wireguard servers' % (SERVERS, len(servers)))
        else:
            log_warn('Can not download servers from %s, because of %s' % (url_servers, response.text))
    except Exception as e:
        log_warn('Can not download servers from %s, because of %s' % (url_servers, str(e)))


def get_network_devices():
    dir = '/sys/class/net'
    devices = []
    for dev in os.listdir(dir):
        path_dest = os.readlink(os.path.join(dir, dev))
        if 'virtual' in path_dest:
            devices.append((DeviceType.Virtual, dev, None))
        elif 'devices' in path_dest:
            path = os.path.join(dir, path_dest, "phy80211")
            if os.path.exists(path):
                devices.append((DeviceType.Wifi, dev, os.path.basename(os.readlink(path))))
            else:
                devices.append((DeviceType.Ethernet, dev, None))
    return devices


# NOTE: This is just a workaround until we find a better way.
# FIXME: This is very ugly! [get_network_devices_in_namespace]
def get_network_devices_from_namespace(namespace):
    devices = []
    process = subprocess.run(['ip', 'netns', 'exec', namespace, sys.argv[0], 'dev', '-r'], capture_output=True, check=True)
    if process.returncode == 0:
        output = str(process.stdout, 'utf8')
        return yaml.load(output, yaml.UnsafeLoader)
    else:
        return devices


# TODO: remove
def dev_command(args):
    become_root(do_lock=False)

    devices = get_network_devices()

    # FIXME: This is very ugly! [get_network_devices_in_namespace]
    if args.raw:
        yaml.dump(devices, sys.stdout)
        return

    for type, dev, phy in devices:
        if phy:
            print('%-10s %s (%s)' % (type.name, dev, phy))
        else:
            print('%-10s %s' % (type.name, dev))


class TestDependencies(unittest.TestCase):
    def test(self):
        commands = [
            "sudo",
            "kill",
            "killall",
            "timeout",
            "wg",
            "ip",
            "iw",
            "wpa_supplicant",
            "dhcpcd",
            "sysctl",
            "resolvconf",
            # pass
        ]

        for command in commands:
            process = subprocess.run(['bash', '-c', 'command -v %s' % command], capture_output=True)
            if process.returncode != 0:
                print("Command '%s' should be available!" % command)


class TestCase(unittest.TestCase):
    def save_main_module(self):
        self.main_module = dict()
        module = sys.modules[__name__]
        for key, value in module.__dict__.items():
            if not '__' in key:
                self.main_module[key] = value
        return module

    def restore_main_module(self):
        module = sys.modules[__name__]
        for key, value in self.main_module.items():
            module.__dict__[key] = value

    def inject_get_response(self, code, content):
        response = Response()
        response.status_code = code
        response._content = bytes(content, "utf8")
        requests.get = lambda x: response

    def throw_exception(self, arg):
        raise Exception("Some exception")

    def assertExit(self, func):
        with self.assertRaises(SystemExit):
            func()

    def capture(self, func):
        out = StringIO()
        with redirect_stdout(out):
            func()
        return out.getvalue()


class TestCommand(TestCase):
    def load_config(self):
        self.called[inspect.currentframe().f_code.co_name] = True
        return self.config

    def update_command(self, args):
        self.called[inspect.currentframe().f_code.co_name] = True

    def request_account_number(self, passname, config):
        self.called[inspect.currentframe().f_code.co_name] = True
        return self.request_account_number_result

    def request_login(self, login):
        self.called[inspect.currentframe().f_code.co_name] = True
        return self.request_login_result

    def request_logout(self, login):
        self.called[inspect.currentframe().f_code.co_name] = True

    def request_add_key(self, login):
        self.called[inspect.currentframe().f_code.co_name] = True
        return self.request_add_key_result

    def save_config(self, config):
        self.called[inspect.currentframe().f_code.co_name] = True
        self.config = config

    def setUp(self):
        self.called = dict()
        self.config = None
        self.request_login_result = dict(account=dict(
            active=True,
            can_add_wg_peers=True,
            expires='NEVER',
        ))
        self.request_add_key_result = (
            'PRIVATE',
            'PUBLIC',
            dict(
                ipv4_address='4',
                ipv6_address='6'
            )
        )
        self.request_account_number_result = '1234567890123456'

        module = self.save_main_module()
        module.become_root = lambda: None
        module.load_config = self.load_config
        module.save_config = self.save_config
        module.update_command = self.update_command
        module.request_account_number = self.request_account_number
        module.request_login = self.request_login
        module.request_add_key = self.request_add_key
        module.request_logout = self.request_logout

    def tearDown(self):
        self.restore_main_module()


class TestServerRandomChoice(TestCase):
    def test(self):
        import numpy as np
        servers = filter_servers()
        countries = defaultdict(int)

        N = 1000
        for _ in range(N):
            server = server_random_choice(servers, uniform_by_country=True)
            countries[server['country_code']] += 1

        result = np.array(list(countries.values()))
        expected = np.array([N/len(countries)] * len(countries.values()))

        chi = np.sum((result - expected)**2 / expected)
        chi = chi / len(countries.values())
        assert chi < 2.0


class TestGetDnsServerFromFlags(TestCase):
    def testWrongFlag(self):
        out = self.capture(partial(get_dns_server_from_flags, "x"))
        self.assertIn("Unkown", out)

    def test(self):
        cases = [
            ("10.64.0.1",   ""),
            ("100.64.0.1",  "a"),
            ("100.64.0.2",  "t"),
            ("100.64.0.3",  "at"),
            ("100.64.0.4",  "m"),
            ("100.64.0.5",  "am"),
            ("100.64.0.6",  "tm"),
            ("100.64.0.7",  "atm"),
            ("100.64.0.8",  "p"),
            ("100.64.0.9",  "pa"),
            ("100.64.0.10", "pt"),
            ("100.64.0.11", "pat"),
            ("100.64.0.12", "pm"),
            ("100.64.0.13", "pam"),
            ("100.64.0.14", "ptm"),
            ("100.64.0.15", "patm"),
            ("100.64.0.16", "g"),
            ("100.64.0.17", "ga"),
            ("100.64.0.18", "gt"),
            ("100.64.0.19", "gat"),
            ("100.64.0.20", "gm"),
            ("100.64.0.21", "gam"),
            ("100.64.0.22", "gmt"),
            ("100.64.0.23", "gamt"),
            ("100.64.0.24", "gp"),
            ("100.64.0.25", "gap"),
            ("100.64.0.26", "gpt"),
            ("100.64.0.27", "gapt"),
            ("100.64.0.28", "gpm"),
            ("100.64.0.29", "gapm"),
            ("100.64.0.30", "gpmt"),
            ("100.64.0.31", "apgmt"),
        ]

        for dns, flags in cases:
            self.assertEqual(dns, get_dns_server_from_flags(flags), "Used flags: %s" % flags)


class TestRequestLogin(TestCase):
    def call(self):
        request_login('1234567890123456')

    def tearDown(self):
        from importlib import reload
        reload(sys.modules["requests"])

    def test404(self):
        self.inject_get_response(404, 'ACCOUNT_NOT_FOUND')
        out = self.capture(partial(self.assertExit, self.call))
        self.assertTrue('ACCOUNT_NOT_FOUND', out)

    def testException(self):
        requests.get = self.throw_exception
        out = self.capture(partial(self.assertExit, self.call))
        self.assertIn('while sending', out)

    def testJson(self):
        self.inject_get_response(200, 'NOTJSON')
        out = self.capture(partial(self.assertExit, self.call))
        self.assertIn('not parse', out)

    def test(self):
        self.inject_get_response(200, '{}')
        out = self.capture(self.call)
        self.assertTrue(out == '')


class TestInitCommand(TestCommand):
    def testSaveAccountNumber(self):
        out = self.capture(partial(init_command, Namespace(
            save_account_number=True,
            passname='pasname'
        )))
        self.assertTrue(self.called['save_config'])
        self.assertEqual(self.config['account_number'], self.request_account_number_result)

    def testConfigUnchanged(self):
        self.config = dict(
            save_account_number=False,
            account_number='TEST',
        )
        out = self.capture(partial(init_command, Namespace(
            add_device=False,
            save_account_number=False,
            passname='pasname'
        )))
        self.assertTrue(self.called['save_config'])
        self.assertIn('account_number', self.config)

    def testAddDevice(self):
        self.config = dict(
            devices=[dict()]
        )
        out = self.capture(partial(init_command, Namespace(
            save_account_number=False,
            add_device=True,
            passname='pasname'
        )))
        self.assertIn('added', out)
        self.assertEqual(len(self.config['devices']), 2)

    def testAlreadyInitialized(self):
        self.config = dict(
            devices=[dict()]
        )
        out = self.capture(partial(self.assertExit, partial(init_command, Namespace(
            save_account_number=False,
            add_device=False,
            passname='pasname'
        ))))
        self.assertIn('Already', out)

    def testNotActive(self):
        self.request_login_result['account']['active'] = False
        out = self.capture(partial(self.assertExit, partial(init_command, Namespace(
            save_account_number=False,
            add_device=True,
            passname='pasname'
        ))))
        self.assertIn('NEVER', out)
        self.assertTrue(self.called['request_logout'])

    def testNoMoreDevices(self):
        self.request_login_result['account']['can_add_wg_peers'] = False
        out = self.capture(partial(self.assertExit, partial(init_command, Namespace(
            save_account_number=False,
            add_device=True,
            passname='pasname'
        ))))
        self.assertIn('full', out)
        self.assertTrue(self.called['request_logout'])

    def test(self):
        out = self.capture(partial(init_command, Namespace(
            save_account_number=False,
            add_device=True,
            passname='pasname'
        )))
        self.assertIn('First device added', out)
        self.assertTrue(self.called['update_command'])
        self.assertTrue(self.called['request_login'])
        self.assertTrue(self.called['request_logout'])
        self.assertTrue(self.called['request_add_key'])
        self.assertEqual(
            self.config,
            dict(devices=[dict(
                private_key='PRIVATE',
                ipv4='4',
                ipv6='6',
            )])
        )


def test_build_image(base_image, build, Dockerfile):
    from tempfile import TemporaryDirectory

    tag = 'vad-%s' % base_image

    if build:
        with TemporaryDirectory() as dir:
            with open('%s/Dockerfile' % dir, 'w') as f:
                f.write(Dockerfile.format(base_image=base_image))
            subprocess.run(f"docker build -t {tag} {dir}", shell=True, check=True)
    return tag


def test_command(args):
    if args.docker:
        become_root()

        images = []
        images.append(test_build_image('archlinux', not args.docker_skip_build,
            """
            FROM {base_image}
            RUN pacman -Syu --noconfirm python-requests python-dbus python-yaml python-prettytable python-numpy sudo iw wpa_supplicant dhcpcd wireguard-tools
            """
        ))

        for base_image in ['ubuntu', 'ubuntu:20.04', 'debian']:
            images.append(test_build_image(base_image, not args.docker_skip_build,
                """
                FROM {base_image}
                RUN apt update && apt install -y -q python3-dbus python3-requests python3-yaml python3-prettytable python3-numpy sudo psmisc wireguard-tools iproute2 iw wpasupplicant dhcpcd5 procps
                """
            ))


        path = sys.argv[0]
        for image in images:
            command = f"docker run --rm -v /etc/vad/servers.json:/etc/vad/servers.json -v {path}:/bin/vad {image} vad test"
            print(command)
            subprocess.run(command, shell=True, check=True)
    else:
        unittest.main(argv=sys.argv[1:])


def get_default_arguments(parser, subparser):
    defaults_parser = vars(parser.parse_args([]))
    defaults_subparser = vars(subparser.parse_args([]))
    defaults = {**defaults_parser, **defaults_subparser}
    return defaults


def is_default_arguments(parser, subparser, args):
    defaults_parser = vars(parser.parse_args([]))
    defaults = get_default_arguments(parser, subparser)
    args_to_compare = {**vars(args), **defaults_parser}
    args_to_compare['func'] = None
    args_to_compare['dont_save'] = False
    args_to_compare['dry_run'] = False
    defaults['func'] = None
    return defaults == args_to_compare


def vad():
    parser = argparse.ArgumentParser(
        prog="vad",
        description="An alternative command line interface (CLI) for Mullvad that is based on network namespaces and supports up to ten hops.",
    )

    parser.add_argument('-p', '--print-args', action='store_true', help='Output parsed args.')
    parser.add_argument('-v', '--verbose', action='store_true', help='Output verbose information.')
    parser.add_argument('-n', '--no-color', action='store_true', help='Never color output')
    parser.add_argument('-c', '--config', help='Use this configuration file', default=CONFIGURATION)
    parser.set_defaults(func=show_command)

    subparsers = parser.add_subparsers()
    subparser_args = dict(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    init = subparsers.add_parser('init', help='Initalize Mullvad VPN. Adds devices to this computer. Without arguments, adds a new device to your account to this computer (will ask for your account number)', **subparser_args)
    init.add_argument('-p', '--passname', nargs=1, dest='passname', help='Request account number from pass.', default='web/mullvad')
    init.add_argument('-a', '--add-device', action='store_true', help='Creates an additonal device for your account to built tunnels over more hops. Every new devices enables one hop. In a multihop configuration (https://mullvad.net/de/help/multihop-wireguard) every devices enables two hops. Normally 5 devices are possible per account, this allows a maximum of ten hops.')
    init.add_argument('-d', '--dont-save-account-number', action='store_true', help='Does not save the account number into the configuration file. Useful if you have the account number in `pass`.')
    init.set_defaults(func=init_command)

    delete = subparsers.add_parser('delete', help='Delete mapped device(s) from this computer and your account.', **subparser_args)
    delete.add_argument('--all', action='store_true', help='Delete all mapped devices.')
    delete.add_argument('-p', '--passname', nargs=1, dest='passname', help='Request account number from pass.', default='web/mullvad')
    delete.add_argument('INDEX', nargs='?', metavar='INDEX', choices=['0','1','2','3','4','5','6','7','8','9'], help='Delete specified mapped device from this computer and your account (find index with `vad info`). BEWARE index of other devices change after one delete.')
    delete.set_defaults(func=delete_command)

    info = subparsers.add_parser('info', help='View account information and highlight devices added to this computer.', **subparser_args)
    info.add_argument('-p', '--passname', nargs=1, dest='passname', help='Request account number from pass.', default='web/mullvad')
    info.add_argument('-a', '--show-account-number', action='store_true', help='Shows the account number.')
    info.add_argument('-s', '--show-device-ids', action='store_true', help='Show device ids.')
    info.add_argument('-6', '--show-ipv6', action='store_true', help='Show IPv6 address column of device.')
    info.add_argument('-r', '--raw', action='store_true', help='Output raw account information.')
    info.set_defaults(func=info_command)

    update = subparsers.add_parser('update', help='Update or initialize server list.')
    update.set_defaults(func=update_command)

    up = subparsers.add_parser('up', aliases=['u'], help=f'Set up a vpn tunnel: move all physical network devices into the physical network namespace, configure one or more Mullvad server and setup a wireguard device in the root namespace. All programs from non root users are forced to use the wireguard device in the root namespace.')
    up.add_argument('COUNTRY_CITY_HOSTNAME', nargs='*', help='Select up to ten random hops by country code (e.g. de), city code (e.g. dus) or hostname (e.g. de-dus-wg-001). Filtering by hostname only works with four or more characters and must be a substring from the server\'s hostname. The sequence determines the data flow. More hops require more devices (see `vad init`). If you want to use a random hop around the earth, then use "w" as placeholder. If you only want to use hops from countries in the European Union then use "eu". If you only want to use hops from countries on the European continent then use "ec". If no hops are specified, then a one hop tunnel with a random hop from around the earth will be built. If already active, than a second call, will tear down the configuration, except the physical namespace, so no data leaks can occur, and build a new tunnel. If you execute the up command without arguments (`vad up`) it will use the options of the last call with arguments. The last call with arguments will be saved to the configuration file, after an successful up, if you do not want this, use `-s --dont-save`.')
    up.add_argument('-i', '--auto-configure-wifi', action='store_true', help='This is a workaround to automaically configure the wifi interface. It only works if you have NetworkManager, currently connected to an wifi network and `wpa_supplicant` is used. It will retrive the configuration from `wpa_supplicant` for the current network and fetch the PSK from NetworkManager (somehow `wpa_supplicant` does not give us this information?). This is at least a better for usability then configuring it manually.')
    up.add_argument('-s', '--dont-save', action='store_true', help='Do not save the last call with arguments to the configuration file.')
    up.add_argument('-a', '--update-server-list', action='store_true', help='Update server list.')
    up.add_argument('-n', '--dry-run', action='store_true', help='Show only chosen hop(s) and nameserver.')
    up.add_argument('-d', '--dns', nargs=1, help='Set a blocking dns server by flags (atmpg) or with no flags use the nonblocking dns server (10.64.0.1): a = Block adverdisments, t = Block tracking, m = Block malicious sites, p = Block adult content, g = Block gampling sites.', default='')
    up.add_argument('-w', '--without-multihop', action='store_true', help='Normally pairs of hops are taken and configured as multihop beginning from the last hop. Every hop pair requires one device, with this option every hop requires one device.')
    up.add_argument('-u', '--uniform-by-country', action='store_true', help='Randomly select a country and then randomly select a hop.')
    up.add_argument('-o', '--owned-entry', action='store_true', help='Use a owned server by Mullvad for your entry hop.')
    up.add_argument('-b', '--diskless-entry', action='store_true', help='Use a diskless server for your entry hop (stboot [BETA]).')
    up.add_argument('-6', '--only-use-ipv6', action='store_true', help='Only use IPv6 addresses.')
    up.set_defaults(func=up_command)

    down = subparsers.add_parser('down', aliases=['d'], help='Tear down the vpn configuration and restore the previous state.')
    down.add_argument('-p', '--partial', action='store_true', help=f'Do not delete the physical namespace. Your physical network interfaces will remain in this namespace, which leaves you with no network access at all. Useful if you manually configured your physical network namespace.', default=False)
    down.set_defaults(func=down_command)

    exec = subparsers.add_parser('exec', aliases=['e'], help='Execute command in the physical namespace. The command can use the physical network interfaces directly.')
    exec.add_argument('CMD', nargs=argparse.REMAINDER, help=f'Command to execute in the physical namespace with or without arguments.')
    exec.set_defaults(func=exec_command)

    show = subparsers.add_parser('show', aliases=['s'], help='Show vpn status information, return 0 if active otherwise 1.', **subparser_args)
    show.set_defaults(func=show_command)

    # TODO: remove
    dev = subparsers.add_parser('dev', help='List all network devices in the current namespace.')
    dev.add_argument('-r', '--raw', action='store_true', help='Output device information as yaml.')
    dev.set_defaults(func=dev_command)

    list = subparsers.add_parser('list', aliases=['l'], help='List, filter and group servers.', **subparser_args)
    list.add_argument('COUNTRY_CITY_HOSTNAME', nargs='?', help='Select server by country code (e.g. de), city code (e.g. dus) or hostname if it contains this substring (e.g. de-dus-wg-001). Filtering by hostname only works with four or more characters.')
    list.add_argument('--all', action='store_true', help='List also non wireguard servers and add "Type" column to table.')
    list.add_argument('-c', '--group-by-country', action='store_true', help='Group and count by country.')
    list.add_argument('-y', '--group-by-country-city', action='store_true', help='Group and count by country and city.')
    list.add_argument('-d', '--group-by-provider', action='store_true', help='Group and count by provider.')
    list.add_argument('-4', '--show-column-ipv4', action='store_true', help='Shows ipv4 column (ignored by --group-by-*).')
    list.add_argument('-6', '--show-column-ipv6', action='store_true', help='Shows ipv6 column (ignored by --group-by-*).')
    list.add_argument('-p', '--show-column-public-key', action='store_true', help='Show public key column (ignored by --group-by-*).')
    list.add_argument('-s', '--show-column-socks-proxy', action='store_true', help='Show socks proxy column (ignored by --group-by-*).')
    list.add_argument('-m', '--show-column-status-messages', action='store_true', help='Show status messages column (ignored by --group-by-*).')
    list.add_argument('-o', '--owned', dest='owned', action='store_true', help='Filter by owned servers.', default=None)
    list.add_argument('-r', '--rented', dest='owned', action='store_false', help='Filter by rented servers.', default=None)
    list.add_argument('-a', '--active', dest='active', action='store_true', help='Filter by active servers.', default=None)
    list.add_argument('-i', '--inactive', dest='active', action='store_false', help='Filter by inactive servers.', default=None)
    list.add_argument('-b', '--diskless', action='store_true', help='Filter by diskless boot servers (stboot [BETA]).', default=None)
    list.set_defaults(func=list_command)

    service = subparsers.add_parser('service', help='Install and remove services and timers.')
    service_subparser = service.add_subparsers()
    service_install = service_subparser.add_parser('install', aliases=['i'], help='Installs a service which automatically starts the VPN on system startup and tears it down on system shutdown. A udev rule move new network devices into physical namespace and automatically creates it if it does not exists. A timer will rotate WireGuard keys every 4 days (same as the Mullvad app).')
    service_install.set_defaults(func=service_install_command)
    service_remove = service_subparser.add_parser('remove', aliases=['rm'], help='Removes all installed services.')
    service_remove.set_defaults(func=service_remove_command)
    service.set_defaults(func=lambda args: service.print_help())

    move = subparsers.add_parser('move', aliases=['mv'], help='Move device into physical namespace and if it does not exist create it.')
    move.add_argument('INTERFACE', nargs=1, help='Interface name that will be moved.')
    move.set_defaults(func=move_command)

    rotate = subparsers.add_parser('rotate', help='Rotate WireGuard keys from all mapped devices.')
    rotate.add_argument('-p', '--passname', nargs=1, dest='passname', help='Request account number from pass.', default='web/mullvad')
    rotate.set_defaults(func=rotate_command)

    reset = subparsers.add_parser('reset', help='Tear down vpn, delete all mapped devices to this computer, remove services added through `vpn service` and remove account related information from configuration.')
    reset.set_defaults(func=reset_command)

    test = subparsers.add_parser('test', help='Run unittests.')
    test.add_argument('-d', '--docker', action='store_true', help='Run the tests in different docker images (archlinux, ubuntu, debian).')
    test.add_argument('-s', '--docker-skip-build', action='store_true', help='Skip docker build.')
    test.add_argument('UNITTEST_CMD', nargs=argparse.REMAINDER, help='Command(s) for unittest.')
    test.set_defaults(func=test_command)

    args = parser.parse_args()

    global VERBOSE
    VERBOSE = args.verbose

    global colored
    if args.no_color:
        colored = nop_colored

    if args.print_args:
        if os.geteuid() == 0:
            print(args)

    try:
        if not 'func' in args:
            parser.print_help()
        elif args.func == info_command:
            args.func(args, up)
        elif args.func == up_command:
            args.func(args, is_default=is_default_arguments(parser, up, args))
        elif args.func == rotate_command:
            args.func(args, get_default_arguments(parser, up))
        else:
            args.func(args)
    except KeyboardInterrupt:
        sys.exit(1)
    except CommandFailed as e:
        # TODO: Should this only apply to the first `vad up`, and not to the following?
        log_warn("A command failed during `vad up`, to leave the network in a working state we will undo all changes with `vad down`.")
        if args.func == up_command:
            down_command(Namespace(config=args.config, partial=False))
        sys.exit(e.returncode)
    except Abort:
        sys.exit(1)

if __name__ == "__main__":
    vad()
