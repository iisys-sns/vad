#!/usr/bin/env python3

import argparse
import atexit
import base64
import ctypes
import ctypes.util
import dataclasses
import fcntl
import glob
import ipaddress
import json
import math
import os
import random
import requests
import shutil
import socket
import struct
import subprocess
import sys
import threading
import unittest
import yaml
import time
import copy

from datetime import datetime
from termcolor import colored
from argparse import Namespace as Args
from argparse import ArgumentParser
from collections import defaultdict
from collections import Counter
from collections import deque
from datetime import datetime
from enum import Enum
from prettytable import PrettyTable, ALL, FRAME
from tempfile import NamedTemporaryFile

from io import StringIO
from contextlib import redirect_stdout
from functools import partial
from dataclasses import dataclass
from dataclasses import is_dataclass
from dataclasses import field
from types import UnionType, NoneType
from typing import Tuple, TypeVar, Type, Set, Dict, Any, List, Optional, Union, NoReturn, Deque, Iterable, get_type_hints, get_args, get_origin

from cryptography.hazmat.primitives.asymmetric.x25519 import X25519PrivateKey, X25519PublicKey
from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PublicKey

from noise.connection import NoiseConnection, Keypair


VERBOSE = False


PREFIX = '/etc'
NAME = 'vad'
RUN_DIR = '/var/run/vad'
LOCK_FILE = f'{RUN_DIR}/lock'
LOCK_FD = None
WIREGUARD_DIR = f'{PREFIX}/wireguard',
NAMESPACE_HOP = f'{NAME}-%s-%d'
DEVICE_NAME_HOP = f'{NAME}%d'
CONFIGURATION = f'{PREFIX}/{NAME}/config.yaml'
STATE = f'{RUN_DIR}/state'
PROVIDER_DIR = f'{PREFIX}/{NAME}'
NAMESPACE_ROOT = '1'
NAMESPACE_PHYSICAL = 'physical'
EUROPE_UNION = ["at", "be", "bg", "hr", "cy", "cz", "dk", "ee", "fi", "fr", "de", "gr", "hu", "ie", "it", "lv", "lt", "lu", "mt", "nl", "pl", "pt", "ro", "sk", "si", "es", "se"]
EUROPE_CONTINENT = EUROPE_UNION + ["is", "no", "li", "ch", "uk", "gb", "me", "mk", "al", "rs", "tr", "ba", "xk", "am", "az", "by", " md", "ge", "ua"]
SUPPORTED_PROVIDERS = ['mullvad']


ACTION_LISTEN = 0
ACTION_STOP_LISTEN = 1
ACTION_CONNECT = 2
ACTION_TEST = 3

RESPONSE_ACK = 10
RESPONSE_NCK = 11
RESPONSE_CLIENT_CONNECT = 12
RESPONSE_STOP_LISTING = 13


class PrettyTablePretty(PrettyTable):
    def __init__(self, field_names=None, **kwargs) -> None:
        super().__init__(field_names, **kwargs)
        # source: https://github.com/ITGlobal/CLI/blob/master/src/CLI.Table/Impl/PrettyGridTableStyleImpl.cs
        self.vertical_char = '│'
        self.horizontal_char = '─'
        self.top_left_junction_char = '┌'
        self.top_right_junction_char = '┐'
        self.bottom_left_junction_char = '└'
        self.bottom_right_junction_char = '┘'
        self.right_junction_char = '┤'
        self.left_junction_char = '├'
        self.bottom_junction_char = '┴'
        self.top_junction_char = '┬'
        self.junction_char = '┼'


class DeviceKind(Enum):
    Ethernet = 1
    Wifi = 2
    Virtual = 3


@dataclass
class Device:
    kind: DeviceKind
    name: str
    phy: str


@dataclass
class OnionVpnUrl:
    ipv4: str
    port_ip: int
    public_key: bytes

    def to_url(self) -> str:
        ipv4_bytes = ipaddress.IPv4Address(self.ipv4).packed
        port_ip_bytes = struct.pack('!H', int(self.port_ip))
        url = bytes([0, 0]) + ipv4_bytes + port_ip_bytes + self.public_key
        return base64.b32encode(url).decode('utf8').lower() + '.onion.vpn'

    def ed25519_public_key(self) -> Ed25519PublicKey:
        return Ed25519PublicKey.from_public_bytes(self.public_key)

    def __repr__(self) -> str:
        return self.to_url()

    @staticmethod
    def from_url(url: str) -> 'OnionVpnUrl':
        suffix = url[-10:]
        assert suffix == '.onion.vpn'
        url = url[:-10]
        url_decoded = base64.b32decode(url.upper())
        url_decoded = url_decoded[2:]
        ipv4 = str(ipaddress.IPv4Address(url_decoded[0:4]))
        port_ip = struct.unpack('!H', url_decoded[4:6])[0]
        public_key = url_decoded[6:]
        assert len(public_key) == 32
        return OnionVpnUrl(ipv4, port_ip, public_key)


MS_RDONLY = 1
MS_REC = 16384
MS_SLAVE = 1 << 19
MNT_DETACH = 2
CLONE_NEWNET = 0x40000000
CLONE_NEWNS = 0x00020000

LIBC = ctypes.CDLL(ctypes.util.find_library('c'), use_errno=True)
LIBC.setns.argtypes = (ctypes.c_int, ctypes.c_int)
LIBC.unshare.argtypes = (ctypes.c_int,)
LIBC.mount.argtypes = (ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_ulong, ctypes.c_char_p)
LIBC.umount2.argtypes = (ctypes.c_char_p, ctypes.c_int)

def setns(fd: int, nstype: int):
    return LIBC.setns(fd, nstype)

def unshare(flags: int):
    return LIBC.unshare(flags)

def mount(source: str, target: str, fstype: str, flags: int, data: str):
    return LIBC.mount(source.encode(), target.encode(), fstype.encode(), flags, data.encode())

def umount2(target: str, flags: int):
    return LIBC.umount2(target.encode(), flags)

class NetworkNamespace:
    """
    This class follows how `ip netns exec ...` switches to network namespaces.
    <https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/tree/lib/namespace.c?h=v6.7.0#n45>
    """
    def __init__(self, namespace_name: str):
        self.namespace_name = namespace_name
        self.current_net_ns = -1
        self.target_net_ns = -1

    def __enter__(self):
        if self.namespace_name == NAMESPACE_ROOT:
            return

        log_verbose("Enter network namespace %s" % self.namespace_name)

        try:
            self.current_mnt_ns = os.open('/proc/self/ns/mnt', os.O_RDONLY|os.O_CLOEXEC)
            self.current_net_ns = os.open('/proc/self/ns/net', os.O_RDONLY|os.O_CLOEXEC)
            self.target_net_ns = os.open(f'/var/run/netns/{self.namespace_name}', os.O_RDONLY|os.O_CLOEXEC)
        except OSError as e:
            log_fatal("Failed to change netns to '%s' (%s)" % (self.namespace_name, str(e)))

        if setns(self.target_net_ns, CLONE_NEWNET) < 0:
            errmsg = os.strerror(ctypes.get_errno())
            log_fatal("Failed to change netns to '%s' (%s)" % (self.namespace_name, errmsg))

        os.close(self.target_net_ns)

        if unshare(CLONE_NEWNS) < 0:
            errmsg = os.strerror(ctypes.get_errno())
            log_fatal("Unshare mount namespace failed: %s" % (errmsg))

        if mount("none", "/", "none", MS_SLAVE | MS_REC, "") < 0:
            errmsg = os.strerror(ctypes.get_errno())
            log_fatal("mount namespace failed: '%s' (%s)" % (self.namespace_name, errmsg))

        mountflags = 0
        if umount2("/sys", MNT_DETACH) < 0:
            info = os.statvfs("/sys")
            if info.f_flag & os.ST_RDONLY:
                mountflags = MS_RDONLY

        if mount("none", "/sys", "sysfs", mountflags, "") < 0:
            errmsg = os.strerror(ctypes.get_errno())
            log_fatal("mount of /sys failed: %s" % (errmsg))

    def __exit__(self, *_):
        if self.namespace_name == NAMESPACE_ROOT:
            return

        if umount2("/sys", 0) < 0:
            errmsg = os.strerror(ctypes.get_errno())
            log_fatal("Failed to unmount sysfs: %s" % (errmsg))
        if setns(self.current_mnt_ns, 0) < 0:
            errmsg = os.strerror(ctypes.get_errno())
            log_fatal("Failed to change netns back: %s" % (errmsg))
        if setns(self.current_net_ns, 0) < 0:
            errmsg = os.strerror(ctypes.get_errno())
            log_fatal("Failed to change netns back: %s" % (errmsg))
        os.close(self.current_mnt_ns)
        os.close(self.current_net_ns)

        log_verbose("Leave network namespace %s" % self.namespace_name)


class Abort(Exception):
    pass


class CommandFailed(Abort):
    def __init__(self, returncode):
        self.returncode = returncode


class UDPSocket:
    def __init__(self, sock: socket.socket, address: Tuple[str, int]):
        self.sock = sock
        self.address = address

    def settimeout(self, timeout):
        self.sock.settimeout(timeout)

    def send(self, data: bytes):
        self.sock.sendto(data, self.address)

    def recv(self, count: int):
        data, address = self.sock.recvfrom(count)
        assert self.address == address
        return data


class NoiseUDPSocket:
    def __init__(self, noise: NoiseConnection, udp: UDPSocket, public_key: bytes):
        self.noise = noise
        self.udp = udp
        self.address = udp.address
        self.public_key = public_key

    def settimeout(self, timeout: Optional[int]):
        self.udp.settimeout(timeout)

    def send(self, data: bytes):
        message = self.noise.encrypt(data)
        self.udp.send(message)

    def recv(self, count: int):
        message = self.udp.recv(count)
        data = self.noise.decrypt(message)
        return data


class InterceptRemoteStaticPublicKey:
    def __init__(self, noise: NoiseConnection):
        self.noise:NoiseConnection = noise
        if self.noise.noise_protocol is not None:
            self.func = self.noise.noise_protocol.handshake_done
        self.public_key = b''

    def __enter__(self) -> 'InterceptRemoteStaticPublicKey':
        def handshake_done():
            if self.noise.noise_protocol is not None:
                self.public_key = self.noise.noise_protocol.handshake_state.rs.public_bytes
            self.func()
        if self.noise.noise_protocol is not None:
            self.noise.noise_protocol.handshake_done = handshake_done
        return self

    def __exit__(self, *_):
        if self.noise.noise_protocol is not None:
            self.noise.noise_protocol.handshake_done = self.func


def initiator_do_handshake(name, udp: UDPSocket, conn: NoiseConnection) -> NoiseUDPSocket:
    print(f'{name}: Handshake')
    conn.set_as_initiator()
    conn.start_handshake()

    with InterceptRemoteStaticPublicKey(conn) as intercept:
        print(f'{name}: Handshake send to %s:%d' % udp.address)
        message = conn.write_message()
        udp.send(message)
        print(f'{name}: Handshake receive...')
        received = udp.recv(2048)
        print(f'{name}: Handshake received from %s:%d' % udp.address)
        _ = conn.read_message(received)
        assert conn.handshake_finished
        print(f'{name}: Handshake done')
        return NoiseUDPSocket(conn, udp, intercept.public_key)


def responder_do_handshake(name, udp: UDPSocket, conn: NoiseConnection) -> NoiseUDPSocket:
    udp.settimeout(5)
    print(f'{name}: Handshake')
    conn.set_as_responder()
    conn.start_handshake()

    with InterceptRemoteStaticPublicKey(conn) as intercept:
        print(f'{name}: Handshake receive from %s:%d' % udp.address)
        data = udp.recv(2048)
        conn.read_message(data)
        print(f'{name}: Handshake send to %s:%d' % udp.address)
        ciphertext = conn.write_message()
        udp.send(ciphertext)
        assert conn.handshake_finished
        print(f'{name}: Handshake done')
        return NoiseUDPSocket(conn, udp, intercept.public_key)


class ProxyPeer:
    def __init__(self, udp: UDPSocket|NoiseUDPSocket):
        self.udp = udp
        self.public_key = b''
        self.handler = lambda: None

    def handle(self):
        self.handler()


class Proxy:
    def __init__(self, key: X25519PrivateKey, port: int):
        self.key = key
        self.port = port
        self.peers: Dict[Tuple[str, int], ProxyPeer] = {}
        self.listener: Dict[bytes, Tuple[str, int]] = {}
        self.listener_peers: Deque[ProxyPeer] = deque([], 10000)

    def start(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

        try:
            sock.settimeout(10)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind(('0.0.0.0' , self.port))
            while True:
                try:
                    print('Proxy: Waiting for messages...')
                    _, address = sock.recvfrom(0, socket.MSG_PEEK)
                    if address not in self.peers:
                        print('Proxy: New peer')
                        peer = ProxyPeer(UDPSocket(sock, address))
                        self.peers[address] = peer
                        self.peers[address].handler = partial(self.state_handshake, peer)
                    self.peers[address].handler()
                except TimeoutError:
                    continue
        finally:
            sock.close()

    def state_handshake(self, peer: ProxyPeer):
        noise = NoiseConnection.from_name(b'Noise_IK_25519_ChaChaPoly_BLAKE2s')
        noise.set_keypair_from_private_bytes(Keypair.STATIC, self.key.private_bytes_raw())
        assert isinstance(peer.udp, UDPSocket)
        peer.udp = responder_do_handshake('Proxy', peer.udp, noise)
        peer.public_key = peer.udp.public_key
        peer.handler = partial(self.state_normal, peer)

    def state_normal(self, peer: ProxyPeer):
        data = peer.udp.recv(2048)
        assert len(data) >= 1

        action = data[0]
        key = data[1:]
        unkown = False

        print('Proxy: Received action from %s:%d:' % peer.udp.address, action, len(data))
        if len(key) == 0:
            if action == ACTION_TEST:
                print('Proxy: Send reflexive address %s:%d' % peer.udp.address)
                peer.udp.send(bytes([RESPONSE_ACK]) + ipv4_pack(*peer.udp.address))
            elif action == ACTION_LISTEN:
                assert peer.public_key is not None
                if not peer.public_key in self.listener:
                    print('Proxy: Add listener for %s:%d' % peer.udp.address, to_base64(peer.public_key))
                    if self.listener_peers.maxlen == len(self.listener_peers):
                        removed_peer = self.listener_peers.popleft()
                        removed_peer.udp.send(bytes([RESPONSE_STOP_LISTING]))
                    self.listener_peers.append(peer)
                else:
                    print('Proxy: Update listener for %s:%d' % peer.udp.address)
                    old_peer_address = self.listener[peer.public_key]
                    if old_peer_address != peer.udp.address:
                        print('Proxy: Remove old listener')
                        del self.peers[old_peer_address]
                self.listener[peer.public_key] = peer.udp.address
                peer.udp.send(bytes([RESPONSE_ACK]))
            elif action == ACTION_STOP_LISTEN:
                self.listener_peers.remove(peer)
                del self.listener[peer.public_key]
                peer.udp.send(bytes([RESPONSE_ACK]))
            else:
                unkown = True
        elif len(key) == 32:
            if action == ACTION_CONNECT:
                print('Proxy: Connect %s:%d' % peer.udp.address, to_base64(key))
                if key in self.listener:
                    other_peer = self.peers[self.listener[key]]
                    assert peer.public_key is not None
                    other_peer.udp.send(bytes([RESPONSE_CLIENT_CONNECT]) + ipv4_pack(*peer.udp.address) + peer.public_key)
                    peer.udp.send(bytes([RESPONSE_ACK]) + ipv4_pack(*self.listener[key]))
                else:
                    peer.udp.send(bytes([RESPONSE_NCK]))
            else:
                unkown = True
        else:
            unkown = True

        if unkown:
            print('Proxy: Received an unkown message that will be ignored')


class ParseError(Exception):
    pass


@dataclass
class Base:
    def to_dict(self) -> Dict[str, Any]:
        def serialize(object):
            if isinstance(object, datetime):
                return object.strftime("%Y-%m-%dT%H:%M:%S+00:00")
            else:
                return object
        data = dataclasses.asdict(self)
        for key, value in data.items():
            data[key] = serialize(value)
        return data


T = TypeVar("T")


def pretty_type(base: type) -> str:
    if base is str:
        return 'str'
    elif base is int:
        return 'int'
    elif base is datetime:
        return 'datetime'
    elif base is dict:
        return 'Dict'
    elif base is NoneType:
        return 'None'
    elif get_origin(base) is list:
        args = get_args(base)
        return 'List[' + pretty_type(args[0]) + ']'
    elif get_origin(base) is UnionType or get_origin(base) is Union:
        return '|'.join([pretty_type(t) for t in get_args(base)])
    elif is_dataclass(base):
        pretty = str(base).replace('__main__.', '')
        pretty = pretty.replace("<class '", '')
        pretty = pretty.replace("'>", '')
        return pretty
    else:
        return str(base)


def parse_and_check_type(context: str, base: type, data: Any) -> Any:
    data_type = type(data)
    if base is data_type:
        return data
    elif base is datetime and data_type is str:
        try:
            return datetime.strptime(data, "%Y-%m-%dT%H:%M:%S+00:00")
        except Exception as e:
            raise ParseError("Could not parse datetime field '%s' with '%s'!" % (context, data)) from e
    elif get_origin(base) is list and data_type is list:
        args = get_args(base)
        assert len(args) == 1
        for idx, value in enumerate(data):
            data[idx] = parse_and_check_type(context + '/%d' % idx, args[0], value)
        return data
    elif get_origin(base) is dict and data_type is dict:
        args = get_args(base)
        key_type, value_type = args
        data_new = dict()
        for key, value in data.items():
            key = parse_and_check_type(context + '/%s' % key, key_type, key)
            data_new[key] = parse_and_check_type(context + '/%s' % key, value_type, value)
        return data_new
    elif get_origin(base) is UnionType or get_origin(base) is Union:
        errors = []
        for t in get_args(base):
            try:
                return parse_and_check_type(context, t, data)
            except ParseError as e:
                errors.append(str(e))
                continue
        raise ParseError("Possible causes:\n- %s" % ('\n- '.join(errors)))
    elif is_dataclass(base) and data_type is dict:
        for field_name, field_type in get_type_hints(base).items():
            if field_name not in data:
                raise ParseError("Field '%s' is missing!" % (context + "/%s" % field_name))
            else:
                data[field_name] = parse_and_check_type(context + "/%s" % field_name, field_type, data[field_name])
        return base(**data)

    raise ParseError("Type missmatch for field '%s', should be %s but is %s!" % (context, pretty_type(base), pretty_type(data_type)))


def from_dict(base: Type[T], data: Optional[Dict[str, str]]) -> T:
    return parse_and_check_type('', base, data)


@dataclass
class Peer(Base):
    dns: Optional[str]
    ipv4: str
    ipv6: str
    private_key: str
    provider: str


@dataclass
class Config(Base):
    pre_up: List[str] = field(default_factory=list)
    post_up: List[str] = field(default_factory=list)
    pre_down: List[str] = field(default_factory=list)
    post_down: List[str] = field(default_factory=list)

    @staticmethod
    def load(filename: str = CONFIGURATION) -> 'Config':
        if not os.path.exists(filename):
            return Config()

        st = os.stat(filename)
        if st.st_uid == 0 and (st.st_mode & 0o777) == 0o600:
            log_fatal("%s has %s access rights but should have %s" % (filename, oct(st.st_mode), oct(0o600)))

        with open(filename) as c:
            return from_dict(Config, yaml.safe_load(c))

    def save(self, filename: str = CONFIGURATION):
        with open(filename, 'w') as c:
            yaml.dump(self.to_dict(), c)


@dataclass
class Relay(Base):
    hostname: str = ''
    country_code: str = ''
    country_name: str = ''
    city_code: str = ''
    city_name: str = ''
    active: bool = False
    owned: bool = False
    asn: str = ''
    ipv4: str = ''
    ipv6: str = ''
    gigabit_per_second: int = 0
    public_key: str =  ''
    multihop_port: int = 0
    provider: str = ''

EmptyRelay = Relay()

@dataclass
class Hop(Base):
    peer: Peer
    relay: Relay

    def public_key(self):
        return self.relay.public_key

    def ipv4(self):
        return self.relay.ipv4

    def ipv6(self):
        return self.relay.ipv6

    def port(self):
        return 51820

    def provider(self):
        return self.relay.provider


@dataclass
class MultiHop(Base):
    peer: Peer
    entry: Relay
    exit: Relay

    def public_key(self):
        return self.exit.public_key

    def ipv4(self):
        return self.entry.ipv4

    def ipv6(self):
        return self.entry.ipv6

    def port(self):
        assert self.entry.provider == 'mullvad'
        return self.exit.multihop_port

    def provider(self):
        return self.entry.provider


@dataclass
class MullvadToken(Base):
    access_token: str
    expiry: datetime


@dataclass
class StateMullvad(Base):
    account_number: Optional[str] = None
    access_token: Optional[MullvadToken] = None


@dataclass
class StateProvider(Base):
    mullvad: StateMullvad = field(default_factory=StateMullvad)


class Active(Enum):
    Yes = 1
    Partial = 2
    No = 3


@dataclass
class Circuit(Base):
    namespace_source: str
    namespace_target: str
    hops: List[Hop|MultiHop] = field(default_factory=list)
    pre_up: List[str] = field(default_factory=list)
    post_up: List[str] = field(default_factory=list)
    pre_down: List[str] = field(default_factory=list)
    post_down: List[str] = field(default_factory=list)
    up_command: List[str] = field(default_factory=list)

    def is_active(self) -> bool:
        # TODO: `self.hops` could be stale, therefore we should check if it matches reality.
        #       E.g. check if `vad0` exists in the target namespace and if source and target namespaces actually exists.
        #       If not it is not active and we must assign an empty list.
        #       If parts of it exists, that is an error and would require an (partial) down.
        #       But we should do that in another function.
        # TODO: Replace result with enum `Active`.
        return len(self.hops) > 0


@dataclass
class State(Base):
    version: int = 1
    circuits: Dict[str, Circuit] = field(default_factory=dict)
    peers: List[Peer] = field(default_factory=list)
    provider: StateProvider = field(default_factory=StateProvider)

    @staticmethod
    def load(filename: str = STATE) -> 'State':
        if not os.path.exists(filename):
            return State()

        st = os.stat(filename)
        if st.st_uid != 0 or (st.st_mode & 0o777) != 0o600:
            print(oct(st.st_mode & 0o777))
            log_fatal("%s has %s access rights but should have %s" % (filename, oct(st.st_mode), oct(0o600)))

        with open(filename) as s:
            data = yaml.safe_load(s)
            return from_dict(State, data)

    def save(self, filename: str = STATE):
        with open(filename, 'w') as s:
            yaml.dump(self.to_dict(), s)

    def get_circuit(self, namespace_source: str, namespace_target: str):
        key = '%s-%s' % (namespace_target, namespace_source)
        if not key in self.circuits:
            self.circuits[key] = Circuit(namespace_source=namespace_source, namespace_target=namespace_target)
        return self.circuits[key]


class MullvadError(Exception):
    pass


@dataclass
class MullvadAccount(Base):
    id: str
    expiry: datetime
    max_ports: int
    max_devices: int
    can_add_ports: bool
    can_add_devices: bool

    def is_active(self):
        return self.expiry > datetime.now()

    def can_add_peers(self):
        return self.can_add_devices

    def max_peers(self):
        return self.max_devices


@dataclass
class MullvadPeer(Base):
    id: str
    name: str
    pubkey: str
    hijack_dns: bool
    created: datetime
    ipv4_address: str
    ipv6_address: str
    ports: list


@dataclass
class MullvadRelay(Base):
    hostname: str
    country_code: str
    country_name: str
    city_code: str
    city_name: str
    fqdn: str
    active: bool
    owned: bool
    provider: str
    ipv4_addr_in: str
    ipv6_addr_in: str
    network_port_speed: int
    stboot: bool
    pubkey: str
    multihop_port: int
    socks_name: str
    socks_port: int
    daita: bool
    type: str
    status_messages: list


class Mullvad:
    def __init__(self):
        self.api_url = "https://api.mullvad.net/"
        self.session = requests.Session()

    def __enter__(self):
        return self

    def __exit__(self, *_):
        return False

    def do(self, name: str, request: requests.Request, status_codes: List[int]):
        log_verbose('Request to %s' % request.url)

        try:
            response = self.session.send(request.prepare())
        except Exception as e:
            raise MullvadError("%s failed!" % name) from e
        if response.status_code not in status_codes:
            if 'Content-Type' in response.headers and response.headers['Content-Type'] == 'application/json':
                error = response.json()
                if 'code' in error:
                    raise MullvadError("%s failed! Got status code %d but expected one of %s. With error code: %s." % (name, response.status_code, status_codes, error['code']))
            raise MullvadError("%s failed! Got status code %d but expected one of %s." % (name, response.status_code, status_codes))
        return response

    def connected(self) -> Tuple[bool, str]:
        response = self.do(
            "Mullvad: Test if connected",
            requests.Request('GET', 'https://ipv4.am.i.mullvad.net/json'),
            [200],
        )
        data = response.json()
        return data['mullvad_exit_ip'], data['ip']

    def relays(self) -> List[MullvadRelay]:
        response = self.do(
            "Mullvad: Fetch relays",
            requests.Request('GET', 'https://api.mullvad.net/www/relays/all'),
            [200],
        )
        relays = []
        for relay in response.json():
            if relay['type'] == 'wireguard':
                relays.append(from_dict(MullvadRelay, relay))
        return relays

    def authenticate(self, account_number: str, access_token: Optional[MullvadToken] = None):
        return MullvadAuth(account_number, access_token)


class MullvadAuth(Mullvad):
    def __init__(self, account_number: str, access_token: Optional[MullvadToken] = None):
        self.account_number = account_number
        self.access_token = access_token
        super().__init__()

    def __enter__(self):
        self.login()
        return self

    def __exit__(self, *_):
        self.logout()
        return False

    def do_authenticated(self, name: str, request: requests.Request, status_codes: List[int]):
        self.login()
        if self.access_token is not None:
            request.headers['Authorization'] = f'Bearer {self.access_token.access_token}'
        return self.do(name, request, status_codes)

    def login(self):
        if self.access_token is not None and self.access_token.expiry > datetime.now():
            return
        response = self.do(
            "Mullvad: Login",
            requests.Request('POST', self.api_url + "auth/v1/token", json={'account_number': self.account_number}),
            [200]
        )
        self.access_token = from_dict(MullvadToken, response.json())

    def logout(self):
        self.access_token = None
        if self.session is not None:
            self.session.close()

    def account(self) -> MullvadAccount:
        response = self.do_authenticated(
            "Mullvad: Get account information",
            requests.Request('GET', self.api_url + "accounts/v1/accounts/me"),
            [200]
        )

        return from_dict(MullvadAccount, response.json())

    def peers(self) -> List[MullvadPeer]:
        response = self.do_authenticated(
            "Mullvad: Get all wireguard peers (devices)",
            requests.Request('GET', self.api_url + "accounts/v1/devices"),
            [200]
        )

        peers = []
        for peer in response.json():
            peers.append(from_dict(MullvadPeer, peer))
        return peers

    def peer_by_public_key(self, public_key: str) -> Optional[MullvadPeer]:
        for peer in self.peers():
            if peer.pubkey == public_key:
                return peer
        return None

    def peer_create(self, public_key: str, hijack_dns: bool = True):
        response = self.do_authenticated(
            "Mullvad: Create wireguard peer",
            requests.Request('POST', self.api_url + "accounts/v1/devices", json={'pubkey': public_key, 'hijack_dns': hijack_dns}),
            [201]
        )
        return from_dict(MullvadPeer, response.json())

    def peer_remove(self, public_key: str):
        title = "Mullvad: Remove wireguard peer"

        peer = self.peer_by_public_key(public_key)

        if peer is None:
            raise MullvadError('%s failed! Could not find peer with given public key!')

        self.do_authenticated(
            title,
            requests.Request('DELETE', self.api_url + f"accounts/v1/devices/{peer.id}"),
            [204]
        )

    def peer_update_pubkey(self, public_key: str, public_key_new: str, hijack_dns: bool = True):
        title = "Mullvad: Update public key of wireguard peer"

        peer = self.peer_by_public_key(public_key)

        if peer is None:
            raise MullvadError('%s failed! Could not find peer with given public key!')

        response = self.do_authenticated(
            title,
            requests.Request('PUT', self.api_url + f"accounts/v1/devices/{peer.id}/pubkey", json={'pubkey': public_key_new, 'hijack_dns': hijack_dns}),
            [200]
        )

        return from_dict(MullvadPeer, response.json())


def punch_hole(name, udp: UDPSocket, number_of_messages=10):
    count = 0
    failure = 0
    udp.settimeout(1)
    while True:
        try:
            print(f'{name}: Punchy punchy hole to %s:%d' % udp.address[0:2], end='')
            udp.send(b'')
            data = udp.recv(0)
            if len(data) == 0:
                print(' (success)')
                count += 1
                if count == number_of_messages:
                    break
        except TimeoutError as error:
            failure += 1
            if failure > 10:
                raise error
            continue

    try:
        while True:
            data, _ = udp.sock.recvfrom(2048, socket.MSG_PEEK)
            if len(data) == 0:
                udp.recv(0)
            else:
                break
    except TimeoutError:
        pass


def get_socket_proxy_client(proxy_address, port=0):
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(5)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(('0.0.0.0', port))
    return UDPSocket(sock, proxy_address)


def get_socket_proxy_client6(proxy_address, port=0):
    sock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
    sock.settimeout(5)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(('::', port))
    return UDPSocket(sock, proxy_address)


ALREADY_LOCKED = False


def lock():
    global ALREADY_LOCKED
    global LOCK_FD
    if ALREADY_LOCKED:
        return
    os.makedirs(RUN_DIR, exist_ok=True)
    fd = open(LOCK_FILE, 'a')
    fcntl.lockf(fd, fcntl.LOCK_EX)
    fd.write('%s\n' % os.getpid())
    fd.flush()
    LOCK_FD = fd
    ALREADY_LOCKED = True
    atexit.register(unlock)


def unlock():
    if LOCK_FD is None:
        return
    fd = LOCK_FD
    sys.stdout.flush()
    fcntl.lockf(fd, fcntl.LOCK_UN)
    fd.truncate(0)
    fd.close()


def become_root(do_lock=True):
    if os.geteuid() != 0:
        os.execvp("sudo", ["sudo", "-E"] + sys.argv)

    # NOTE: Every time we become root, we usually want to perform an atomic operation.
    #       We prevent race conditions with a file lock.
    if do_lock:
        try:
            lock()
        except Exception as e:
            log_fatal("Can not acquire file lock (%s)!" % str(e))


def log_verbose(text, **kwargs):
    if VERBOSE:
        print(colored(text, 'cyan'), **kwargs)


def log_info(text, highlight=False, **kwargs):
    if highlight:
        print(colored(text, 'blue', attrs=['bold']), **kwargs)
    else:
        print(colored(text, 'blue'), **kwargs)


def log(text, **kwargs):
    print(text, **kwargs)


def log_good(text, **kwargs):
    print(colored(text, 'green'), **kwargs)


def log_success(text, **kwargs):
    print(colored(text, 'green', attrs=['bold']), **kwargs)


def log_warn(text, **kwargs):
    print(colored(text, 'yellow'), **kwargs)


def log_fatal(text, **kwargs) -> NoReturn:
    log_bad(text, **kwargs)
    raise Abort


def log_bad(text, **kwargs):
    print(colored(text, 'red'), **kwargs)


def print_command(process, print_output: bool = True):
    command = subprocess.list2cmdline(process.args)
    command = command.replace('\n','\\n')

    if process.returncode == 0:
        log_good('+ ' + command)
    else:
        log_bad('- ' + command)

    if print_output:
        if isinstance(process.stdout, bytes):
            output = process.stdout
        else:
            output = process.stdout.read()
        if len(output) > 0:
            lines = str(process.stdout, 'utf8')
            lines = lines.split('\n')
            output = '\n  '.join(lines)
            output = output.strip()
            print('  ' + output)


def to_base64(data: bytes) -> str:
    return base64.b64encode(data).decode('utf8')


def from_base64(data: str) -> bytes:
    return base64.b64decode(data)


# TODO:: Hardcoded and DNS names are not supported at the moment, you need to replace 'proxy' with you public ip address!
PROXY_ADDRESS: Tuple[str, int] = ('proxy', 50398)
PROXY_KEY = X25519PrivateKey.from_private_bytes(from_base64('KEGMxadHKE4F0dtQ/SiYYL5/EnW6xlXna1dTF+pj8n4='))
SERVICE_KEY = X25519PrivateKey.from_private_bytes(from_base64('+Gnm7XzLwm+ioOaVBca3ZS1UL2bklpaYD/688rnOV24='))



def ipv4_pack(ip: str, port: int) -> bytes:
    ip_packed = ipaddress.IPv4Address(ip).packed
    port_packed = struct.pack('!H', port)
    return ip_packed + port_packed


def ipv4_unpack(data: bytes) -> Tuple[str, int]:
    assert len(data) == 6
    ip = data[0:4]
    port = data[4:6]
    return str(ipaddress.IPv4Address(ip)), struct.unpack('!H', port)[0]


assert ipv4_unpack(ipv4_pack('127.0.0.1', 6666)) == ('127.0.0.1', 6666)


def run(args, failure_ok=False, print_output=True, as_user=False, in_namespace=NAMESPACE_ROOT, **kwargs):
    if as_user:
        uid = os.getenv('SUDO_UID', os.geteuid())
        gid = os.getenv('SUDO_GID', os.getegid())
        args = ['sudo', '-E', '-u', '#%s' % uid, '-g', '#%s' % gid, "--"] + args

    if in_namespace != NAMESPACE_ROOT:
        args = ["ip", "netns", "exec", in_namespace] + args

    if VERBOSE:
        command = subprocess.list2cmdline(args)
        command = command.replace('\n','\\n')
        if sys.stdout.isatty() and sys.stderr.isatty():
            log_info('= ' + command + '\r', end='')

    process = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, **kwargs)

    if VERBOSE:
        print_command(process, print_output=print_output, **kwargs)
    elif not failure_ok and process.returncode != 0:
        print_command(process, print_output=print_output, **kwargs)

    return process


def run_in_namespace(namespace: str, args: list[str], **kwargs):
    return run(args, in_namespace=namespace, **kwargs)


def run_or_fail(args, **kwargs):
    process = run(args, **kwargs)
    if process.returncode != 0:
        raise CommandFailed(process.returncode)
    return process


def run_in_namespace_or_fail(namespace: str, args: list[str], **kwargs):
    return run_or_fail(args, in_namespace=namespace, **kwargs)


def run_commands(title: str, commands: List[str]):
    log_verbose("Execute %s commands:" % title)
    for command in commands:
        run(['bash', '-c', command.replace('\\n', '\n')])


def device_move_to_physical(device: Device):
    log_verbose("Move device '%s' into %s namespace:" % (device.name, NAMESPACE_PHYSICAL))

    run_or_fail(["ip", "link", "set", device.name, "down"])
    run_or_fail(["resolvconf", "-f", "-d", '%s.*' % device.name])

    if device.kind == DeviceKind.Ethernet:
        run_or_fail(["ip", "link", "set", device.name, "netns", NAMESPACE_PHYSICAL])
    elif device.kind == DeviceKind.Wifi:
        run_or_fail(["iw", "phy", device.phy, "set", "netns", "name", NAMESPACE_PHYSICAL])
    else:
        assert False


def wireguard_init(namespace: str, device_name: str, namespace_link_to: str, private_key: str, listen_port=51820):
    log_verbose(f"Init wireguard device '%s' in namespace %s and move to namespace %s" % (
        device_name,
        namespace_link_to,
        namespace,
    ))

    run_in_namespace_or_fail(namespace_link_to, ["ip", "link", "add", device_name, "type", "wireguard"])
    run_in_namespace_or_fail(namespace_link_to, ["ip", "link", "set", device_name, "netns", namespace])

    with NamedTemporaryFile('w+') as key:
        key.write('%s\n' % private_key)
        key.flush()
        run_in_namespace_or_fail(namespace, ["wg", "set", device_name, "private-key", key.name, "listen-port", str(listen_port)])


def wireguard_device_setup(namespace: str, device_name: str, ipv4: Optional[str], ipv6: Optional[str], mtu: int = 1420):
    log_verbose(f"Setup wireguard device '%s' in namespace %s (ipv4=%s, ipv6=%s, mtu=%s)" % (
        device_name,
        namespace,
        ipv4,
        ipv6,
        mtu
    ))

    if ipv4 is not None:
        run_in_namespace_or_fail(namespace, ["ip", "addr", "add", ipv4, "dev", device_name])
    if ipv6 is not None:
        run_in_namespace_or_fail(namespace, ["ip", "addr", "add", ipv6, "dev", device_name])
    run_in_namespace_or_fail(namespace, ["ip", "link", "set", device_name, "up"])
    run_in_namespace_or_fail(namespace, ["ip", "link", "set", device_name, "mtu", str(mtu)])
    run_in_namespace_or_fail(namespace, ["ip", "route", "add", "default", "dev", device_name])
    # run_in_namespace_or_fail(namespace, ["ip", "route", "add", "::/0", "dev", device_name])


def wireguard_add_peer(namespace:str, device_name:str, public_key:str, endpoint:Optional[str]=None, allowed_ips:str='0.0.0.0/0,::0/0', persistent_keepalive:int=0):
    log_verbose("Add wireguard peer to %s in namespace %s" % (device_name, namespace))
    command = ['wg', 'set', device_name, 'peer', public_key]
    if endpoint is not None:
        command.extend(['endpoint', endpoint])
    command.extend(['allowed-ips', allowed_ips])
    command.extend(['persistent-keepalive', str(persistent_keepalive)])
    run_in_namespace_or_fail(namespace, command)


def update_resolvconf(dns):
    log_verbose('Update `resolvconf` with nameserver %s:' % dns)
    with subprocess.Popen(['resolvconf', '-a', '%s.vad' % DEVICE_NAME_HOP % 0], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) as process:
        if process.stdin is not None:
            process.stdin.write(bytes('nameserver %s\n' % dns, 'utf8'))
            process.stdin.close()
        if VERBOSE:
            print_command(process)
    run(['resolvconf', '-u'])


def get_dns_server_from_flags(flags):
    bits = 0
    for flag in flags:
        if flag == 'a':
            bits |= 1
        elif flag == 't':
            bits |= 1<<1
        elif flag == 'm':
            bits |= 1<<2
        elif flag == 'p':
            bits |= 1<<3
        elif flag == 'g':
            bits |= 1<<4
        else:
            log_warn('Unkown flag "%s" for DNS server, we will ignore it!' % flag)

    if bits == 0:
        return '10.64.0.1'
    else:
        return '100.64.0.%d' % bits


def load_relays(providers: Optional[Iterable[str]] = None) -> List[Relay]:
    relays = []
    for provider_filename in glob.glob(os.path.join(PROVIDER_DIR, '*.json')):
        provider = os.path.basename(provider_filename)
        provider = provider.replace('.json', '')
        if providers is not None and provider not in providers:
            continue
        with open(provider_filename, 'r') as file:
            relays.extend([from_dict(Relay, relay) for relay in json.load(file)])

    if len(relays) == 0:
        log_fatal('No `%s/*.json` files do exists, please use `vad update`, `vad up --update-relay-list` or `vad init`.' % PROVIDER_DIR)

    return relays


def filter_relays(relays: List[Relay], active: Optional[bool] = None, owned: Optional[bool] = None, country_city_hostname: Optional[str] = None) -> List[Relay]:
    if owned is not None:
        relays = list(filter(lambda relay: relay.owned == owned, relays))

    if active is not None:
        relays = list(filter(lambda relay: relay.active == active, relays))

    if country_city_hostname is not None and not country_city_hostname == 'w':
        if country_city_hostname == 'eu':
            relays = list(filter(lambda relay: relay.country_code in EUROPE_UNION, relays))
        elif country_city_hostname == 'ec':
            relays = list(filter(lambda relay: relay.country_code in EUROPE_CONTINENT, relays))
        elif len(country_city_hostname) == 2:
            relays = list(filter(lambda relay: relay.country_code == country_city_hostname, relays))
        elif len(country_city_hostname) == 3:
            relays = list(filter(lambda relay: relay.city_code == country_city_hostname, relays))
        elif len(country_city_hostname) >= 4:
            relays = list(filter(lambda relay: country_city_hostname in relay.hostname, relays))
        else:
            relays = []

    return relays


def relay_random_choice(relays: List[Relay], uniform_by_country: bool = False) -> Relay:
    if uniform_by_country:
        countries: Set[str] = set()
        for relay in relays:
            countries.add(relay.country_code)
        if len(countries) == 0:
            return EmptyRelay
        c: str = random.choice(list(countries))
        relays = filter_relays(country_city_hostname=c, relays=relays)
    if len(relays) == 0:
        return EmptyRelay
    return random.choice(relays)


def verify_account_number(account_number):
    # NOTE: https://mullvad.net/en/blog/2017/6/20/mullvads-account-numbers-get-longer-and-safer
    if len(account_number) in [12, 13, 16] or not account_number.isdigit():
        return False
    return True


def user_request_account_number(passname):
    try:
        uid = os.getenv('SUDO_UID', os.geteuid())
        gid = os.getenv('SUDO_GID', os.getegid())
        process = run(['sudo', '-E', '-u', '#%s' % uid, '-g', '#%s' % gid, 'pass', passname], failure_ok=True)
        if process.returncode == 0:
            lines = str(process.stdout, 'utf8')
            lines = lines.split('\n')
            if len(lines) >= 1:
                account_number = lines[0]
                if len(account_number) == 16:
                    return account_number
    except FileNotFoundError:
        pass

    while True:
        account_number = input("Please enter your Mullvad account number (with or w/o spaces): ")
        account_number = account_number.replace(" ", "")
        if verify_account_number(account_number):
            print("The account number must have 12, 13 or 16 digits!")
            continue
        return account_number


def get_account_number(state: State, passname: str):
    if state.provider.mullvad.account_number is None:
        return user_request_account_number(passname)
    else:
        return state.provider.mullvad.account_number


state: Optional[State] = None

def state_load(state_filename: str = STATE, auto_save: bool = False) -> State:
    global state

    if state is not None:
        return state

    try:
        new_state = State.load(state_filename)

        if auto_save:
            atexit.register(lambda: new_state.save())

        state = new_state

        return new_state
    except ParseError as e:
        log_fatal("Parsing '%s' failed: %s" % (state_filename, str(e)))


def init_command(args: Args):
    become_root()

    no_configuration_file_exists = not os.path.exists(CONFIGURATION)

    if no_configuration_file_exists:
        log_info('No configuration file found at "%s". We will create a default configuration file for you that is suitable for systems with NetworkManager under systemd.' % CONFIGURATION)
        config = Config(
            pre_up=[
                "systemctl stop NetworkManager",
                "systemctl stop wpa_supplicant",
            ],
            post_up=[
                "mkdir -p /etc/systemd/system/wpa_supplicant.service.d",
                "printf '[Service]\\nNetworkNamespacePath=/var/run/netns/physical' > /etc/systemd/system/wpa_supplicant.service.d/override.conf",
                "mkdir -p /etc/systemd/system/NetworkManager.service.d",
                "printf '[Service]\\nNetworkNamespacePath=/var/run/netns/physical' > /etc/systemd/system/NetworkManager.service.d/override.conf",
                "systemctl daemon-reload",
                "systemctl start NetworkManager",
            ],
            pre_down=[
                "systemctl stop NetworkManager",
                "systemctl stop wpa_supplicant",
            ],
            post_down=[
                "systemctl revert wpa_supplicant",
                "systemctl revert NetworkManager",
                "systemctl start NetworkManager",
            ]
        )
        config.save()

    state = state_load(auto_save=True)

    if args.provider not in SUPPORTED_PROVIDERS:
        log_fatal('Provider %s is not supported!' % args.provider)

    count = 0
    for peer in state.peers:
        if peer.provider == args.provider:
            count += 1

    if count > 0:
        if args.provider == 'mullvad':
            log_fatal('Already initialized with at least one peer. If you want to add a new peer, use `vad add`.')
        else:
            log_fatal('Already initialized with at least one peer. If you want to add a new peer, use `vad add --provider=%s`.' % args.provider)

    if count == 0:
        update_command(Args())

    if args.provider == 'mullvad':
        account_number = get_account_number(state, args.passname)

        with Mullvad().authenticate(account_number, state.provider.mullvad.access_token) as mullvad:
            state.provider.mullvad.access_token = mullvad.access_token

            add_command(Args(config=args.config, provider='mullvad', passname=args.passname, count=1))

            if args.dont_save_account_number:
                state.provider.mullvad.account_number = None
            else:
                state.provider.mullvad.account_number = account_number

            log_info('Initialized with one peer, you can now use `vad up`')


def add_command(args: Args):
    if args.count <= 0 and args.count < 100:
        log_warn('N should be greater than 1 and smaller than 100!')

    become_root()

    state = state_load(auto_save=True)

    if args.provider not in SUPPORTED_PROVIDERS:
        log_fatal('Provider %s is not supported!' % args.provider)

    if args.provider == 'mullvad':
        account_number = get_account_number(state, args.passname)

        with Mullvad().authenticate(account_number, state.provider.mullvad.access_token) as mullvad:
            state.provider.mullvad.access_token = mullvad.access_token

            account = mullvad.account()

            if not account.is_active():
                log_fatal('Your account is expired (since %s)!' % str(account.expiry))

            for _ in range(args.count):
                if not account.can_add_peers():
                    log_fatal('You can not add more peers to your account, your account is full!')

                private_key = generate_private_key()
                public_key = get_public_key(private_key)

                peer: MullvadPeer = mullvad.peer_create(public_key)

                state.peers.append(Peer(
                    dns=None,
                    private_key=private_key,
                    ipv4=peer.ipv4_address,
                    ipv6=peer.ipv6_address,
                    provider='mullvad',
                ))

                log_info('New peer added: %s' % peer.pubkey)


def delete_command(args):
    become_root()

    state = state_load(auto_save=True)

    peers = []
    public_keys = []
    if not args.all and args.INDEX_PUBLIC_KEY is None:
        log_warn('Specify an index, a public key or use `--all`')
        return
    elif args.all:
        peers.extend(state.peers)
    elif len(args.INDEX_PUBLIC_KEY) == 44:
        public_keys.append(args.INDEX_PUBLIC_KEY)
    elif len(args.INDEX_PUBLIC_KEY) == 1 and args.INDEX_PUBLIC_KEY[0].isdigit():
        index = int(args.INDEX_PUBLIC_KEY[0])
        if index < len(state.peers):
            peers.append(state.peers[index])
        else:
            log_warn('Peer with index %d does not exists!' % index)
            return
    else:
        log_warn('INDEX_PUBLIC_KEY is neither a base64 encoded 256 bit public key nor a index (0-9)!')
        return

    for peer in peers:
        if peer.provider == 'mullvad':
            account_number = get_account_number(state, args.passname)
            with Mullvad().authenticate(account_number, state.provider.mullvad.access_token) as mullvad:
                state.provider.mullvad.access_token = mullvad.access_token
                public_key = get_public_key(peer.private_key)
                mullvad.peer_remove(public_key)
                log_info("Deleted peer %s!" % (public_key))
                state.peers.remove(peer)

    provider_in_use = set([peer.provider for peer in state.peers])

    for public_key in public_keys:
        is_public_key_unknown = True
        for provider in provider_in_use:
            if provider == 'mullvad':
                account_number = get_account_number(state, args.passname)
                with Mullvad().authenticate(account_number, state.provider.mullvad.access_token) as mullvad:
                    peer = mullvad.peer_by_public_key(public_key)
                    if peer is not None:
                        mullvad.peer_remove(public_key)
                        is_public_key_unknown = False
                        break

        if is_public_key_unknown:
            log_warn('Peer with public key %s does not exists for any provider!' % public_key)
            return


def generate_private_key() -> str:
    process = run(['wg', 'genkey'], failure_ok=True, print_output=False)
    key = str(process.stdout, 'utf8').strip()
    assert len(key) == 44
    return key


def get_public_key(private_key: str) -> str:
    process = subprocess.Popen(['wg', 'pubkey'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)
    if process.stdin is not None:
        process.stdin.write(bytes('%s\n' % private_key, 'utf8'))
        process.stdin.close()
    output: bytes = b''
    if process.stdout is not None:
        output = process.stdout.read()
        process.stdout.close()
    process.terminate()
    return str(output, 'utf8').strip()


def get_this_peer(peer: Peer, mullvad: MullvadAuth) -> Optional[MullvadPeer]:
    public_key = get_public_key(peer.private_key)
    return mullvad.peer_by_public_key(public_key)


@dataclass
class InfoPeer(Base):
    id: str
    name: str
    public_key: str
    created: datetime
    ipv4: str
    ipv6: str
    provider: str


def info_command(args: Args):
    become_root()

    state = state_load(auto_save=True)

    provider_in_use = set([peer.provider for peer in state.peers])

    peers: List[InfoPeer] = []
    mapped_peers: List[InfoPeer] = []

    for provider in provider_in_use:
        account_number = get_account_number(state, args.passname)

        with Mullvad().authenticate(account_number, state.provider.mullvad.access_token) as mullvad:
            state.provider.mullvad.access_token = mullvad.access_token

            for peer_mullvad in mullvad.peers():
                peers.append(
                    InfoPeer(
                        id=peer_mullvad.id,
                        name=peer_mullvad.name,
                        public_key=peer_mullvad.pubkey,
                        created=peer_mullvad.created,
                        ipv4=peer_mullvad.ipv4_address,
                        ipv6=peer_mullvad.ipv6_address,
                        provider=provider,
                    )
                )

            for peer in state.peers:
                peer_mullvad = get_this_peer(peer, mullvad)
                if peer_mullvad is not None:
                    mapped_peers.append(
                        InfoPeer(
                            id=peer_mullvad.id,
                            name=peer_mullvad.name,
                            public_key=peer_mullvad.pubkey,
                            created=peer_mullvad.created,
                            ipv4=peer_mullvad.ipv4_address,
                            ipv6=peer_mullvad.ipv6_address,
                            provider=provider,
                        )
                    )

            account: MullvadAccount = mullvad.account()

            print()
            print(colored('Mullvad:', 'white', attrs=['bold']))
            print('--------')
            print('Account number: ', end='')
            if args.show_account_number:
                print('(%s)' % account_number)
            else:
                print('*' * 16)

            delta = account.expiry - datetime.now()
            if account.is_active():
                print('Expires:', end=' ')
                log_good(str(account.expiry), end=' ')
                print('(in %d days)' % delta.days)
            else:
                print('Expired:', end=' ')
                log_bad(str(account.expiry), end=' ')
                print('(since %d days)' % (-1*delta.days))

            print('Peers: ', end='')
            peers_text = '%s/%s' % (len(peers), account.max_peers())
            if account.can_add_peers():
                log_good(peers_text)
            else:
                log_warn(peers_text)

    fields = ['Index', 'Provider', 'Created']

    if args.show_peer_ids:
        fields.append('ID')

    fields.extend(['Name', 'IPv4'])

    if args.show_ipv6:
        fields.append('IPv6')

    fields.extend(['Public Key'])

    table = PrettyTablePretty(fields)

    table.align['Name'] = 'l'
    table.align['IPv4'] = 'r'
    table.align['IPv6'] = 'r'
    for peer in peers:
        if peer in mapped_peers:
            idx = str(mapped_peers.index(peer))
        else:
            idx = ''
        table.add_row(
            [idx, peer.provider, peer.created] +
            ([peer.id] if args.show_peer_ids else []) +
            [peer.name.title(), peer.ipv4] +
            ([peer.ipv6] if args.show_ipv6 else []) +
            [peer.public_key]
        )

    print()
    print(table)


def show_command(args: Args):
    become_root()

    state = state_load()

    root_providers = []
    for circuit in state.circuits.values():
        if circuit.is_active():
            if circuit.namespace_target == NAMESPACE_ROOT:
                root_providers.append(circuit.hops[-1].peer.provider)
            try:
                print(colored('Active circuit from namespace "%s" to "%s":' % (circuit.namespace_source, circuit.namespace_target), attrs=['bold', 'underline']))
                if circuit.namespace_target == NAMESPACE_ROOT and circuit.namespace_source == NAMESPACE_PHYSICAL:
                    print()
                    log_info('If you only call `vad up` this command will be executed: ', end='')
                    print('vad up ' + ' '.join(circuit.up_command))
                    print()
                print(create_hop_table(circuit.hops))
                print()

                if 'wireguard_interfaces' in args.__dict__ and args.wireguard_interfaces:
                    namespaces = [circuit.namespace_target]
                    for idx in range(1, len(circuit.hops)):
                        namespaces.append(NAMESPACE_HOP % (NAMESPACE_ROOT, idx))

                    for namespace in namespaces:
                        with NetworkNamespace(namespace):
                            subprocess.run(["wg"])
                            print()
            except Exception as e:
                log_warn("VPN seemed to be active but something went wrong (%s)" % str(e))

    if 'mullvad' in root_providers:
        try:
            is_mullvad_ip, public_ip = Mullvad().connected()
            if is_mullvad_ip:
                log_good('You are connected to Mullvad, your IP address is %s.' % public_ip)
            else:
                log_bad('You are not connect to Mullvad, your IP address is %s.' % public_ip)
                raise Abort()
        except:
            log_bad("Not able to determine if connected to VPN.")
            raise Abort()


def get_dns_from_args(args):
    if len(args.dns) == 0:
        return get_dns_server_from_flags('')
    else:
        return get_dns_server_from_flags(args.dns[0])


def create_network_namespace(namespace_new: str):
    log_verbose(f"Create namespace %s" % namespace_new)
    run_or_fail(["ip", "netns", "add", namespace_new])
    run_or_fail(["ip", "-n", namespace_new, "link", "set", "lo", "up"])
    # NOTE: allow "ping" command for all user groups in the physical namespace
    run_or_fail(["ip", "netns", "exec", namespace_new, "sysctl", 'net.ipv4.ping_group_range=0 2147483647'])


def path_selection(relays: List[Relay], path: List[str], owned_entry: bool, uniform_by_country: bool) -> List[Relay]:
    selected_path = [
        relay_random_choice(
            filter_relays(
                relays,
                active=True,
                owned=owned_entry if owned_entry else None,
                country_city_hostname=path[0],
            ),
            uniform_by_country=uniform_by_country
        )
    ]
    for country_city_hostname in path[1:]:
        for _ in range(10):
            chosen_relay = relay_random_choice(
                filter_relays(
                    relays,
                    active=True,
                    country_city_hostname=country_city_hostname,
                ),
                uniform_by_country=uniform_by_country
            )
            if not chosen_relay in selected_path:
                selected_path.append(chosen_relay)
                break
    return selected_path


def path_selection_default(relays: List[Relay]) -> List[Relay]:
    # (1) Select a entry relay
    #     (a) Select a trust worthy VPN provider uniform at random
    #     (b) Select a relay from this provider uniform at random
    #     (c) Exclude provider from path selection
    # (2) Select a middle relay
    #     (a) Select a VPN provider uniform at random
    #     (b) Select a relay from this provider uniform at random
    #     (c) Exclude provider from path selection
    # (3) Select a exit relay
    #     (a) Select a VPN provider uniform at random
    #     (b) Select a relay from this provider uniform at random
    #     (c) Infer and/or measure AS’s from client to entry
    #     (d) Infer and/or measure AS’s from exit to destination
    #     (e) Make sure both AS sets do not intersect, if they do, go back to the beginning

    relays_by_provider: Dict[str, List[Relay]] = defaultdict(list)
    for relay in relays:
        relays_by_provider[relay.provider].append(relay)
    providers = list(relays_by_provider.keys())

    # (1) Select a entry relay
    entry_provider = random.choice(providers)
    entry_relay = random.choice(relays_by_provider[entry_provider])
    providers.remove(entry_provider)

    # (2) Select a middle relay
    middle_provider = random.choice(providers)
    middle_relay = random.choice(relays_by_provider[middle_provider])
    providers.remove(middle_provider)

    # (3) Select a exit relay
    # WARN: For (c) and (d) we do not use full ASN path interference and use the provider attribute as a proxy.
    exit_provider = random.choice(providers)
    relays_selected = list(filter(lambda relay: relay.asn != entry_relay.asn, relays_by_provider[exit_provider]))
    exit_relay_idx = random.randint(0, len(relays_selected)-1)
    exit_relay = relays_selected[exit_relay_idx]

    return [entry_relay, middle_relay, exit_relay]


def get_peer_from_group(peers_by_provider: Dict[str, List[Peer]], provider: str) -> Peer:
    if len(peers_by_provider[provider]) == 0:
        log_fatal('Provider "%s" has no more peers!' % provider) # TODO: formulate clearer
    return peers_by_provider[provider].pop(0)


def path_configure_hops(peers: List[Peer], relays: List[Relay], without_multihop: bool) -> List[Hop | MultiHop]:
    hops: List[Hop | MultiHop] = []

    peers_by_provider = defaultdict(list)

    for peer in peers:
        peers_by_provider[peer.provider].append(peer)

    if without_multihop:
        for relay in relays:
            hops.append(Hop(
                copy.copy(get_peer_from_group(peers_by_provider, relay.provider)),
                copy.copy(relay)
            ))
    else:
        idx = 0
        while idx < len(relays) - 1:
            has_multihop_support = (
                relays[idx].multihop_port > 0 and
                relays[idx+1].multihop_port > 0 and
                relays[idx].provider == relays[idx+1].provider
            )

            if has_multihop_support:
                hops.append(MultiHop(
                    copy.copy(get_peer_from_group(peers_by_provider, relays[idx].provider)),
                    copy.copy(relays[idx]),
                    copy.copy(relays[idx+1])
                ))
                idx += 2
            else:
                hops.append(Hop(
                    get_peer_from_group(peers_by_provider, relays[idx].provider),
                    relays[idx]
                ))
                idx += 1

        if idx < len(relays):
            hops.append(Hop(
                get_peer_from_group(peers_by_provider, relays[idx].provider),
                relays[idx]
            ))

    return hops


def create_hop_table(hops: List[Hop | MultiHop]):
    has_multihop = False
    for hop in hops:
        if isinstance(hop, MultiHop):
            has_multihop = True
            break

    if has_multihop:
        hrules=ALL
    else:
        hrules=FRAME

    table = PrettyTablePretty([
        '#',
        'Country',
        'City',
        'Hostname',
        'IP',
        'Port',
        'Provider',
        'ASN',
    ], hrules=hrules)
    table.title = 'Hop configuration with nameserver %s' % hops[-1].peer.dns
    table.align['#'] = 'r'
    table.align['Country'] = 'l'
    table.align['City'] = 'l'
    table.align['Hostname'] = 'l'
    table.align['IP'] = 'r'
    table.align['Provider'] = 'l'
    table.align['ASN'] = 'l'

    idx = 0
    for hop in hops:
        if isinstance(hop, MultiHop):
            index    = '%d\n%d' % (idx, idx+1)
            country  = '%s\n%s' % (hop.entry.country_name , hop.exit.country_name)
            city     = '%s\n%s' % (hop.entry.city_name    , hop.exit.city_name)
            hostname = '%s\n%s' % (hop.entry.hostname     , hop.exit.hostname)
            asn      = '%s\n%s' % (hop.entry.asn          , hop.exit.asn)
            ip       = '%s\n%s' % (hop.entry.ipv4         , hop.exit.ipv4)
            port     = '%d'     % (hop.port())
            provider = '%s'     % (hop.provider())

            table.add_row([index, country, city, hostname, ip, port, provider, asn])
            idx += 2
        else:
            index    = '%d' % (idx)
            country  = '%s' % (hop.relay.country_name)
            city     = '%s' % (hop.relay.city_name)
            hostname = '%s' % (hop.relay.hostname)
            asn      = '%s' % (hop.relay.asn)
            ip       = '%s' % (hop.relay.ipv4)
            port     = '%d' % (hop.port())
            provider = '%s' % (hop.provider())
            table.add_row([index, country, city, hostname, ip, port, provider, asn])
            idx += 1

    return table


def physical_namespace_set_up():
    if network_namespace_exists(NAMESPACE_PHYSICAL):
        return True

    create_network_namespace(NAMESPACE_PHYSICAL)

    run(["mkdir", "-p", "/etc/netns/physical"])
    # NOTE: This instructes NetworkManager not to manage /etc/resolv.conf!
    #       As long as "rc-manager=symlink", which should be standard.
    run(["ln", "-sf", "/var/run/NetworkManager/resolv.conf", "/etc/netns/physical/resolv.conf"])

    for device in get_network_devices():
        if device.kind != DeviceKind.Virtual:
            device_move_to_physical(device)

    return False


def up_command(args: Args, parser_up: ArgumentParser):
    become_root()

    state = state_load(auto_save=True)

    circuit = state.get_circuit(namespace_source=args.namespace_source, namespace_target=args.namespace_target)

    if not os.path.exists(args.config):
        log_warn('Configuration file "%s" not found or is not readable!' % args.config)
    else:
        config = Config.load(args.config)
        circuit.pre_up = config.pre_up
        circuit.post_up = config.post_up
        circuit.pre_down = config.pre_down
        circuit.post_down = config.post_down

    is_default = is_default_arguments(parser_up, args)

    if is_default:
        for key, value in vars(parser_up.parse_args(circuit.up_command)).items():
            args.__dict__[key] = value

    if args.update_relay_list:
        update_command(Args())

    peers = state.peers
    if len(peers) == 0:
        log_fatal('No peers configured (use `vad init` to create a peer)!')

    num_hops = len(args.COUNTRY_CITY_HOSTNAME)
    if len(args.COUNTRY_CITY_HOSTNAME) == 1 and args.COUNTRY_CITY_HOSTNAME[0] == 'default':
        num_hops = 3
        args.without_multihop = True

    if not args.without_multihop:
        needed = math.ceil(num_hops / 2) - len(peers)
        if needed > 0:
            log_fatal('You do not have enough peers to build a %d hop tunnel. With multihop you need at least %d more peer(s) (use `vad init --add-peer`)' % (num_hops, needed))
    else:
        needed = num_hops - len(peers)
        if needed > 0:
            log_fatal('You do not have enough peers to build a %d hop tunnel. Without multihop you need at least %d more peer(s) (use `vad init --add-peer`)' % (num_hops, needed))

    if len(args.COUNTRY_CITY_HOSTNAME) == 0:
        args.COUNTRY_CITY_HOSTNAME = ['w']

    relays = load_relays([peer.provider for peer in state.peers])

    if len(args.COUNTRY_CITY_HOSTNAME) == 1 and args.COUNTRY_CITY_HOSTNAME[0] == 'default':
        path_relays = path_selection_default(relays)
    else:
        path_relays = path_selection(
            relays,
            args.COUNTRY_CITY_HOSTNAME,
            owned_entry=args.owned_entry,
            uniform_by_country=args.uniform_by_country,
        )
        if EmptyRelay in path_relays:
            log_fatal('Filter criteria "%s" does not return any relay!' %  args.COUNTRY_CITY_HOSTNAME[path_relays.index(EmptyRelay)])

        if len(path_relays) != len(args.COUNTRY_CITY_HOSTNAME):
            log_fatal("Could not chose unique relays for all hops! Please try again or use wider filter criteria.")

    hops = path_configure_hops(peers, path_relays, args.without_multihop)

    if hops[-1].provider() == 'mullvad':
        dns_server = hops[-1].peer.dns = get_dns_from_args(args)
    else:
        dns_server = hops[-1].peer.dns
        if dns_server is None:
            log_fatal("Peer %s has no DNS server, please specify one!" % get_public_key(hops[-1].peer.private_key))

    table_hops = create_hop_table(hops)

    if args.dry_run:
        print(table_hops)
        sys.exit(0)

    if circuit.is_active():
        log_verbose("Was already active, do a partial tear down.")
        down_command(Args(config=args.config, namespace_target=args.namespace_target, namespace_source=args.namespace_source, partial=True))

    physical_already_existed = True
    if args.namespace_source == NAMESPACE_PHYSICAL:
        physical_already_existed = physical_namespace_set_up()

        if not physical_already_existed:
            run_commands('pre up', circuit.pre_up)

    if args.namespace_target != NAMESPACE_ROOT:
        if not network_namespace_exists(args.namespace_target):
            create_network_namespace(args.namespace_target)

    print(table_hops)

    circuit.hops = []
    for hop in hops:
        circuit.hops.append(hop)

    namespaces = []
    namespaces.append(args.namespace_source)
    for idx in range(1, len(hops)):
        namespaces.insert(1, NAMESPACE_HOP % (args.namespace_target, idx))
        create_network_namespace(NAMESPACE_HOP % (args.namespace_target, idx))
    namespaces.append(args.namespace_target)

    mtu = 1420
    for idx in range(len(hops)):
        ridx = len(hops) - idx - 1

        hop = hops[idx]
        namespace = namespaces[idx+1]
        namespace_link_to = namespaces[idx]
        device_name = DEVICE_NAME_HOP % ridx

        wireguard_init(
            namespace,
            device_name,
            namespace_link_to,
            hop.peer.private_key
        )

        wireguard_device_setup(
            namespace,
            device_name,
            ipv4=None if args.only_use_ipv6 else hop.peer.ipv4,
            ipv6=hop.peer.ipv6,
            mtu=mtu
        )

        wireguard_add_peer(
            namespace,
            device_name,
            public_key=hop.public_key(),
            endpoint=f'{hop.ipv6()}:{hop.port()}' if args.only_use_ipv6 else f'{hop.ipv4()}:{hop.port()}'
        )

        mtu -= 80

    if args.namespace_target == NAMESPACE_ROOT:
        update_resolvconf(dns_server)

    if not is_default and not args.dont_save:
        circuit.up_command = sys.argv[sys.argv.index('up')+1:]

    if args.namespace_source == NAMESPACE_PHYSICAL:
        if not physical_already_existed:
            run_commands('post up', circuit.post_up)

    run(['systemctl', 'unmask', 'vad.move@.service'])
    log_success("VPN is successfully up!")


def network_namespace_exists(namespace):
    return os.path.exists('/var/run/netns/%s' % namespace)


def remove_device(namespace, device_name):
    log_verbose("Delete device %s from network namespace %s" % (device_name, namespace))

    if namespace == NAMESPACE_ROOT:
        run(['resolvconf', '-d', '%s.vad' % device_name])
        run(['ip', 'link', 'del', device_name])
    else:
        run(['ip', '-n', namespace, 'link', 'del', device_name])


def remove_network_namespace(namespace):
    if namespace == NAMESPACE_ROOT:
        return
    log_verbose("Remove network namespace %s" % namespace)
    process = run(['ip', 'netns', 'pids', namespace], failure_ok=True)
    if process.returncode == 0:
        pids = str(process.stdout, 'utf8')
        pids = pids.split('\n')
        pids = pids[:-1]
        if pids:
            run(['ip', 'netns', 'exec', namespace, 'kill'] + pids)

    if namespace == NAMESPACE_PHYSICAL:
        with NetworkNamespace(NAMESPACE_PHYSICAL):
            for device in get_network_devices():
                run(['ip', 'link', 'set', device.name, 'down'])
                if type == DeviceKind.Wifi:
                    run(['iw', 'phy', device.phy, 'set', 'netns', NAMESPACE_ROOT])
                elif type == DeviceKind.Ethernet:
                    run(['ip', 'link', 'set', device.name, 'netns', NAMESPACE_ROOT])

    run(['ip', 'netns', 'del', namespace])


def down_command(args):
    become_root()

    if not args.partial:
        run(['systemctl', 'mask', 'vad.move@.service'])

    state = state_load(auto_save=True)

    circuit = state.get_circuit(namespace_source=args.namespace_source, namespace_target=args.namespace_target)

    if not args.partial and args.namespace_source == NAMESPACE_PHYSICAL:
        run_commands('pre down', circuit.pre_down)

    namespaces = [args.namespace_target]
    namespaces.extend([os.path.basename(f) for f in glob.glob(f'/var/run/netns/{NAME}-*')])
    if not args.partial:
        if args.namespace_source == NAMESPACE_ROOT:
            namespaces.append(args.namespace_source)
        elif network_namespace_exists(args.namespace_source):
            namespaces.append(args.namespace_source)

    for namespace in namespaces:
        if network_namespace_exists(namespace) or namespace == NAMESPACE_ROOT:
            with NetworkNamespace(namespace):
                devices = get_network_devices()
            for device in devices:
                if device.name.startswith(f'{NAME}'):
                    remove_device(namespace, device.name)
            if args.partial and namespace == args.namespace_target:
                continue
            remove_network_namespace(namespace)

    if not args.partial and args.namespace_source == NAMESPACE_PHYSICAL:
        run_commands('post down', circuit.post_down)

    log_verbose("Reset hop configuration")
    circuit.hops = []

    if args.partial:
        log_success("VPN is succefully down (partial)")
    else:
        run(['systemctl', 'unmask', 'vad.move@.service'])
        log_success("VPN is succefully down")


def exec_command(args):
    become_root(do_lock=False)

    uid = os.getenv('SUDO_UID', os.geteuid())
    gid = os.getenv('SUDO_GID', os.getegid())
    args = ["ip", "netns", "exec", args.namespace, "sudo", "-E", "-u", '#%s' % uid, "-g", '#%s' % gid, "--"] + args.CMD
    if VERBOSE:
        print(subprocess.list2cmdline(args))
    os.execvp("ip", args)


def list_command(args):
    relays = load_relays()

    relays = filter_relays(
        relays,
        active=args.active,
        owned=args.owned,
        country_city_hostname=args.COUNTRY_CITY_HOSTNAME,
    )

    if args.group_by_country:
        countries = defaultdict(int)
        for relay in relays:
            key = (relay.country_code, relay.country_name)
            countries[key] += 1

        table = PrettyTablePretty(['Count', 'Code', 'Country'])
        table.align['Count'] = 'r'
        table.align['Country'] = 'l'
        for (country_code, country_name), count in sorted(countries.items(), key=lambda k: k[1]):
            table.add_row([count, country_code, country_name])
        print(table)
    elif args.group_by_country_city:
        country_cities = defaultdict(int)
        for relay in relays:
            key = (
                relay.country_code, relay.country_name,
                relay.city_code, relay.city_name
            )
            country_cities[key] += 1

        table = PrettyTablePretty(['Count', '', 'Country', 'Code', 'City'])
        table.align['Count'] = 'r'
        table.align['Country'] = 'l'
        table.align['City'] = 'l'
        for (country_code, country_name, city_code, city_name), count in sorted(country_cities.items(), key=lambda k: k[1]):
            table.add_row([count, country_code, country_name, city_code, city_name])
        print(table)
    elif args.group_by_asn:
        providers = defaultdict(int)
        for relay in relays:
            providers[relay.asn] += 1

        total = 0
        for (provider), count in sorted(providers.items(), key=lambda k: k[1]):
            total += count

        table = PrettyTablePretty(['Count', 'Percent', 'Cum. Percent', 'ASN'])
        table.align['Count'] = 'r'
        table.align['Percent'] = 'r'
        table.align['Cum. Percent'] = 'r'
        table.align['ASN'] = 'l'
        cumsum = 0
        for (provider), count in sorted(providers.items(), key=lambda k: k[1]):
            cumsum += count
            table.add_row([count, '%.1f' % (count/total*100), '%.1f' % (cumsum/total*100), provider])
        print(table)
    elif args.group_by_provider:
        providers = defaultdict(int)
        for relay in relays:
            providers[relay.provider] += 1

        total = 0
        for (provider), count in sorted(providers.items(), key=lambda k: k[1]):
            total += count

        table = PrettyTablePretty(['Count', 'Percent', 'Cum. Percent', 'Provider'])
        table.align['Count'] = 'r'
        table.align['Percent'] = 'r'
        table.align['Cum. Percent'] = 'r'
        table.align['ASN'] = 'l'
        cumsum = 0
        for (provider), count in sorted(providers.items(), key=lambda k: k[1]):
            cumsum += count
            table.add_row([count, '%.1f' % (count/total*100), '%.1f' % (cumsum/total*100), provider])
        print(table)
    else:
        fields = ['Active', 'Owned']

        fields.extend(['', 'Country', 'Code', 'City', 'Provider', 'ASN', 'Hostname'])

        if args.show_column_ipv4:
            fields.append('IPv4')
        if args.show_column_ipv6:
            fields.append('IPv6')

        fields.append('Multihop Port')

        fields.append('Gbit/s')

        if args.show_column_public_key:
            fields.append('Public Key')

        table = PrettyTablePretty(fields)
        table.align['Country'] = 'l'
        table.align['City'] = 'l'
        table.align['Provider'] = 'l'
        table.align['ASN'] = 'l'
        table.align['Hostname'] = 'l'
        table.align['IPv4'] = 'r'
        table.align['IPv6'] = 'r'
        table.align['Gbit/s'] = 'r'
        table.align['Messages'] = 'l'
        for relay in relays:
            values = [
                '✓' if relay.active else '',
                '✓' if relay.owned else '',
            ]

            values.extend([
                relay.country_code,
                relay.country_name,
                relay.city_code,
                relay.city_name,
                relay.asn,
                relay.provider,
                relay.hostname,
            ])

            if args.show_column_ipv4:
                values.append(relay.ipv4)
            if args.show_column_ipv6:
                values.append(relay.ipv6)

            values.append(str(relay.multihop_port))
            values.append(str(relay.gigabit_per_second))

            if args.show_column_public_key:
                values.append(relay.public_key)

            table.add_row(values)
        print(table)


def service_config() -> Args:
    udev_rule = """
    SUBSYSTEM=="net", ACTION=="add", DEVPATH!="/devices/virtual/*", RUN+="/bin/systemctl start vad.move@%E{ID_NET_NAME}"
    """

    vad_move_service = """
    [Unit]
    Description=Move interface to physical namespace

    [Service]
    Type=forking
    ExecStart=vad -nv mv %I
    """

    vad_rotate_service = """
    [Unit]
    Description=Rotate WireGuard keys of all devices

    [Service]
    Type=oneshot
    ExecStart=vad -nv rotate
    """

    vad_rotate_timer = """
    [Unit]
    After=network-online.target
    Description=Rotate WireGuard keys of all devices every 4 days

    [Timer]
    OnCalendar=*-*-2/4 02:00
    Persistent=true

    [Install]
    WantedBy=timers.target
    """

    vad_up_service = """
    [Unit]
    Description=Execute `vad update` and `vad up`

    [Service]
    Type=oneshot
    ExecStartPre=-vad -nv update
    ExecStartPre=vad -nv show
    ExecStart=vad -nv up
    """

    vad_up_timer = """
    [Unit]
    After=network-online.target
    Description=Execute `vad update` and `vad up` daily at 03:00 to refresh hop endpoints

    [Timer]
    OnCalendar=*-*-* 03:00
    Persistent=true

    [Install]
    WantedBy=timers.target
    """

    vad_service = """
    [Unit]
    Description=Starts Vad on system startup
    After=syslog.target network-online.target
    Wants=network-online.target

    [Service]
    Type=forking
    RemainAfterExit=yes
    ExecStart=vad -nv up
    ExecStop=vad -nv down

    [Install]
    WantedBy=multi-user.target
    """

    prefix='/usr/local'
    bin_prefix=f"{prefix}/bin"
    rule_prefix=f"{prefix}/lib/udev/rules.d"
    systemd_prefix=f"{prefix}/lib/systemd/system"

    return Args(
        prefix=prefix,
        bin_prefix=bin_prefix,
        bin_path=f"{bin_prefix}/vad",
        rule_prefix=rule_prefix,
        rule_path=f"{rule_prefix}/vad.rules",
        systemd_prefix=systemd_prefix,
        udev_rule=udev_rule,
        systemd_units=[
            ("service" , f"{systemd_prefix}/vad.move@.service"  , vad_move_service   ) ,
            ("service" , f"{systemd_prefix}/vad.rotate.service" , vad_rotate_service ) ,
            ("service" , f"{systemd_prefix}/vad.up.service"     , vad_up_service     ) ,
            ("service" , f"{systemd_prefix}/vad.service"        , vad_service        ) ,
            ("timer"   , f"{systemd_prefix}/vad.rotate.timer"   , vad_rotate_timer   ) ,
            ("timer"   , f"{systemd_prefix}/vad.up.timer"       , vad_up_timer       ) ,
        ],
    )


def generate_ipv6_private_address() -> ipaddress.IPv6Interface:
    private = ipaddress.IPv6Network('fc00::/7')
    return ipaddress.IPv6Interface(
        random.randint(
            int(private.network_address) + 2,
            int(private.broadcast_address) + 1
        )
    )


def get_rp_address(key: X25519PrivateKey, proxy_address: Tuple[str, int], proxy_public_key: X25519PublicKey, port_rp: int):
    udp_rp = get_socket_proxy_client(proxy_address, port_rp)

    conn = NoiseConnection.from_name(b'Noise_IK_25519_ChaChaPoly_BLAKE2s')
    conn.set_keypair_from_private_bytes(Keypair.STATIC, key.private_bytes_raw())
    conn.set_keypair_from_public_bytes(Keypair.REMOTE_STATIC, proxy_public_key.public_bytes_raw())
    noise = initiator_do_handshake('Service', udp_rp, conn)

    noise.send(bytes([ACTION_TEST]))
    data = noise.recv(2048)
    rp_address = data[1:]
    print('Service: Reflexive address for RP: %s:%d' % ipv4_unpack(rp_address))

    return ipv4_unpack(rp_address)


# TODO: Implement keepalive for services
# TODO: Better error handling
# TODO: Rate limiting (DoS)
# TODO: Only supportes one client
# NOTE: Assumption: Every unique (protcol, private address, port) combination is mapped to the same public combination
def introduction_point_service(key: X25519PrivateKey, proxy_address: Tuple[str, int], proxy_public_key: X25519PublicKey, our_rp_address: Tuple[str, int], port_service: int) -> Tuple[str, X25519PublicKey, Tuple[str, int]]:
    udp = get_socket_proxy_client(proxy_address)

    conn = NoiseConnection.from_name(b'Noise_IK_25519_ChaChaPoly_BLAKE2s')
    conn.set_keypair_from_private_bytes(Keypair.STATIC, key.private_bytes_raw())
    conn.set_keypair_from_public_bytes(Keypair.REMOTE_STATIC, proxy_public_key.public_bytes_raw())
    noise = initiator_do_handshake('Service', udp, conn)

    noise.send(bytes([ACTION_TEST]))
    data = noise.recv(2048)
    print('Service: Reflexive address for IP: %s:%d' % ipv4_unpack(data[1:]))

    print('Service: Request listing')
    noise.send(bytes([ACTION_LISTEN]))
    data = noise.recv(2048)
    assert len(data) == 1

    print('Service: Listening', to_base64(key.public_key().public_bytes_raw()))
    noise.settimeout(None)
    data = noise.recv(2048)
    assert len(data) == (1 + 6 + 32)

    print('Service: Got public key for peer')
    peer_public_key = data[7:]
    peer_public_key = X25519PublicKey.from_public_bytes(peer_public_key)
    peer = ipv4_unpack(data[1:7])
    peer_udp = UDPSocket(udp.sock, peer)
    punch_hole('Service', peer_udp)

    conn = NoiseConnection.from_name(b'Noise_KK_25519_ChaChaPoly_BLAKE2s')
    conn.set_keypair_from_private_bytes(Keypair.STATIC, key.private_bytes_raw())
    conn.set_keypair_from_public_bytes(Keypair.REMOTE_STATIC, peer_public_key.public_bytes_raw())
    noise = responder_do_handshake('Service', peer_udp, conn)

    ipv6 = generate_ipv6_private_address()
    print(f'Service: Allocate address for client: {ipv6}')
    noise.send(ipv4_pack(*our_rp_address))
    data = noise.recv(2048)
    assert len(data) == 6
    their_rp_address = data

    noise.send(ipv6.packed + struct.pack('!H', int(port_service)))
    noise.recv(2048)
    return str(ipv6.ip), peer_public_key, ipv4_unpack(their_rp_address)


# TODO: DoS is possible (Exhaust resources with added wireguard peers)
# TODO: -> Introduce `max_connections` and `max_connections_per_second`
# TODO: -> Automatically remove wireguard peers
# NOTE: WIP: This function just demonstrates how it could work, but it is far from production ready!
def introduction_point(stop: threading.Event, service_key: X25519PrivateKey, namespace: str, device_name: str, our_rp_address, port_service: int):
    while not stop.is_set():
        ipv6, peer_public_key, their_rp_address = introduction_point_service(service_key, PROXY_ADDRESS, PROXY_KEY.public_key(), our_rp_address, port_service)
        rp_ipv4, rp_port = their_rp_address
        wireguard_add_peer(namespace, device_name, to_base64(peer_public_key.public_bytes_raw()), endpoint=f'{rp_ipv4}:{rp_port}', allowed_ips=f'{ipv6}', persistent_keepalive=25)
        with NetworkNamespace('service'):
            run(['ping', '-c', '5', '-6', str(ipv6)])



def get_my_public_ip():
    try:
        response = requests.get('https://ipv4.am.i.mullvad.net/json')
        return response.json()['ip']
    except Exception as e:
        log_fatal("Error while getting public ip (%s)!" % (str(e)))


def copy_to_clipboard(message: str):
    from tkinter import Tk
    r = Tk()
    r.withdraw()
    r.clipboard_clear()
    r.clipboard_append(message)
    r.update()


def proxy_command(args):
    Proxy(PROXY_KEY, args.port).start()


def start_command(args: Args):
    become_root()

    # FIXME: inflexible
    # if not is_active():
    #     up_command(Args(**up_command_defaults), True)

    introduction_point_thread = None
    stop_event = None
    service_process = None

    def start():
        nonlocal introduction_point_thread
        nonlocal stop_event
        nonlocal service_process

        stop_event = threading.Event()

        local_rp_port = random.randint(40000, 2**16)
        rp_address = get_rp_address(SERVICE_KEY, PROXY_ADDRESS, PROXY_KEY.public_key(), local_rp_port)

        introduction_point_thread = threading.Thread(target=introduction_point, args=(stop_event, SERVICE_KEY, 'service', 'service0', rp_address, '8000'))

        url = OnionVpnUrl(PROXY_ADDRESS[0], PROXY_ADDRESS[1], PROXY_KEY.public_key().public_bytes_raw())
        copy_to_clipboard('vad -v connect ' + str(url))
        log_info('Share this URL with a client: ' + str(url) + " (It does not work with a regular web browser)")

        num_hops = 0
        create_network_namespace('service')
        wireguard_init('service', 'service0', NAMESPACE_ROOT, to_base64(SERVICE_KEY.private_bytes_raw()), local_rp_port)
        wireguard_device_setup('service', 'service0', 'fc00::1', None, 1420 - (num_hops*80))

        log_info('Start introduction point')
        introduction_point_thread.start()
        service_process = subprocess.Popen(['ip', 'netns', 'exec', 'service'] + args.CMD)

    def cleanup():
        if stop_event is not None:
            stop_event.set()
        if introduction_point_thread is not None and introduction_point_thread.is_alive():
            introduction_point_thread.join()
        if service_process is not None:
            service_process.terminate()
            service_process.wait()
        remove_device('service', 'service0')
        remove_network_namespace('service')

    try:
        start()
        input()
    finally:
        cleanup()

def introduction_point_connect(key: X25519PrivateKey, proxy_address: Tuple[str, int], proxy_public_key: X25519PublicKey, service_public_key: X25519PublicKey, our_rp_address: Tuple[str, int]) -> Optional[Tuple[str, int, Tuple[str, int]]]:
    udp = get_socket_proxy_client(proxy_address)

    conn = NoiseConnection.from_name(b'Noise_IK_25519_ChaChaPoly_BLAKE2s')
    conn.set_keypair_from_private_bytes(Keypair.STATIC, key.private_bytes_raw())
    conn.set_keypair_from_public_bytes(Keypair.REMOTE_STATIC, proxy_public_key.public_bytes_raw())
    noise = initiator_do_handshake('Client', udp, conn)

    noise.send(bytes([ACTION_TEST]))
    data = noise.recv(2048)
    print('Client: Reflexive address:', ipv4_unpack(data[1:]))

    noise.send(bytes([ACTION_CONNECT]) + service_public_key.public_bytes_raw())
    data = noise.recv(2048)
    assert len(data) >= 1
    action = data[0]
    if len(data) == 1 and action == RESPONSE_NCK:
        print('Client: No listener for key')
        return None
    elif len(data) == 7 and action == RESPONSE_ACK:
        print('Client: Found listener')
        peer = ipv4_unpack(data[1:])
        peer_udp = UDPSocket(udp.sock, peer)
        punch_hole('Client', peer_udp)
        # peer_udp.recv(0)

        conn = NoiseConnection.from_name(b'Noise_KK_25519_ChaChaPoly_BLAKE2s')
        conn.set_keypair_from_private_bytes(Keypair.STATIC, key.private_bytes_raw())
        conn.set_keypair_from_public_bytes(Keypair.REMOTE_STATIC, service_public_key.public_bytes_raw())
        noise = initiator_do_handshake('Client', peer_udp, conn)

        data = noise.recv(2048)
        assert len(data) == 6
        their_rp_address = ipv4_unpack(data)

        noise.send(ipv4_pack(*our_rp_address))

        data = noise.recv(2048)
        assert len(data) == 18
        ipv6 = ipaddress.IPv6Address(data[0:16])
        service_port: int = struct.unpack('!H', data[16:18])[0]
        print(f'Client: Got {ipv6}:{service_port}')
        noise.send(bytes([RESPONSE_ACK]))

        return str(ipv6), service_port, their_rp_address

    return None


def connect_command(args):
    become_root(do_lock=False)

    # FIXME: inflexible
    # if no is_active():
    #   up_command(Args(**up_command_defaults), True)

    url = OnionVpnUrl.from_url(args.URL[0])

    log_info('Service Information:', highlight=True)
    log('- ip address: ' + url.ipv4)
    log('- introduction point port: ' + str(url.port_ip))
    log('- service sign public key: ' + to_base64(url.public_key))

    # TODO: hardcoded
    client_key = X25519PrivateKey.from_private_bytes(from_base64('0Bz3Vpa47HCoNYrWmtZDfDFi4mEuXmgPC6Nk8mA8aU8='))

    local_rp_port = random.randint(40000, 2**16)
    our_rp_address = get_rp_address(client_key, PROXY_ADDRESS, PROXY_KEY.public_key(), local_rp_port)

    log_info('IP: Connecting to introduction point', highlight=True)
    result = introduction_point_connect(client_key, (url.ipv4, int(url.port_ip)), X25519PublicKey.from_public_bytes(url.public_key), SERVICE_KEY.public_key(), our_rp_address)
    if result is None:
        return
    our_ipv6, service_port, their_rp_address = result
    rp_ipv4, rp_port = their_rp_address
    log('IP: Got our ip address from the service: ' + our_ipv6)

    try:
        num_hops = 0
        create_network_namespace('client')
        wireguard_init('client', 'client0', NAMESPACE_ROOT, to_base64(client_key.private_bytes_raw()), local_rp_port)
        wireguard_device_setup('client', 'client0', None, our_ipv6, 1420 - (num_hops*80))
        wireguard_add_peer('client', 'client0', to_base64(SERVICE_KEY.public_key().public_bytes_raw()), endpoint=f'{rp_ipv4}:{rp_port}', allowed_ips='fc00::1/128', persistent_keepalive=25)
        with NetworkNamespace('client'):
            run(['ping', '-c', '5', '-6', 'fc00::1'])
        run_in_namespace_or_fail('client', ['chromium', f'http://[fc00::1]:{service_port}'], as_user=True)
    finally:
        remove_device('client', 'client0')
        remove_network_namespace('client')


def install_command(_: Args):
    become_root()

    config = service_config()

    os.makedirs(config.bin_prefix, exist_ok=True)
    os.makedirs(config.rule_prefix, exist_ok=True)
    os.makedirs(config.systemd_prefix, exist_ok=True)

    log_verbose("Copy vad into %s" % config.bin_prefix)
    shutil.copyfile(os.path.abspath(sys.argv[0]), config.bin_path)
    os.chmod(config.bin_path, 0o755)

    log_verbose("Install udev rule %s" % config.rule_path)

    with open(config.rule_path, 'w') as f:
        f.write(config.udev_rule)

    for type, filename, content in config.systemd_units:
        log_verbose("Install %s %s" % (type, filename))
        with open(filename, 'w') as f:
            f.write(content)

    log_verbose("Verify configuration files:")

    for filename in os.listdir('/sys/class/net'):
        run_or_fail(['bash', '-c', 'udevadm test --action=add /sys/class/net/%s 2>&1 | grep "vad"' % filename])

    for type, filename, content in config.systemd_units:
        run_or_fail(['systemd-analyze', 'verify', os.path.basename(filename)])

    log_verbose("Enable:")

    for type, filename, content in config.systemd_units:
        if 'vad.rotate.service' in filename:
            continue
        if 'vad.up.service' in filename:
            continue
        if 'vad.move@.service' in filename:
            continue
        run_or_fail(['systemctl', 'enable', os.path.basename(filename)])

    log_verbose("Reload udev rules")
    run_or_fail(['udevadm', 'control', '--reload'])

    log_success("Successfully installed udev rule, services and timers!")


def remove_file_if_exists(filename):
    if os.path.exists(filename):
        os.remove(filename)
        log_verbose('Removed %s' % filename)


def uninstall_command(_: Args):
    become_root()

    config = service_config()

    log_verbose("Disable services/timers:")
    for _, filename, _ in config.systemd_units:
        run(['systemctl', 'disable', os.path.basename(filename)], failure_ok=True)

    log_verbose("Unlink %s" % config.bin_path)
    remove_file_if_exists(config.bin_path)

    log_verbose("Remove udev rule %s" % config.rule_path)
    remove_file_if_exists(config.rule_path)

    for _, filename, _ in config.systemd_units:
        remove_file_if_exists(filename)

    log_verbose("Reload udev rules")
    run(['udevadm', 'control', '--reload'], failure_ok=True)


def menu_select_one(selection, default):
    while True:
        digits_total = int(math.ceil(math.log10(len(selection))))
        for idx, (_, value) in enumerate(selection):
            index = idx+1
            index_format = '%%%ds' % digits_total
            print(colored(index_format, 'green') % str(index) + ' %s' % value)
        try:
            print()
            print(
                colored('[%d]' % (default + 1), 'green') +
                ': ',
                end=''
            )
            idx = input()
            if idx == '':
                idx = default
                break
            idx = int(idx) - 1
            if idx < 0 or idx >= len(selection):
                continue
            else:
                break
        except ValueError:
            continue
    return selection[idx][0]


def move_command(args):
    become_root()

    if not network_namespace_exists(NAMESPACE_PHYSICAL):
        log_warn('Namespace %s does not exists, can not move device!' % NAMESPACE_PHYSICAL)
        raise Abort()

    moved_to = False
    for device in get_network_devices():
        if device.kind != DeviceKind.Virtual and device.name == args.INTERFACE[0]:
            device_move_to_physical(device)
            moved_to = True

    exists_in_physical = False
    with NetworkNamespace(NAMESPACE_PHYSICAL):
        for device in get_network_devices():
            if device.kind != DeviceKind.Virtual and device.name == args.INTERFACE[0]:
                exists_in_physical = True

    if not moved_to and not exists_in_physical:
        log_warn("Device '%s' does not exists!" % args.INTERFACE[0])


def rotate_command(args: Args, parser_up: ArgumentParser):
    become_root()

    state = state_load(auto_save=True)

    with Mullvad().authenticate(get_account_number(state, args.passname), state.provider.mullvad.access_token) as mullvad:
        state.provider.mullvad.access_token = mullvad.access_token

        for peer in state.peers:
            if not peer.provider == 'mullvad':
                continue
            private_key_new = generate_private_key()
            public_key_new = get_public_key(private_key_new)
            public_key = get_public_key(peer.private_key)
            mullvad_peer = mullvad.peer_update_pubkey(public_key, public_key_new)
            log_info("%s: Rotate key of peer %s -> %s" % (peer.provider, public_key, public_key_new))
            peer.private_key = private_key_new
            peer.ipv4 = mullvad_peer.ipv4_address
            peer.ipv6 = mullvad_peer.ipv6_address
            # FIXME: Implement backoff
            time.sleep(2)

    log_success("Successfully rotated WireGuard keys of all mapped peers")

    for circuit in state.circuits.values():
        if circuit.is_active():
            args = Args(**vars(parser_up.parse_args(circuit.up_command)))
            up_command(args, parser_up)


def reset_command(args: Args):
    become_root()

    state = state_load(auto_save=True)

    uninstall_command(Args())
    delete_command(Args(config=args.config, all=True, INDEX=None, passname=args.passname))

    for circuit in state.circuits.values():
        down_command(Args(config=args.config, namespace_target=circuit.namespace_target, namespace_source=circuit.namespace_source, partial=False))

    state.provider.mullvad.account_number = None
    state.provider.mullvad.access_token = None

    log_success("Successfully reseted")


def check_unique_city_codes(relays: List[Relay]):
    country_cities = set([(relay.country_code, relay.city_code) for relay in relays])
    city_counter = Counter([city for _, city in country_cities])

    for city, count in city_counter.items():
        if count > 1:
            duplicates = set()
            for relay in relays:
                if city == relay.city_code:
                    duplicates.add('%s (%s), %s (%s)' % (relay.country_name, relay.country_code, relay.city_name, relay.city_code))
            log_warn("Attention, the city code '%s' is not unique:" % city)
            for text in duplicates:
                print('- %s' % text)


def check_special_country_codes_not_in_use(relays: List[Relay]):
    for relay in relays:
        if 'eu' == relay.country_code:
            log_warn("Attention, the special country code 'eu' used by this program is in use by a relay. This makes this relay unselectable! (%s)" % str(relay))
        if 'ec' == relay.country_code:
            log_warn("Attention, the special country code 'ec' used by this program is in use by a relay. This makes this relay unselectable! (%s)" % str(relay))


def update_command(_: Args):
    become_root()

    os.makedirs('/etc/vad', exist_ok=True)

    state = state_load()

    providers = set(['mullvad'])
    for peer in state.peers:
        providers.add(peer.provider)
    providers = list(providers)

    for provider in providers:
        if provider == 'mullvad':
            try:
                relays: List[Relay] = []
                for mullvad_relay in Mullvad().relays():
                    relay = Relay(
                        provider           = provider,
                        hostname           = mullvad_relay.hostname,
                        country_code       = mullvad_relay.country_code,
                        country_name       = mullvad_relay.country_name,
                        city_code          = mullvad_relay.city_code,
                        city_name          = mullvad_relay.city_name,
                        active             = mullvad_relay.active,
                        owned              = mullvad_relay.owned,
                        asn                = mullvad_relay.provider,
                        ipv4               = mullvad_relay.ipv4_addr_in,
                        ipv6               = mullvad_relay.ipv6_addr_in,
                        gigabit_per_second = mullvad_relay.network_port_speed,
                        public_key         = mullvad_relay.pubkey,
                        multihop_port      = mullvad_relay.multihop_port,
                    )
                    relays.append(relay)

                path = os.path.join(PROVIDER_DIR, provider + '.json')
                with open(path, 'w') as file:
                    json.dump([relay.to_dict() for relay in relays], file, indent=4)
                os.chmod(path, 0o644)

                log_info('%s updated with %d wireguard relays' % (path, len(relays)))
            except Exception as e:
                log_warn('Can not download relays from Mullvad, because of %s' % (str(e)))

    relays = load_relays(providers)
    check_unique_city_codes(relays)
    check_special_country_codes_not_in_use(relays)


def get_network_devices() -> List[Device]:
    dir = '/sys/class/net'
    devices = []
    for dev in os.listdir(dir):
        path_dest = os.readlink(os.path.join(dir, dev))
        if 'virtual' in path_dest:
            devices.append(Device(DeviceKind.Virtual, dev, ''))
        elif 'devices' in path_dest:
            path = os.path.join(dir, path_dest, "phy80211")
            if os.path.exists(path):
                devices.append(Device(DeviceKind.Wifi, dev, os.path.basename(os.readlink(path))))
            else:
                devices.append(Device(DeviceKind.Ethernet, dev, ''))
    return devices


class TestDependencies(unittest.TestCase):
    def test(self):
        commands = [
            "sudo",
            "kill",
            "killall",
            "timeout",
            "wg",
            "ip",
            "iw",
            "sysctl",
            "resolvconf",
            # pass
        ]

        for command in commands:
            process = subprocess.run(['bash', '-c', 'command -v %s' % command], capture_output=True)
            if process.returncode != 0:
                print("Command '%s' should be available!" % command)


class TestCase(unittest.TestCase):
    def save_main_module(self):
        self.main_module = dict()
        module = sys.modules[__name__]
        for key, value in module.__dict__.items():
            if not '__' in key:
                self.main_module[key] = value
        return module

    def restore_main_module(self):
        module = sys.modules[__name__]
        for key, value in self.main_module.items():
            module.__dict__[key] = value

    def assertExit(self, func):
        with self.assertRaises(SystemExit):
            func()

    def capture(self, func):
        out = StringIO()
        with redirect_stdout(out):
            func()
        return out.getvalue()


class TestRelayRandomChoice(TestCase):
    def test(self):
        import numpy as np
        relays = load_relays()
        countries = defaultdict(int)

        N = 1000
        for _ in range(N):
            relay = relay_random_choice(relays, uniform_by_country=True)
            if relay is not EmptyRelay:
                countries[relay.country_code] += 1

        result = np.array(list(countries.values()))
        expected = np.array([N/len(countries)] * len(countries.values()))

        chi = np.sum((result - expected)**2 / expected)
        chi = chi / len(countries.values())
        assert chi < 2.0


class TestGetDnsServerFromFlags(TestCase):
    def testWrongFlag(self):
        out = self.capture(partial(get_dns_server_from_flags, "x"))
        self.assertIn("Unkown", out)

    def test(self):
        cases = [
            ("10.64.0.1",   ""),
            ("100.64.0.1",  "a"),
            ("100.64.0.2",  "t"),
            ("100.64.0.3",  "at"),
            ("100.64.0.4",  "m"),
            ("100.64.0.5",  "am"),
            ("100.64.0.6",  "tm"),
            ("100.64.0.7",  "atm"),
            ("100.64.0.8",  "p"),
            ("100.64.0.9",  "pa"),
            ("100.64.0.10", "pt"),
            ("100.64.0.11", "pat"),
            ("100.64.0.12", "pm"),
            ("100.64.0.13", "pam"),
            ("100.64.0.14", "ptm"),
            ("100.64.0.15", "patm"),
            ("100.64.0.16", "g"),
            ("100.64.0.17", "ga"),
            ("100.64.0.18", "gt"),
            ("100.64.0.19", "gat"),
            ("100.64.0.20", "gm"),
            ("100.64.0.21", "gam"),
            ("100.64.0.22", "gmt"),
            ("100.64.0.23", "gamt"),
            ("100.64.0.24", "gp"),
            ("100.64.0.25", "gap"),
            ("100.64.0.26", "gpt"),
            ("100.64.0.27", "gapt"),
            ("100.64.0.28", "gpm"),
            ("100.64.0.29", "gapm"),
            ("100.64.0.30", "gpmt"),
            ("100.64.0.31", "apgmt"),
        ]

        for dns, flags in cases:
            self.assertEqual(dns, get_dns_server_from_flags(flags), "Used flags: %s" % flags)


class TestMullvadIntegration(unittest.TestCase):
    def test(self):
        import base64

        with Mullvad() as api:
            connected = api.connected()
            self.assertEqual(len(connected), 2)
            self.assertEqual(type(connected[0]), bool)
            self.assertEqual(type(connected[1]), str)

            relays = api.relays()
            self.assertTrue(len(relays) > 200)
            self.assertEqual(type(relays[0]), MullvadRelay)

            with api.authenticate(user_request_account_number('web/mullvad')) as auth:
                public_key = str(base64.encodebytes(os.urandom(32)), 'utf8').strip()
                public_key2 = str(base64.encodebytes(os.urandom(32)), 'utf8').strip()

                account = auth.account()
                self.assertTrue(account.is_active())
                self.assertTrue(account.can_add_peers())

                peers = auth.peers()

                peer = auth.peer_create(public_key)
                self.assertEqual(peer.pubkey, public_key)
                self.assertEqual(len(peers)+1, len(auth.peers()))

                peer = auth.peer_update_pubkey(public_key, public_key2)
                self.assertEqual(peer.pubkey, public_key2)

                auth.peer_remove(public_key2)
                self.assertEqual(len(peers), len(auth.peers()))


class TestOnionVpnUrl(unittest.TestCase):
    def test(self):
        url = OnionVpnUrl('123.45.6.78', 6666, bytes([1]*32))
        url_ = OnionVpnUrl.from_url(str(url))

        self.assertEqual(url.ipv4, '123.45.6.78')
        self.assertEqual(url.port_ip, 6666)
        self.assertEqual(url.public_key, bytes([1]*32))

        self.assertIsInstance(url.ipv4, str)
        self.assertIsInstance(url_.ipv4, str)
        self.assertIsInstance(url.port_ip, str)
        self.assertIsInstance(url_.port_ip, str)
        self.assertIsInstance(url.public_key, bytes)
        self.assertIsInstance(url_.public_key, bytes)

        self.assertEqual(url.ipv4, url_.ipv4)
        self.assertEqual(url.port_ip, url_.port_ip)
        self.assertEqual(url.public_key, url_.public_key)
        self.assertEqual(len(url.public_key), 32)
        self.assertEqual(len(url_.public_key), 32)

        self.assertEqual(str(url), 'aaahwligjynauaibaeaqcaibaeaqcaibaeaqcaibaeaqcaibaeaqcaibaeaqcaib.onion.vpn')


def test_build_image(base_image, build, Dockerfile):
    from tempfile import TemporaryDirectory

    tag = 'vad-%s' % base_image

    if build:
        with TemporaryDirectory() as dir:
            with open('%s/Dockerfile' % dir, 'w') as f:
                f.write(Dockerfile.format(base_image=base_image))
            subprocess.run(f"docker build -t {tag} {dir}", shell=True, check=True)
    return tag


def test_command(args):
    if args.docker:
        become_root()

        images = []
        images.append(test_build_image('archlinux', not args.docker_skip_build,
            """
            FROM {base_image}
            RUN pacman -Syu --noconfirm python-requests python-dbus python-yaml python-prettytable python-numpy sudo iw wireguard-tools
            """
        ))

        for base_image in ['ubuntu', 'ubuntu:20.04', 'debian']:
            images.append(test_build_image(base_image, not args.docker_skip_build,
                """
                FROM {base_image}
                RUN apt update && apt install -y -q python3-dbus python3-requests python3-yaml python3-prettytable python3-numpy sudo psmisc wireguard-tools iproute2 iw wpasupplicant dhcpcd5 procps
                """
            ))


        path = sys.argv[0]
        for image in images:
            command = f"docker run --rm -v /etc/vad/mullvad.json:/etc/vad/mullvad.json -v {path}:/bin/vad {image} vad test"
            print(command)
            subprocess.run(command, shell=True, check=True)
    else:
        unittest.main(argv=sys.argv[1:])


def get_default_arguments(parser: ArgumentParser) -> Args:
    return parser.parse_args([])


def is_default_arguments(parser: ArgumentParser, current_args: Args) -> bool:
    args = vars(current_args)
    default_args = vars(parser.parse_args([]))
    is_default = True
    for key, value in default_args.items():
        if not key in args or value != args[key]:
            is_default = False
    return is_default


def vad():
    parser = argparse.ArgumentParser(
        prog="vad",
        description="An alternative command line interface (CLI) for Mullvad that is based on network namespaces and supports up to ten hops.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument('-p', '--print-args', action='store_true', help='Output parsed args.')
    parser.add_argument('-v', '--verbose', action='store_true', help='Output verbose information.')
    parser.add_argument('-n', '--no-color', action='store_true', help='Never output color')
    parser.add_argument('-c', '--config', help='Use this configuration file', default=CONFIGURATION)
    parser.set_defaults(func=show_command)

    subparsers = parser.add_subparsers()

    init = subparsers.add_parser('init', help='Initalize Mullvad VPN by asking the user for the account number and adding one peer. The account number will be saved.', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    init.add_argument('-p', '--passname', nargs=1, dest='passname', help='Request account number from pass.', default='web/mullvad')
    init.add_argument('-d', '--dont-save-account-number', action='store_true', help='Does not save the account number into the configuration file. Useful if you have the account number in `pass`.')
    init.add_argument('-o', '--provider', type=str, nargs='?', default='mullvad', help='Specifices the provider that should be initialized')
    init.set_defaults(func=init_command)

    add = subparsers.add_parser('add', help='Adding new peers from your account to this computer. Every new peer enables at least one hop. In a multihop configuration (https://mullvad.net/de/help/multihop-wireguard) every peer enables two hops. Normally 5 peers are possible per account, this allows a maximum of ten hops.', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    add.add_argument('-p', '--passname', nargs=1, dest='passname', help='Request account number from pass.', default='web/mullvad')
    add.add_argument('-o', '--provider', type=str, nargs='?', default='mullvad', help='Specifices the provider from which (a) peer(s) should be added')
    add.add_argument('count', metavar='N', type=int, nargs='?', default=1, help='Number of peers to add, useful if you do not want to save your account number and want to add more than one peer.')
    add.set_defaults(func=add_command)

    delete = subparsers.add_parser('delete', help='Delete mapped peer(s) from this computer and your account.', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    delete.add_argument('--all', action='store_true', help='Delete all mapped peers.')
    delete.add_argument('-p', '--passname', nargs=1, dest='passname', help='Request account number from pass.', default='web/mullvad')
    delete.add_argument('INDEX_PUBLIC_KEY', nargs='?', metavar='INDEX_PUBLIC_KEY', help='Delete specified mapped peer from this computer and your account. You can do that with the index (`vad info`) or the public key. CAUTION: The index of the other peers changes after deletion. You can use the public key to delete non mapped peers.')
    delete.set_defaults(func=delete_command)

    info = subparsers.add_parser('info', help='View account information and highlight peers added to this computer.', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    info.add_argument('-p', '--passname', nargs=1, dest='passname', help='Request account number from pass.', default='web/mullvad')
    info.add_argument('-a', '--show-account-number', action='store_true', help='Shows the account number.')
    info.add_argument('-s', '--show-peer-ids', action='store_true', help='Show peer ids.')
    info.add_argument('-6', '--show-ipv6', action='store_true', help='Show IPv6 address column of peer.')
    info.set_defaults(func=info_command)

    update = subparsers.add_parser('update', help='Update or initialize relay list.')
    update.set_defaults(func=update_command)

    up = subparsers.add_parser('up', aliases=['u'], help=f'Set up a vpn tunnel: move all physical network devices into the physical network namespace, configure one or more Mullvad relay and setup a wireguard device in the root namespace. All programs from non root users are forced to use the wireguard device in the root namespace.')
    up.add_argument('COUNTRY_CITY_HOSTNAME', nargs='*', help='Select up to ten random hops by country code (e.g. de), city code (e.g. dus) or hostname (e.g. de-dus-wg-001). Filtering by hostname only works with four or more characters and must be a substring from the relay\'s hostname. The sequence determines the data flow. More hops require more devices (see `vad init`). If you want to use a random hop around the earth, then use "w" as placeholder. If you only want to use hops from countries in the European Union then use "eu". If you only want to use hops from countries on the European continent then use "ec". If no hops are specified, then a one hop tunnel with a random hop from around the earth will be built. If already active, than a second call, will tear down the configuration, except the physical namespace, so no data leaks can occur, and build a new tunnel. If you execute the up command without arguments (`vad up`) it will use the options of the last call with arguments. The last call with arguments will be saved to the configuration file, after an successful up, if you do not want this, use `-s --dont-save`.')
    up.add_argument('-s', '--dont-save', action='store_true', help='Do not save the last call with arguments to the configuration file.')
    up.add_argument('-a', '--update-relay-list', action='store_true', help='Update relay list.')
    up.add_argument('-n', '--dry-run', action='store_true', help='Show only chosen hop(s) and nameserver.')
    up.add_argument('-d', '--dns', nargs=1, help='Set a blocking dns server by flags (atmpg) or with no flags use the nonblocking dns server (10.64.0.1): a = Block adverdisments, t = Block tracking, m = Block malicious sites, p = Block adult content, g = Block gampling sites.', default='')
    up.add_argument('-w', '--without-multihop', action='store_true', help='Normally pairs of hops are taken and configured as multihop beginning from the last hop. Every hop pair requires one peer, with this option every hop requires one peer.')
    up.add_argument('-u', '--uniform-by-country', action='store_true', help='Randomly select a country and then randomly select a hop.')
    up.add_argument('-o', '--owned-entry', action='store_true', help='Use a owned relay by Mullvad for your entry hop.')
    up.add_argument('-6', '--only-use-ipv6', action='store_true', help='Only use IPv6 addresses.')
    up.add_argument('-t', '--namespace-target', help='EXPERIMENTAL: You can specific which namespace will have access to the tunnel, if this option is not present, it will be the root namespace, which is called "1" under Linux.', default=NAMESPACE_ROOT)
    up.add_argument('-b', '--namespace-source', help='EXPERIMENTAL: You can specific the namespace where tunnel has access to (physical) interfaces. Usually it is the physical namespace.', default=NAMESPACE_PHYSICAL)
    up.set_defaults(func=up_command)

    down = subparsers.add_parser('down', aliases=['d'], help='Tear down the vpn configuration and restore the previous state.')
    down.add_argument('-p', '--partial', action='store_true', help=f'Do not delete the physical namespace. Your physical network interfaces will remain in this namespace, which leaves you with no network access at all. Useful if you manually configured your physical network namespace.', default=False)
    down.add_argument('-t', '--namespace-target', help='EXPERIMENTAL: Specific the traget namespace', default=NAMESPACE_ROOT)
    down.add_argument('-b', '--namespace-source', help='EXPERIMENTAL: Specific the source namespace', default=NAMESPACE_PHYSICAL)
    down.set_defaults(func=down_command)

    exec = subparsers.add_parser('exec', aliases=['e'], help='Execute command in the physical namespace. The command can use the physical network interfaces directly.', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    exec.add_argument('-n', '--namespace', nargs='?', help=f'Specify the namespace you want to execute the command in', default=NAMESPACE_PHYSICAL)
    exec.add_argument('CMD', nargs=argparse.REMAINDER, help=f'Command to execute in the specified namespace with or without arguments.')
    exec.set_defaults(func=exec_command)

    show = subparsers.add_parser('show', aliases=['s'], help='Show vpn status information and active circuits, return 0 if at least one circuit is active, otherwise 1.', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    show.add_argument('-i', '--wireguard-interfaces', action='store_true', help=f'Show all WireGuard interfaces per circuit', default=False)
    show.set_defaults(func=show_command)

    list = subparsers.add_parser('list', aliases=['l'], help='List, filter and group relays.', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    list.add_argument('COUNTRY_CITY_HOSTNAME', nargs='?', help='Select relay by country code (e.g. de), city code (e.g. dus) or hostname if it contains this substring (e.g. de-dus-wg-001). Filtering by hostname only works with four or more characters.')
    list.add_argument('-c', '--group-by-country', action='store_true', help='Group and count by country.')
    list.add_argument('-y', '--group-by-country-city', action='store_true', help='Group and count by country and city.')
    list.add_argument('-s', '--group-by-asn', action='store_true', help='Group and count by ASN.')
    list.add_argument('-d', '--group-by-provider', action='store_true', help='Group and count by provider.')
    list.add_argument('-4', '--show-column-ipv4', action='store_true', help='Shows ipv4 column (ignored by --group-by-*).')
    list.add_argument('-6', '--show-column-ipv6', action='store_true', help='Shows ipv6 column (ignored by --group-by-*).')
    list.add_argument('-p', '--show-column-public-key', action='store_true', help='Show public key column (ignored by --group-by-*).')
    list.add_argument('-o', '--owned', dest='owned', action='store_true', help='Filter by owned relays.', default=None)
    list.add_argument('-r', '--rented', dest='owned', action='store_false', help='Filter by rented relays.', default=None)
    list.add_argument('-a', '--active', dest='active', action='store_true', help='Filter by active relays.', default=None)
    list.add_argument('-i', '--inactive', dest='active', action='store_false', help='Filter by inactive relays.', default=None)
    list.set_defaults(func=list_command)

    proxy = subparsers.add_parser('proxy', help='Start a proxy that will help an onion vpn service to connect to a client')
    proxy.set_defaults(func=proxy_command)
    proxy.add_argument('--port', nargs=1, default=6666, help=f'Port where the proxy should listen on')

    start = subparsers.add_parser('start', help='Start an onion vpn service in its own network namespace')
    start.set_defaults(func=start_command)
    start.add_argument('CMD', nargs=argparse.REMAINDER, help=f'Command to start the service in the service namespace with or without arguments.')

    connect = subparsers.add_parser('connect', help='Connect to an onion vpn service')
    connect.set_defaults(func=connect_command)
    connect.add_argument('URL', nargs=1, help=f'URL')

    install = subparsers.add_parser('install', aliases=['in'], help='Installs a service which automatically starts the VPN on system startup and tears it down on system shutdown. A udev rule move new network devices into physical namespace and automatically creates it if it does not exists. A timer will rotate WireGuard keys every 4 days (same as the Mullvad app).')
    install.set_defaults(func=install_command)

    uninstall = subparsers.add_parser('uninstall', aliases=['un'], help='Uninstalles all services.')
    uninstall.set_defaults(func=uninstall_command)

    move = subparsers.add_parser('move', aliases=['mv'], help='Move a physical device into the physical namespace if it exists.')
    move.add_argument('INTERFACE', nargs=1, help='Interface name that will be moved.')
    move.set_defaults(func=move_command)

    rotate = subparsers.add_parser('rotate', help='Rotate WireGuard keys from all mapped peers.')
    rotate.add_argument('-p', '--passname', nargs=1, dest='passname', help='Request account number from pass.', default='web/mullvad')
    rotate.set_defaults(func=rotate_command)

    reset = subparsers.add_parser('reset', help='Tear down vpn, delete all mapped peers to this computer, remove services added through `vpn service` and remove account related information from configuration.')
    reset.add_argument('-p', '--passname', nargs=1, dest='passname', help='Request account number from pass.', default='web/mullvad')
    reset.set_defaults(func=reset_command)

    test = subparsers.add_parser('test', help='Run unittests.')
    test.add_argument('-d', '--docker', action='store_true', help='Run the tests in different docker images (archlinux, ubuntu, debian).')
    test.add_argument('-s', '--docker-skip-build', action='store_true', help='Skip docker build.')
    test.add_argument('UNITTEST_CMD', nargs=argparse.REMAINDER, help='Command(s) for unittest.')
    test.set_defaults(func=test_command)

    args = parser.parse_args()

    global VERBOSE
    VERBOSE = args.verbose

    global colored
    if args.no_color:
        colored = partial(colored, no_color=True)

    if args.print_args:
        if os.geteuid() == 0:
            print(args)

    try:
        if not 'func' in args:
            parser.print_help()
        elif args.func in [up_command, rotate_command]:
            args.func(args, up)
        else:
            args.func(args)
    except KeyboardInterrupt:
        sys.exit(1)
    except CommandFailed as e:
        # TODO: Should this only apply to the first `vad up`, and not to partial ups's?
        if args.func == up_command:
            log_warn("A command failed during `vad up`, to leave the network in a working state we will undo all changes with `vad down`.")
            # TODO: what to do with source and target namespace?
            down_command(Args(config=args.config, partial=False))
        sys.exit(e.returncode)
    except Abort:
        sys.exit(1)

if __name__ == "__main__":
    vad()
